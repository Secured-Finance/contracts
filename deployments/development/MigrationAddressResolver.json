{
  "address": "0x3fa5dB8bEe1275DC501A65009c4cEA128b82dBc5",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_addresses",
          "type": "address[]"
        }
      ],
      "name": "buildCaches",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xf790321769a925b9af61bd0385a97d2980681f20342e9678d39168de471eb88b",
  "receipt": {
    "to": null,
    "from": "0xDBA767F3DFF3835BEf5dE1eDEe91A9901402AB21",
    "contractAddress": "0x3fa5dB8bEe1275DC501A65009c4cEA128b82dBc5",
    "transactionIndex": 9,
    "gasUsed": "196489",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xdd35077e8cc82d2596714a5202346e1e01cbbbe03e7c07b1d95966c11bc749ce",
    "transactionHash": "0xf790321769a925b9af61bd0385a97d2980681f20342e9678d39168de471eb88b",
    "logs": [],
    "blockNumber": 11303733,
    "cumulativeGasUsed": "2056759",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "ffb1032f3699f9d3ed44e5ac1e696f7c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"buildCaches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Implements migration module to build caches of contract address from `AddressResolver.sol` in the contract that is inherited `MixinAddressResolver.sol`. This contract is used only in the following cases. - The case of the initial deployment of the contract. - The case when some contract needs to deploy a new proxy contract.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/migrations/MigrationAddressResolver.sol\":\"MigrationAddressResolver\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IAddressResolver {\\n    event AddressImported(bytes32 name, address destination);\\n\\n    function getAddress(bytes32 name, string calldata reason) external view returns (address);\\n\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function getAddresses() external view returns (address[] memory);\\n}\\n\",\"keccak256\":\"0x85fea92a32d4ac0f08532d339ceeef07a468748ab7628bd2fd60980090e53a5d\",\"license\":\"MIT\"},\"contracts/interfaces/ICollateralAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ICollateralAggregator {\\n    event Register(address indexed addr);\\n    event ReleaseUnsettled(address indexed party, bytes32 ccy, uint256 amount);\\n    event UseUnsettledCollateral(address indexed party, bytes32 ccy, uint256 amount);\\n\\n    function isCovered(address _user) external view returns (bool);\\n\\n    function isRegisteredUser(address addr) external view returns (bool);\\n\\n    function getWithdrawableCollateral(address _user) external view returns (uint256 maxWithdraw);\\n\\n    function getCoverage(address _user) external view returns (uint256 coverage);\\n\\n    function getUnsettledCollateral(address user, bytes32 ccy) external view returns (uint256);\\n\\n    function getUnusedCollateral(address _user) external view returns (uint256);\\n\\n    function getTotalUnsettledExposure(address _user) external view returns (uint256);\\n\\n    function getCollateralParameters()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function register() external;\\n\\n    function useUnsettledCollateral(\\n        address user,\\n        bytes32 ccy,\\n        uint256 amount\\n    ) external;\\n\\n    function releaseUnsettledCollateral(\\n        address user,\\n        bytes32 ccy,\\n        uint256 amount\\n    ) external;\\n\\n    function setCollateralParameters(\\n        uint256 marginCallThresholdRate,\\n        uint256 autoLiquidationThresholdRate,\\n        uint256 liquidationPriceRate,\\n        uint256 minCollateralRate\\n    ) external;\\n}\\n\",\"keccak256\":\"0x044f9ce00b347c34307571cb24b3d8c3435db583f9d92b5554dbf847f7fcd477\",\"license\":\"MIT\"},\"contracts/interfaces/ICollateralVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ICollateralVault {\\n    event Deposit(address user, bytes32 ccy, uint256 amount);\\n    event Withdraw(address from, bytes32 ccy, uint256 amount);\\n    event CurrencyRegistered(bytes32 ccy, address tokenAddress);\\n\\n    function deposit(bytes32 _ccy, uint256 _amount) external payable;\\n\\n    function getIndependentCollateral(address _user, bytes32 _ccy) external view returns (uint256);\\n\\n    function getIndependentCollateralInETH(address _user, bytes32 _ccy)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function withdraw(bytes32 _ccy, uint256 _amount) external;\\n\\n    function getUsedCurrencies(address user) external view returns (bytes32[] memory);\\n\\n    function getTotalIndependentCollateralInETH(address _party) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb67032b6e0eaf42b0eab142605bd2310d6432cee771ed1fe8a89546a7a1c2ef4\",\"license\":\"MIT\"},\"contracts/interfaces/ICurrencyController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../types/ProtocolTypes.sol\\\";\\n\\n/**\\n * @dev Currency Controller contract is responsible for managing supported\\n * currencies in Secured Finance Protocol\\n *\\n * Contract links new currencies to ETH Chainlink price feeds, without existing price feed\\n * contract owner is not able to add a new currency into the protocol\\n */\\ninterface ICurrencyController {\\n    event CcyAdded(bytes32 indexed ccy, string name, uint256 haircut);\\n    event CcyCollateralUpdate(bytes32 indexed ccy, bool isCollateral);\\n    event CcySupportUpdate(bytes32 indexed ccy, bool isSupported);\\n    event HaircutUpdated(bytes32 indexed ccy, uint256 haircut);\\n    event MinMarginUpdated(bytes32 indexed ccy, uint256 minMargin);\\n    event PriceFeedAdded(bytes32 ccy, string secondCcy, address indexed priceFeed);\\n    event PriceFeedRemoved(bytes32 ccy, string secondCcy, address indexed priceFeed);\\n\\n    function convertFromETH(bytes32 _ccy, uint256 _amountETH) external view returns (uint256);\\n\\n    function convertToETH(bytes32 _ccy, uint256 _amount) external view returns (uint256);\\n\\n    function convertToETH(bytes32 _ccy, int256 _amount) external view returns (int256);\\n\\n    function getCurrencies(bytes32) external view returns (ProtocolTypes.Currency memory);\\n\\n    function getEthDecimals(bytes32) external view returns (uint8);\\n\\n    function getUsdDecimals(bytes32) external view returns (uint8);\\n\\n    function getHaircut(bytes32 _ccy) external view returns (uint256);\\n\\n    function getHistoricalETHPrice(bytes32 _ccy, uint80 _roundId) external view returns (int256);\\n\\n    function getHistoricalUSDPrice(bytes32 _ccy, uint80 _roundId) external view returns (int256);\\n\\n    function getLastETHPrice(bytes32 _ccy) external view returns (int256);\\n\\n    function getLastUSDPrice(bytes32 _ccy) external view returns (int256);\\n\\n    function isCollateral(bytes32) external view returns (bool);\\n\\n    function isSupportedCcy(bytes32 _ccy) external view returns (bool);\\n\\n    function linkPriceFeed(\\n        bytes32 _ccy,\\n        address _priceFeedAddr,\\n        bool _isEthPriceFeed\\n    ) external returns (bool);\\n\\n    function removePriceFeed(bytes32 _ccy, bool _isEthPriceFeed) external;\\n\\n    function supportCurrency(\\n        bytes32 _ccy,\\n        string memory _name,\\n        address _ethPriceFeed,\\n        uint256 _haircut,\\n        address _tokenAddress\\n    ) external;\\n\\n    function updateCcyHaircut(bytes32 _ccy, uint256 _haircut) external;\\n\\n    function updateCollateralSupport(bytes32 _ccy, bool _isSupported) external;\\n\\n    function updateCurrencySupport(bytes32 _ccy, bool _isSupported) external;\\n\\n    function getTokenAddresses(bytes32) external view returns (address);\\n}\\n\",\"keccak256\":\"0x1956cb9ac170250917d9b284882bc10d0fd025198f7b3e711cb7acd089a74a79\",\"license\":\"MIT\"},\"contracts/interfaces/ILendingMarketController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../types/ProtocolTypes.sol\\\";\\n\\nstruct Order {\\n    bytes32 ccy;\\n    uint256 term;\\n    ProtocolTypes.Side side;\\n    uint256 amount;\\n    uint256 rate;\\n}\\n\\ninterface ILendingMarketController {\\n    event LendingMarketCreated(\\n        bytes32 ccy,\\n        address indexed marketAddr,\\n        uint256 index,\\n        uint256 maturity\\n    );\\n    event LendingMarketsRotated(bytes32 ccy, uint256 oldMaturity, uint256 newMaturity);\\n    event OrderFilled(\\n        address lender,\\n        address borrower,\\n        bytes32 ccy,\\n        uint256 maturity,\\n        uint256 amount,\\n        uint256 rate\\n    );\\n\\n    function getBasisDate(bytes32 _ccy) external view returns (uint256);\\n\\n    function getLendingMarkets(bytes32 _ccy) external view returns (address[] memory);\\n\\n    function getBorrowRates(bytes32 _ccy) external view returns (uint256[] memory rates);\\n\\n    function getLendRates(bytes32 _ccy) external view returns (uint256[] memory rates);\\n\\n    function getMidRates(bytes32 _ccy) external view returns (uint256[] memory rates);\\n\\n    function getMaturities(bytes32 _ccy) external view returns (uint256[] memory);\\n\\n    function getTotalPresentValue(bytes32 ccy, address account) external view returns (int256);\\n\\n    function getTotalPresentValueInETH(address account)\\n        external\\n        view\\n        returns (int256 totalPresentValue);\\n\\n    function getBeaconProxyAddress(bytes32 beaconName) external view returns (address);\\n\\n    function isInitializedLendingMarket(bytes32 _ccy) external view returns (bool);\\n\\n    function initializeLendingMarket(\\n        bytes32 _ccy,\\n        uint256 _basisDate,\\n        uint256 _compoundFactor\\n    ) external;\\n\\n    function setLendingMarketImpl(address newImpl) external;\\n\\n    function createLendingMarket(bytes32 _ccy) external returns (address market);\\n\\n    function rotateLendingMarkets(bytes32 _ccy) external;\\n\\n    function pauseLendingMarkets(bytes32 _ccy) external returns (bool);\\n\\n    function unpauseLendingMarkets(bytes32 _ccy) external returns (bool);\\n}\\n\",\"keccak256\":\"0xed9acb9480a8978d74a85f28af34684c7c93f7cd8d99af818f160364cfcb9ba0\",\"license\":\"MIT\"},\"contracts/libraries/Contracts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nlibrary Contracts {\\n    bytes32 internal constant COLLATERAL_AGGREGATOR = \\\"CollateralAggregator\\\";\\n    bytes32 internal constant COLLATERAL_VAULT = \\\"CollateralVault\\\";\\n    bytes32 internal constant CURRENCY_CONTROLLER = \\\"CurrencyController\\\";\\n    bytes32 internal constant LENDING_MARKET_CONTROLLER = \\\"LendingMarketController\\\";\\n}\\n\\nlibrary BeaconContracts {\\n    bytes32 internal constant LENDING_MARKET = \\\"LendingMarket\\\";\\n}\\n\",\"keccak256\":\"0xd2dc9d943f2de1871ee4ffa4b801291c2369985b61b40508576c8770aed8eff4\",\"license\":\"MIT\"},\"contracts/migrations/MigrationAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../mixins/MixinAddressResolver.sol\\\";\\n\\n/**\\n * @notice Implements migration module to build caches of contract address from `AddressResolver.sol`\\n * in the contract that is inherited `MixinAddressResolver.sol`.\\n *\\n * This contract is used only in the following cases.\\n * - The case of the initial deployment of the contract.\\n * - The case when some contract needs to deploy a new proxy contract.\\n */\\ncontract MigrationAddressResolver {\\n    function buildCaches(address[] calldata _addresses) external {\\n        for (uint256 i = 0; i < _addresses.length; i++) {\\n            MixinAddressResolver destination = MixinAddressResolver(_addresses[i]);\\n            if (!destination.isResolverCached()) {\\n                destination.buildCache();\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf678b4d0f17f8a9fa1ce4ded2a2659e52867bfaa5ac12d25a31ecc4e102126f9\",\"license\":\"MIT\"},\"contracts/mixins/MixinAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../libraries/Contracts.sol\\\";\\nimport \\\"../interfaces/IAddressResolver.sol\\\";\\nimport \\\"../interfaces/ICollateralAggregator.sol\\\";\\nimport \\\"../interfaces/ICollateralVault.sol\\\";\\nimport \\\"../interfaces/ICurrencyController.sol\\\";\\nimport \\\"../interfaces/ILendingMarketController.sol\\\";\\n\\ncontract MixinAddressResolver {\\n    event CacheUpdated(bytes32 name, address destination);\\n\\n    IAddressResolver public resolver;\\n\\n    mapping(bytes32 => address) private addressCache;\\n\\n    modifier onlyAcceptedContracts() {\\n        require(isAcceptedContract(msg.sender), \\\"Only Accepted Contracts\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns the contract names used in this contract.\\n     * @dev The contract name list is in `./libraries/Contracts.sol`.\\n     */\\n    function requiredContracts() public pure virtual returns (bytes32[] memory contracts) {}\\n\\n    /**\\n     * @notice Returns contract names that can call this contract.\\n     * @dev The contact name listed in this method is also needed to be listed `requiredContracts` method.\\n     */\\n    function acceptedContracts() public pure virtual returns (bytes32[] memory contracts) {}\\n\\n    function buildCache() public {\\n        // The resolver must call this function whenever it updates its state\\n        bytes32[] memory contractNames = requiredContracts();\\n        for (uint256 i = 0; i < contractNames.length; i++) {\\n            bytes32 name = contractNames[i];\\n            // Note: can only be invoked once the resolver has all the targets needed added\\n            address destination = resolver.getAddress(\\n                name,\\n                string(abi.encodePacked(\\\"Resolver missing target: \\\", name))\\n            );\\n            addressCache[name] = destination;\\n            emit CacheUpdated(name, destination);\\n        }\\n    }\\n\\n    function isResolverCached() external view returns (bool) {\\n        bytes32[] memory contractNames = requiredContracts();\\n        for (uint256 i = 0; i < contractNames.length; i++) {\\n            bytes32 name = contractNames[i];\\n            // false if our cache is invalid or if the resolver doesn't have the required address\\n            if (\\n                resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)\\n            ) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Register the Address Resolver contract\\n     * @param _resolver The address of the Address Resolver contract\\n     */\\n    function registerAddressResolver(address _resolver) internal {\\n        require(address(resolver) == address(0), \\\"resolver registered already\\\");\\n        resolver = IAddressResolver(_resolver);\\n    }\\n\\n    function getAddress(bytes32 name) internal view returns (address) {\\n        address _foundAddress = addressCache[name];\\n        require(_foundAddress != address(0), string(abi.encodePacked(\\\"Missing address: \\\", name)));\\n        return _foundAddress;\\n    }\\n\\n    function isAcceptedContract(address account) internal view virtual returns (bool) {\\n        bytes32[] memory contractNames = acceptedContracts();\\n        for (uint256 i = 0; i < contractNames.length; i++) {\\n            if (account == getAddress(contractNames[i])) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function collateralAggregator() internal view returns (ICollateralAggregator) {\\n        return ICollateralAggregator(getAddress(Contracts.COLLATERAL_AGGREGATOR));\\n    }\\n\\n    function collateralVault() internal view returns (ICollateralVault) {\\n        return ICollateralVault(getAddress(Contracts.COLLATERAL_VAULT));\\n    }\\n\\n    function currencyController() internal view returns (ICurrencyController) {\\n        return ICurrencyController(getAddress(Contracts.CURRENCY_CONTROLLER));\\n    }\\n\\n    function lendingMarketController() internal view returns (ILendingMarketController) {\\n        return ILendingMarketController(getAddress(Contracts.LENDING_MARKET_CONTROLLER));\\n    }\\n}\\n\",\"keccak256\":\"0x98a8ba49db3740dd8f058343297f54713fa6859f0aea363a5444063ef7a11f5b\",\"license\":\"MIT\"},\"contracts/types/ProtocolTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev ProtocolTypes is a base-level contract that holds common Secured Finance protocol types\\n * @author Secured Finance\\n */\\nlibrary ProtocolTypes {\\n    // Constant values\\n    uint256 public constant BP = 10000; // basis point\\n    uint256 public constant PCT = 10000; // percentage point in basis\\n    uint256 public constant PENALTYLEVEL = 1000; // 10% settlement failure penalty\\n    uint256 public constant MKTMAKELEVEL = 2000; // 20% for market making\\n\\n    uint256 internal constant DAYS_IN_YEAR = 365;\\n    uint256 internal constant SECONDS_IN_YEAR = 31557600;\\n\\n    // Lending market common types\\n    enum Side {\\n        LEND,\\n        BORROW\\n    }\\n    enum Ccy {\\n        ETH,\\n        FIL,\\n        USDC,\\n        BTC\\n    }\\n\\n    // Collateral common types\\n    enum CollateralState {\\n        EMPTY,\\n        AVAILABLE,\\n        IN_USE,\\n        MARGIN_CALL,\\n        LIQUIDATION_IN_PROGRESS,\\n        LIQUIDATION\\n    }\\n\\n    struct Currency {\\n        bool isSupported;\\n        string name;\\n    }\\n}\\n\",\"keccak256\":\"0xb7d72cd14320881eb1a6832ead684c89854fd643958d07e5d3476134f57328a8\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610298806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806367ba79c814610030575b600080fd5b61004361003e36600461015c565b610045565b005b60005b81811015610157576000838383818110610064576100646101d1565b905060200201602081019061007991906101e7565b9050806001600160a01b0316632af64bd36040518163ffffffff1660e01b815260040160206040518083038186803b1580156100b457600080fd5b505afa1580156100c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100ec9190610217565b61014457806001600160a01b03166329985e5a6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561012b57600080fd5b505af115801561013f573d6000803e3d6000fd5b505050505b508061014f81610239565b915050610048565b505050565b6000806020838503121561016f57600080fd5b823567ffffffffffffffff8082111561018757600080fd5b818501915085601f83011261019b57600080fd5b8135818111156101aa57600080fd5b8660208260051b85010111156101bf57600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052603260045260246000fd5b6000602082840312156101f957600080fd5b81356001600160a01b038116811461021057600080fd5b9392505050565b60006020828403121561022957600080fd5b8151801515811461021057600080fd5b600060001982141561025b57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220050dcaeb403ea3466b8539d427c786da245deccde38b1454610bed17457238b864736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c806367ba79c814610030575b600080fd5b61004361003e36600461015c565b610045565b005b60005b81811015610157576000838383818110610064576100646101d1565b905060200201602081019061007991906101e7565b9050806001600160a01b0316632af64bd36040518163ffffffff1660e01b815260040160206040518083038186803b1580156100b457600080fd5b505afa1580156100c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100ec9190610217565b61014457806001600160a01b03166329985e5a6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561012b57600080fd5b505af115801561013f573d6000803e3d6000fd5b505050505b508061014f81610239565b915050610048565b505050565b6000806020838503121561016f57600080fd5b823567ffffffffffffffff8082111561018757600080fd5b818501915085601f83011261019b57600080fd5b8135818111156101aa57600080fd5b8660208260051b85010111156101bf57600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052603260045260246000fd5b6000602082840312156101f957600080fd5b81356001600160a01b038116811461021057600080fd5b9392505050565b60006020828403121561022957600080fd5b8151801515811461021057600080fd5b600060001982141561025b57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220050dcaeb403ea3466b8539d427c786da245deccde38b1454610bed17457238b864736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Implements migration module to build caches of contract address from `AddressResolver.sol` in the contract that is inherited `MixinAddressResolver.sol`. This contract is used only in the following cases. - The case of the initial deployment of the contract. - The case when some contract needs to deploy a new proxy contract.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}