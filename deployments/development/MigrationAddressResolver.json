{
  "address": "0x780DE2317Efcd026996CAFCfF56809D3269e7a9D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_addresses",
          "type": "address[]"
        }
      ],
      "name": "buildCaches",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x7afdebdcab4ae94ef2014b023af3bd2b279942cc372fc14270a2fb1603d3902c",
  "receipt": {
    "to": null,
    "from": "0xDBA767F3DFF3835BEf5dE1eDEe91A9901402AB21",
    "contractAddress": "0x780DE2317Efcd026996CAFCfF56809D3269e7a9D",
    "transactionIndex": 6,
    "gasUsed": "196489",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x055da7b1904e177d7c118926eb10dd4bf8bc4bfbbafbe8615fe6d38fab662e01",
    "transactionHash": "0x7afdebdcab4ae94ef2014b023af3bd2b279942cc372fc14270a2fb1603d3902c",
    "logs": [],
    "blockNumber": 11471037,
    "cumulativeGasUsed": "4613709",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "c696f8ed857014a3081d8980e3d29f77",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"buildCaches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Implements migration module to build caches of contract address from `AddressResolver.sol` in the contract that is inherited `MixinAddressResolver.sol`. This contract is used only in the following cases. - The case of the initial deployment of the contract. - The case when some contract needs to deploy a new proxy contract.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/migrations/MigrationAddressResolver.sol\":\"MigrationAddressResolver\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0xf2b6c9adb3552254df1445b73563cf014434ff5e78663e9b961b6c059506ceb5\",\"license\":\"MIT\"},\"contracts/interfaces/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IAddressResolver {\\n    event AddressImported(bytes32 name, address destination);\\n\\n    function getAddress(bytes32 name, string calldata reason) external view returns (address);\\n\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function getAddresses() external view returns (address[] memory);\\n}\\n\",\"keccak256\":\"0x85fea92a32d4ac0f08532d339ceeef07a468748ab7628bd2fd60980090e53a5d\",\"license\":\"MIT\"},\"contracts/interfaces/IBeaconProxyController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IBeaconProxyController {\\n    event BeaconProxyCreated(\\n        bytes32 indexed id,\\n        address indexed proxyAddress,\\n        address indexed implementationAddress\\n    );\\n\\n    event BeaconProxyUpdated(\\n        bytes32 indexed id,\\n        address indexed proxyAddress,\\n        address indexed newImplementationAddress,\\n        address oldImplementationAddress\\n    );\\n\\n    function getBeaconProxyAddress(bytes32 beaconName) external view returns (address);\\n\\n    function setLendingMarketImpl(address newImpl) external;\\n\\n    function deployLendingMarket(\\n        bytes32 _ccy,\\n        uint256 _basisDate,\\n        uint256 _maturity\\n    ) external returns (address market);\\n}\\n\",\"keccak256\":\"0x96cc459c25a78e04ebc32cdf92437fb2e27d79b21c3ee53a003e4d71ff7a79fa\",\"license\":\"MIT\"},\"contracts/interfaces/ICurrencyController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {Currency} from \\\"../storages/CurrencyControllerStorage.sol\\\";\\n\\n/**\\n * @dev Currency Controller contract is responsible for managing supported\\n * currencies in Secured Finance Protocol\\n *\\n * Contract links new currencies to ETH Chainlink price feeds, without existing price feed\\n * contract owner is not able to add a new currency into the protocol\\n */\\ninterface ICurrencyController {\\n    event CcyAdded(bytes32 indexed ccy, string name, uint256 haircut);\\n    event CcySupportUpdate(bytes32 indexed ccy, bool isSupported);\\n    event HaircutUpdated(bytes32 indexed ccy, uint256 haircut);\\n    event PriceFeedAdded(bytes32 ccy, string secondCcy, address indexed priceFeed);\\n    event PriceFeedRemoved(bytes32 ccy, string secondCcy, address indexed priceFeed);\\n\\n    function convertFromETH(bytes32 _ccy, uint256 _amountETH) external view returns (uint256);\\n\\n    function convertToETH(bytes32 _ccy, uint256 _amount) external view returns (uint256);\\n\\n    function convertToETH(bytes32 _ccy, int256 _amount) external view returns (int256);\\n\\n    function getCurrencies(bytes32) external view returns (Currency memory);\\n\\n    function getEthDecimals(bytes32) external view returns (uint8);\\n\\n    function getUsdDecimals(bytes32) external view returns (uint8);\\n\\n    function getHaircut(bytes32 _ccy) external view returns (uint256);\\n\\n    function getHistoricalETHPrice(bytes32 _ccy, uint80 _roundId) external view returns (int256);\\n\\n    function getHistoricalUSDPrice(bytes32 _ccy, uint80 _roundId) external view returns (int256);\\n\\n    function getLastETHPrice(bytes32 _ccy) external view returns (int256);\\n\\n    function getLastUSDPrice(bytes32 _ccy) external view returns (int256);\\n\\n    function isSupportedCcy(bytes32 _ccy) external view returns (bool);\\n\\n    function linkPriceFeed(\\n        bytes32 _ccy,\\n        address _priceFeedAddr,\\n        bool _isEthPriceFeed\\n    ) external returns (bool);\\n\\n    function removePriceFeed(bytes32 _ccy, bool _isEthPriceFeed) external;\\n\\n    function supportCurrency(\\n        bytes32 _ccy,\\n        string memory _name,\\n        address _ethPriceFeed,\\n        uint256 _haircut\\n    ) external;\\n\\n    function updateCcyHaircut(bytes32 _ccy, uint256 _haircut) external;\\n\\n    function updateCurrencySupport(bytes32 _ccy, bool _isSupported) external;\\n}\\n\",\"keccak256\":\"0xdb2d6560f24ffc5cc53e0e7da9e8c5cf0f4c92385d549e60189ea01116b29ea5\",\"license\":\"MIT\"},\"contracts/interfaces/ILendingMarketController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../types/ProtocolTypes.sol\\\";\\n\\nstruct Order {\\n    bytes32 ccy;\\n    uint256 term;\\n    ProtocolTypes.Side side;\\n    uint256 amount;\\n    uint256 rate;\\n}\\n\\ninterface ILendingMarketController {\\n    event LendingMarketCreated(\\n        bytes32 ccy,\\n        address indexed marketAddr,\\n        uint256 index,\\n        uint256 maturity\\n    );\\n    event LendingMarketsRotated(bytes32 ccy, uint256 oldMaturity, uint256 newMaturity);\\n    event OrderFilled(\\n        address indexed taker,\\n        bytes32 indexed ccy,\\n        uint48[] orderIds,\\n        address[] makers,\\n        uint256[] amounts,\\n        ProtocolTypes.Side side,\\n        uint256 indexed maturity,\\n        uint256 rate\\n    );\\n    event OrderCanceled(\\n        uint48 orderId,\\n        address indexed maker,\\n        bytes32 indexed ccy,\\n        ProtocolTypes.Side side,\\n        uint256 maturity,\\n        uint256 amount,\\n        uint256 rate\\n    );\\n\\n    function getBasisDate(bytes32 _ccy) external view returns (uint256);\\n\\n    function getLendingMarkets(bytes32 _ccy) external view returns (address[] memory);\\n\\n    function getLendingMarket(bytes32 _ccy, uint256 _maturity) external view returns (address);\\n\\n    function getBorrowRates(bytes32 _ccy) external view returns (uint256[] memory rates);\\n\\n    function getLendRates(bytes32 _ccy) external view returns (uint256[] memory rates);\\n\\n    function getMidRates(bytes32 _ccy) external view returns (uint256[] memory rates);\\n\\n    function getMaturities(bytes32 _ccy) external view returns (uint256[] memory);\\n\\n    function getTotalPresentValue(bytes32 ccy, address account) external view returns (int256);\\n\\n    function getTotalPresentValueInETH(address account)\\n        external\\n        view\\n        returns (int256 totalPresentValue);\\n\\n    function isInitializedLendingMarket(bytes32 _ccy) external view returns (bool);\\n\\n    function initializeLendingMarket(\\n        bytes32 _ccy,\\n        uint256 _basisDate,\\n        uint256 _compoundFactor\\n    ) external;\\n\\n    function createLendingMarket(bytes32 _ccy) external returns (address market);\\n\\n    function createOrder(\\n        bytes32 _ccy,\\n        uint256 _maturity,\\n        ProtocolTypes.Side _side,\\n        uint256 _amount,\\n        uint256 _rate\\n    ) external returns (bool);\\n\\n    function createLendOrderWithETH(\\n        bytes32 _ccy,\\n        uint256 _maturity,\\n        uint256 _rate\\n    ) external payable returns (bool);\\n\\n    function matchOrders(\\n        bytes32 _ccy,\\n        uint256 _maturity,\\n        ProtocolTypes.Side _side,\\n        uint256 _amount,\\n        uint256 _rate\\n    ) external view returns (bool);\\n\\n    function cancelOrder(\\n        bytes32 _ccy,\\n        uint256 _maturity,\\n        uint48 _orderId\\n    ) external returns (bool);\\n\\n    function rotateLendingMarkets(bytes32 _ccy) external;\\n\\n    function pauseLendingMarkets(bytes32 _ccy) external returns (bool);\\n\\n    function unpauseLendingMarkets(bytes32 _ccy) external returns (bool);\\n}\\n\",\"keccak256\":\"0x866780f20768fdeda07eb8cfadb8f31faf93b052b7cb21bde4a6f93d473d4b88\",\"license\":\"MIT\"},\"contracts/interfaces/ITokenVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ITokenVault {\\n    event ReleaseUnsettled(address indexed party, bytes32 ccy, uint256 amount);\\n    event UseUnsettledCollateral(address indexed party, bytes32 ccy, uint256 amount);\\n\\n    event EscrowedAmountAdded(address indexed payer, bytes32 ccy, uint256 amount);\\n    event EscrowedAmountRemoved(\\n        address indexed payer,\\n        address indexed receiver,\\n        bytes32 ccy,\\n        uint256 amount\\n    );\\n\\n    event Deposit(address user, bytes32 ccy, uint256 amount);\\n    event Withdraw(address from, bytes32 ccy, uint256 amount);\\n    event CurrencyRegistered(bytes32 ccy, address tokenAddress);\\n\\n    function isCovered(address user) external view returns (bool);\\n\\n    function isRegisteredCurrency(bytes32 ccy) external view returns (bool);\\n\\n    function getWithdrawableCollateral(address user) external view returns (uint256 maxWithdraw);\\n\\n    function getCoverage(address user) external view returns (uint256 coverage);\\n\\n    function getUnsettledCollateral(address user, bytes32 ccy) external view returns (uint256);\\n\\n    function getUnusedCollateral(address user) external view returns (uint256);\\n\\n    function getTotalUnsettledExposure(address user) external view returns (uint256);\\n\\n    function getCollateralAmount(address user, bytes32 ccy) external view returns (uint256);\\n\\n    function getCollateralAmountInETH(address user, bytes32 ccy) external view returns (uint256);\\n\\n    function getTotalCollateralAmountInETH(address party) external view returns (uint256);\\n\\n    function getUsedCurrencies(address user) external view returns (bytes32[] memory);\\n\\n    function getCollateralParameters()\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function useUnsettledCollateral(\\n        address user,\\n        bytes32 ccy,\\n        uint256 amount\\n    ) external;\\n\\n    function releaseUnsettledCollateral(\\n        address user,\\n        address sender,\\n        bytes32 ccy,\\n        uint256 amount\\n    ) external;\\n\\n    function releaseUnsettledCollaterals(\\n        address sender,\\n        bytes32 ccy,\\n        address[] calldata users,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    function setCollateralParameters(\\n        uint256 marginCallThresholdRate,\\n        uint256 autoLiquidationThresholdRate,\\n        uint256 liquidationPriceRate,\\n        uint256 minCollateralRate\\n    ) external;\\n\\n    function deposit(bytes32 ccy, uint256 amount) external payable;\\n\\n    function withdraw(bytes32 ccy, uint256 amount) external;\\n\\n    function addEscrowedAmount(\\n        address payer,\\n        bytes32 ccy,\\n        uint256 amount\\n    ) external payable;\\n\\n    function removeEscrowedAmount(\\n        address payer,\\n        address receiver,\\n        bytes32 ccy,\\n        uint256 amount\\n    ) external;\\n\\n    function removeEscrowedAmounts(\\n        address receiver,\\n        bytes32 ccy,\\n        address[] calldata users,\\n        uint256[] calldata amounts\\n    ) external;\\n}\\n\",\"keccak256\":\"0x1db2fa8915c8a2cb11be96f780d09507d2addea9d8788fc5a63e1054a88a9e54\",\"license\":\"MIT\"},\"contracts/libraries/Contracts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nlibrary Contracts {\\n    bytes32 internal constant BEACON_PROXY_CONTROLLER = \\\"BeaconProxyController\\\";\\n    bytes32 internal constant CURRENCY_CONTROLLER = \\\"CurrencyController\\\";\\n    bytes32 internal constant LENDING_MARKET_CONTROLLER = \\\"LendingMarketController\\\";\\n    bytes32 internal constant TOKEN_VAULT = \\\"TokenVault\\\";\\n}\\n\\nlibrary BeaconContracts {\\n    bytes32 internal constant LENDING_MARKET = \\\"LendingMarket\\\";\\n}\\n\",\"keccak256\":\"0x993666b36062e56ab6ef4b22e095ea36d5353472fd0214ad2e35aefca61dd035\",\"license\":\"MIT\"},\"contracts/migrations/MigrationAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../mixins/MixinAddressResolver.sol\\\";\\n\\n/**\\n * @notice Implements migration module to build caches of contract address from `AddressResolver.sol`\\n * in the contract that is inherited `MixinAddressResolver.sol`.\\n *\\n * This contract is used only in the following cases.\\n * - The case of the initial deployment of the contract.\\n * - The case when some contract needs to deploy a new proxy contract.\\n */\\ncontract MigrationAddressResolver {\\n    function buildCaches(address[] calldata _addresses) external {\\n        for (uint256 i = 0; i < _addresses.length; i++) {\\n            MixinAddressResolver destination = MixinAddressResolver(_addresses[i]);\\n            if (!destination.isResolverCached()) {\\n                destination.buildCache();\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf678b4d0f17f8a9fa1ce4ded2a2659e52867bfaa5ac12d25a31ecc4e102126f9\",\"license\":\"MIT\"},\"contracts/mixins/MixinAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {Contracts} from \\\"../libraries/Contracts.sol\\\";\\nimport {IAddressResolver} from \\\"../interfaces/IAddressResolver.sol\\\";\\nimport {IBeaconProxyController} from \\\"../interfaces/IBeaconProxyController.sol\\\";\\nimport {ICurrencyController} from \\\"../interfaces/ICurrencyController.sol\\\";\\nimport {ILendingMarketController} from \\\"../interfaces/ILendingMarketController.sol\\\";\\nimport {ITokenVault} from \\\"../interfaces/ITokenVault.sol\\\";\\nimport {MixinAddressResolverStorage as Storage} from \\\"../storages/MixinAddressResolverStorage.sol\\\";\\n\\ncontract MixinAddressResolver {\\n    event CacheUpdated(bytes32 name, address destination);\\n\\n    modifier onlyAcceptedContracts() {\\n        require(isAcceptedContract(msg.sender), \\\"Only Accepted Contracts\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns the contract names used in this contract.\\n     * @dev The contract name list is in `./libraries/Contracts.sol`.\\n     */\\n    function requiredContracts() public pure virtual returns (bytes32[] memory contracts) {}\\n\\n    /**\\n     * @notice Returns contract names that can call this contract.\\n     * @dev The contact name listed in this method is also needed to be listed `requiredContracts` method.\\n     */\\n    function acceptedContracts() public pure virtual returns (bytes32[] memory contracts) {}\\n\\n    function buildCache() public {\\n        // The resolver must call this function whenever it updates its state\\n        bytes32[] memory contractNames = requiredContracts();\\n        for (uint256 i = 0; i < contractNames.length; i++) {\\n            bytes32 name = contractNames[i];\\n            // Note: can only be invoked once the resolver has all the targets needed added\\n            address destination = Storage.slot().resolver.getAddress(\\n                name,\\n                string(abi.encodePacked(\\\"Resolver missing target: \\\", name))\\n            );\\n            Storage.slot().addressCache[name] = destination;\\n            emit CacheUpdated(name, destination);\\n        }\\n    }\\n\\n    function isResolverCached() external view returns (bool) {\\n        bytes32[] memory contractNames = requiredContracts();\\n        for (uint256 i = 0; i < contractNames.length; i++) {\\n            bytes32 name = contractNames[i];\\n            // false if our cache is invalid or if the resolver doesn't have the required address\\n            if (\\n                Storage.slot().resolver.getAddress(name) != Storage.slot().addressCache[name] ||\\n                Storage.slot().addressCache[name] == address(0)\\n            ) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Register the Address Resolver contract\\n     * @param _resolver The address of the Address Resolver contract\\n     */\\n    function registerAddressResolver(address _resolver) internal {\\n        require(address(Storage.slot().resolver) == address(0), \\\"resolver registered already\\\");\\n        Storage.slot().resolver = IAddressResolver(_resolver);\\n    }\\n\\n    function getAddress(bytes32 name) internal view returns (address) {\\n        address _foundAddress = Storage.slot().addressCache[name];\\n        require(_foundAddress != address(0), string(abi.encodePacked(\\\"Missing address: \\\", name)));\\n        return _foundAddress;\\n    }\\n\\n    function isAcceptedContract(address account) internal view virtual returns (bool) {\\n        bytes32[] memory contractNames = acceptedContracts();\\n        for (uint256 i = 0; i < contractNames.length; i++) {\\n            if (account == getAddress(contractNames[i])) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function resolver() public view returns (IAddressResolver) {\\n        return Storage.slot().resolver;\\n    }\\n\\n    function beaconProxyController() internal view returns (IBeaconProxyController) {\\n        return IBeaconProxyController(getAddress(Contracts.BEACON_PROXY_CONTROLLER));\\n    }\\n\\n    function currencyController() internal view returns (ICurrencyController) {\\n        return ICurrencyController(getAddress(Contracts.CURRENCY_CONTROLLER));\\n    }\\n\\n    function lendingMarketController() internal view returns (ILendingMarketController) {\\n        return ILendingMarketController(getAddress(Contracts.LENDING_MARKET_CONTROLLER));\\n    }\\n\\n    function tokenVault() internal view returns (ITokenVault) {\\n        return ITokenVault(getAddress(Contracts.TOKEN_VAULT));\\n    }\\n}\\n\",\"keccak256\":\"0xac122cca03c2145dfeda4bcfd98f84a745575a7053c8b1dd87c41ab3cfd5aea4\",\"license\":\"MIT\"},\"contracts/storages/CurrencyControllerStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\n\\nstruct Currency {\\n    bool isSupported;\\n    string name;\\n}\\n\\nlibrary CurrencyControllerStorage {\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"sf.storage.currencyController\\\");\\n\\n    struct Storage {\\n        // Protocol currencies\\n        mapping(bytes32 => Currency) currencies;\\n        mapping(bytes32 => uint256) haircuts;\\n        // PriceFeed\\n        mapping(bytes32 => AggregatorV3Interface) usdPriceFeeds;\\n        mapping(bytes32 => AggregatorV3Interface) ethPriceFeeds;\\n        mapping(bytes32 => uint8) usdDecimals;\\n        mapping(bytes32 => uint8) ethDecimals;\\n    }\\n\\n    function slot() internal pure returns (Storage storage r) {\\n        bytes32 _slot = STORAGE_SLOT;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := _slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc0c9e9399e6f58e0702c8edcb6b58603d281668b10bf701b119911e24bba192b\",\"license\":\"MIT\"},\"contracts/storages/MixinAddressResolverStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport {IAddressResolver} from \\\"../interfaces/IAddressResolver.sol\\\";\\n\\nlibrary MixinAddressResolverStorage {\\n    bytes32 internal constant STORAGE_SLOT = keccak256(\\\"sf.storage.mixinAddressResolver\\\");\\n\\n    struct Storage {\\n        IAddressResolver resolver;\\n        mapping(bytes32 => address) addressCache;\\n    }\\n\\n    function slot() internal pure returns (Storage storage r) {\\n        bytes32 _slot = STORAGE_SLOT;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := _slot\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x852b885b6264a58930a0945c68842717e19f954eaefc0137235e6f263e17fa9d\",\"license\":\"MIT\"},\"contracts/types/ProtocolTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev ProtocolTypes is a base-level contract that holds common Secured Finance protocol types\\n * @author Secured Finance\\n */\\nlibrary ProtocolTypes {\\n    // Constant values\\n    uint256 public constant BP = 10000; // basis point\\n    uint256 public constant PCT = 10000; // percentage point in basis\\n\\n    uint256 internal constant DAYS_IN_YEAR = 365;\\n    uint256 internal constant SECONDS_IN_YEAR = 31557600;\\n\\n    // Lending market common types\\n    enum Side {\\n        LEND,\\n        BORROW\\n    }\\n    enum Ccy {\\n        ETH,\\n        FIL,\\n        USDC,\\n        BTC\\n    }\\n\\n    // Collateral common types\\n    enum CollateralState {\\n        EMPTY,\\n        AVAILABLE,\\n        IN_USE,\\n        MARGIN_CALL,\\n        LIQUIDATION_IN_PROGRESS,\\n        LIQUIDATION\\n    }\\n}\\n\",\"keccak256\":\"0xebb47b6088b7fa52e4cdab8da1f7ea06308d829aed07ceae13847cbeecea09ba\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610298806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806367ba79c814610030575b600080fd5b61004361003e36600461015c565b610045565b005b60005b81811015610157576000838383818110610064576100646101d1565b905060200201602081019061007991906101e7565b9050806001600160a01b0316632af64bd36040518163ffffffff1660e01b815260040160206040518083038186803b1580156100b457600080fd5b505afa1580156100c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100ec9190610217565b61014457806001600160a01b03166329985e5a6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561012b57600080fd5b505af115801561013f573d6000803e3d6000fd5b505050505b508061014f81610239565b915050610048565b505050565b6000806020838503121561016f57600080fd5b823567ffffffffffffffff8082111561018757600080fd5b818501915085601f83011261019b57600080fd5b8135818111156101aa57600080fd5b8660208260051b85010111156101bf57600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052603260045260246000fd5b6000602082840312156101f957600080fd5b81356001600160a01b038116811461021057600080fd5b9392505050565b60006020828403121561022957600080fd5b8151801515811461021057600080fd5b600060001982141561025b57634e487b7160e01b600052601160045260246000fd5b506001019056fea26469706673582212201c0e62679c9842ac1ad6794d0ecd6f2aab728308bd90613ef3b5b25e79bb976564736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c806367ba79c814610030575b600080fd5b61004361003e36600461015c565b610045565b005b60005b81811015610157576000838383818110610064576100646101d1565b905060200201602081019061007991906101e7565b9050806001600160a01b0316632af64bd36040518163ffffffff1660e01b815260040160206040518083038186803b1580156100b457600080fd5b505afa1580156100c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100ec9190610217565b61014457806001600160a01b03166329985e5a6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561012b57600080fd5b505af115801561013f573d6000803e3d6000fd5b505050505b508061014f81610239565b915050610048565b505050565b6000806020838503121561016f57600080fd5b823567ffffffffffffffff8082111561018757600080fd5b818501915085601f83011261019b57600080fd5b8135818111156101aa57600080fd5b8660208260051b85010111156101bf57600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052603260045260246000fd5b6000602082840312156101f957600080fd5b81356001600160a01b038116811461021057600080fd5b9392505050565b60006020828403121561022957600080fd5b8151801515811461021057600080fd5b600060001982141561025b57634e487b7160e01b600052601160045260246000fd5b506001019056fea26469706673582212201c0e62679c9842ac1ad6794d0ecd6f2aab728308bd90613ef3b5b25e79bb976564736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "notice": "Implements migration module to build caches of contract address from `AddressResolver.sol` in the contract that is inherited `MixinAddressResolver.sol`. This contract is used only in the following cases. - The case of the initial deployment of the contract. - The case when some contract needs to deploy a new proxy contract.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}