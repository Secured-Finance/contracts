{
  "language": "Solidity",
  "sources": {
    "contracts/AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./interfaces/IAddressResolver.sol\";\nimport \"./utils/Ownable.sol\";\nimport \"./utils/Proxyable.sol\";\nimport {AddressResolverStorage as Storage} from \"./storages/AddressResolverStorage.sol\";\n\ncontract AddressResolver is IAddressResolver, Ownable, Proxyable {\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(address owner) public initializer onlyProxy {\n        _transferOwnership(owner);\n    }\n\n    function importAddresses(bytes32[] memory _names, address[] memory _addresses)\n        public\n        onlyOwner\n    {\n        require(_names.length == _addresses.length, \"Input lengths must match\");\n\n        Storage.slot().addressCaches = _addresses;\n\n        for (uint256 i = 0; i < _names.length; i++) {\n            bytes32 name = _names[i];\n            address destination = _addresses[i];\n            Storage.slot().addresses[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    function areAddressesImported(bytes32[] calldata _names, address[] calldata _addresses)\n        external\n        view\n        returns (bool)\n    {\n        for (uint256 i = 0; i < _names.length; i++) {\n            if (Storage.slot().addresses[_names[i]] != _addresses[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 _name, string calldata _reason)\n        external\n        view\n        override\n        returns (address)\n    {\n        address _foundAddress = Storage.slot().addresses[_name];\n        require(_foundAddress != address(0), _reason);\n        return _foundAddress;\n    }\n\n    function getAddress(bytes32 _name) external view override returns (address) {\n        return Storage.slot().addresses[_name];\n    }\n\n    function getAddresses() external view override returns (address[] memory) {\n        return Storage.slot().addressCaches;\n    }\n}\n"
    },
    "contracts/interfaces/IAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IAddressResolver {\n    event AddressImported(bytes32 name, address destination);\n\n    function getAddress(bytes32 name, string calldata reason) external view returns (address);\n\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getAddresses() external view returns (address[] memory);\n}\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"../storages/OwnableStorage.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return OwnableStorage.slot().owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = OwnableStorage.slot().owner;\n        OwnableStorage.slot().owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/utils/Proxyable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nabstract contract Proxyable is Initializable {\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    modifier onlyProxy() {\n        require(_getImplementation() != address(0), \"Must be called from proxy contract\");\n        _;\n    }\n\n    function _getImplementation() private view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n}\n"
    },
    "contracts/storages/AddressResolverStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary AddressResolverStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.addressResolver\");\n\n    struct Storage {\n        // Mapping from contract name to contract address\n        mapping(bytes32 => address) addresses;\n        // Contract address list\n        address[] addressCaches;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/storages/OwnableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary OwnableStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.ownable\");\n\n    struct Storage {\n        address owner;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !Address.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/TermStructure.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./interfaces/ITermStructure.sol\";\nimport \"./libraries/QuickSort.sol\";\nimport \"./libraries/TermSchedule.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\nimport \"./utils/Ownable.sol\";\nimport \"./utils/Proxyable.sol\";\nimport {TermStructureStorage as Storage} from \"./storages/TermStructureStorage.sol\";\n\n/**\n * @dev Term Structure contract is responsible for managing supported\n * terms in Secured Finance Protocol per product and currency\n *\n */\ncontract TermStructure is ITermStructure, MixinAddressResolver, Ownable, Proxyable {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using QuickSort for uint256[];\n\n    modifier existingTermOnly(uint256 _numDays) {\n        require(Storage.slot().terms[_numDays] == _numDays, \"NON EXISTING TERM\");\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(address owner, address resolver) public initializer onlyProxy {\n        _transferOwnership(owner);\n        registerAddressResolver(resolver);\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](2);\n        contracts[0] = Contracts.CURRENCY_CONTROLLER;\n        contracts[1] = Contracts.PRODUCT_ADDRESS_RESOLVER;\n    }\n\n    /**\n     * @dev Triggers to add new term into the protocol\n     * @param _numDays Number of calendar days in a term\n     * @param _currencies Array of currencies supporting this term\n     * @param _products Array of products supporting this term\n     */\n    function supportTerm(\n        uint256 _numDays,\n        bytes4[] memory _products,\n        bytes32[] memory _currencies\n    ) public override onlyOwner {\n        Storage.slot().terms[_numDays] = _numDays;\n\n        if (_products.length > 0) {\n            for (uint256 i = 0; i < _products.length; i++) {\n                bytes4 product = _products[i];\n\n                for (uint256 j = 0; j < _currencies.length; j++) {\n                    bytes32 ccy = _currencies[j];\n                    updateTermSupport(_numDays, product, ccy, true);\n                }\n            }\n        }\n\n        emit TermAdded(_numDays);\n    }\n\n    /**\n     * @dev Triggers to update product and currency support for term\n     * @param _numDays Number of days in term\n     * @param _product Product prefix\n     * @param _ccy Currency short identifier\n     * @param _isSupported Boolean whether term supported for specified `_product` and `_ccy`\n     */\n    function updateTermSupport(\n        uint256 _numDays,\n        bytes4 _product,\n        bytes32 _ccy,\n        bool _isSupported\n    ) public override onlyOwner existingTermOnly(_numDays) {\n        require(productAddressResolver().isSupportedProduct(_product), \"NON SUPPORTED PRODUCT\");\n        require(currencyController().isSupportedCcy(_ccy), \"NON SUPPORTED CCY\");\n\n        if (_isSupported) {\n            Storage.slot().termsForProductAndCcy[_product][_ccy].add(_numDays);\n        } else {\n            Storage.slot().termsForProductAndCcy[_product][_ccy].remove(_numDays);\n        }\n\n        emit ProductTermSupportUpdated(_numDays, _product, _ccy, _isSupported);\n    }\n\n    /**\n     * @dev Triggers to get term structure.\n     * @param _numDays Number of days in term\n     */\n    function getTerm(uint256 _numDays, uint8 _frequency)\n        public\n        view\n        override\n        returns (\n            uint256 numDays,\n            uint256 dfFrac,\n            uint256 numPayments\n        )\n    {\n        numDays = Storage.slot().terms[_numDays];\n        dfFrac = getDfFrac(_numDays);\n        numPayments = getNumPayments(_numDays, _frequency);\n    }\n\n    /**\n     * @dev Triggers to get payment schedule for supported term according to the payment frequency\n     * number of days follows ACT365 market convention\n     * @param _numDays Number of days in term\n     * @param _frequency Payment frequency (like annual, semi-annual, etc.)\n     */\n    function getTermSchedule(uint256 _numDays, uint8 _frequency)\n        public\n        pure\n        override\n        returns (uint256[] memory)\n    {\n        return TermSchedule.getTermSchedule(_numDays, _frequency);\n    }\n\n    /**\n     * @dev Triggers to get number of days for supported term.\n     * number of days follows ACT365 market convention\n     * @param _numDays Number of days in term\n     */\n    function getNumDays(uint256 _numDays) public view override returns (uint256) {\n        return Storage.slot().terms[_numDays];\n    }\n\n    /**\n     * @dev Triggers to get discount factor fractions.\n     * @param _numDays Number of days in term\n     */\n    function getDfFrac(uint256 _numDays) public pure override returns (uint256) {\n        return TermSchedule.getDfFrac(_numDays);\n    }\n\n    /**\n     * @dev Triggers to get number of coupon payments.\n     * @param _numDays Number of days in term\n     * @param _frequency Payment frequency (like annual, semi-annual, etc.)\n     */\n    function getNumPayments(uint256 _numDays, uint8 _frequency)\n        public\n        pure\n        override\n        returns (uint256)\n    {\n        return TermSchedule.getNumPayments(_numDays, _frequency);\n    }\n\n    /**\n     * @dev Triggers to get if specified term is supported for a particular ccy and product.\n     * @param _numDays Number of days in term\n     * @param _product Product prefix\n     * @param _ccy Currency short identifier\n     */\n    function isSupportedTerm(\n        uint256 _numDays,\n        bytes4 _product,\n        bytes32 _ccy\n    ) public view override returns (bool) {\n        EnumerableSet.UintSet storage set = Storage.slot().termsForProductAndCcy[_product][_ccy];\n        return set.contains(_numDays);\n    }\n\n    /**\n     * @dev Returns an array of supported terms for a specific product and currency\n     * @param _product Product prefix\n     * @param _ccy Currency short identifier\n     */\n    function getTermsForProductAndCcy(\n        bytes4 _product,\n        bytes32 _ccy,\n        bool sort\n    ) public view override returns (uint256[] memory) {\n        EnumerableSet.UintSet storage set = Storage.slot().termsForProductAndCcy[_product][_ccy];\n        uint256 numTerms = set.length();\n        uint256[] memory supportedTerms = new uint256[](numTerms);\n\n        for (uint256 i = 0; i < numTerms; i++) {\n            uint256 term = set.at(i);\n            supportedTerms[i] = term;\n        }\n\n        if (sort) {\n            supportedTerms = supportedTerms.sort();\n        }\n\n        return supportedTerms;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/interfaces/ITermStructure.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ITermStructure {\n    event TermAdded(uint256 numDays);\n    event ProductTermSupportUpdated(\n        uint256 numDays,\n        bytes4 product,\n        bytes32 _ccy,\n        bool isSupported\n    );\n    event TermSupportUpdated(uint256 numDays, bool isSupported);\n\n    function getDfFrac(uint256 _numDays) external view returns (uint256);\n\n    function getNumDays(uint256 _numDays) external view returns (uint256);\n\n    function getNumPayments(uint256 _numDays, uint8 frequency) external view returns (uint256);\n\n    function getTerm(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getTermSchedule(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isSupportedTerm(\n        uint256 _numDays,\n        bytes4 _product,\n        bytes32 _ccy\n    ) external view returns (bool);\n\n    function supportTerm(\n        uint256 _numDays,\n        bytes4[] memory _products,\n        bytes32[] memory _currencies\n    ) external;\n\n    function updateTermSupport(\n        uint256 _numDays,\n        bytes4 _product,\n        bytes32 _ccy,\n        bool _isSupported\n    ) external;\n\n    function getTermsForProductAndCcy(\n        bytes4 _product,\n        bytes32 _ccy,\n        bool sort\n    ) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/libraries/QuickSort.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary QuickSort {\n    function sort(uint256[] memory data) public pure returns (uint256[] memory) {\n        quickSort(data, int256(0), int256(data.length - 1));\n        return data;\n    }\n\n    function quickSort(\n        uint256[] memory arr,\n        int256 left,\n        int256 right\n    ) internal pure {\n        int256 i = left;\n        int256 j = right;\n        if (i == j) return;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint256(i)] < pivot) i++;\n            while (pivot < arr[uint256(j)]) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\n                i++;\n                j--;\n            }\n        }\n        if (left < j) quickSort(arr, left, j);\n        if (i < right) quickSort(arr, i, right);\n    }\n}\n"
    },
    "contracts/libraries/TermSchedule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary TermSchedule {\n    enum PaymentFrequency {\n        ANNUAL,\n        SEMI_ANNUAL,\n        QUARTERLY,\n        MONTHLY,\n        FORWARD\n    }\n\n    /**\n     * @dev Triggers to get payment schedule for supported term according to the payment frequency\n     * number of days follows ACT365 market convention\n     * @param _numDays Number of days in term\n     * @param _frequency Payment frequency (like annual, semi-annual, etc.)\n     */\n    function getTermSchedule(uint256 _numDays, uint8 _frequency)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        if (PaymentFrequency(_frequency) == PaymentFrequency.ANNUAL) {\n            if (_numDays >= 365) {\n                uint256 numYears = _numDays / 365;\n                uint256[] memory paymentSchedule = new uint256[](numYears);\n\n                for (uint256 i = 0; i < numYears; i++) {\n                    uint256 j = i + 1;\n                    paymentSchedule[i] = j * 365;\n                }\n\n                return paymentSchedule;\n            } else if (_numDays > 0) {\n                uint256[] memory paymentSchedule = new uint256[](1);\n                paymentSchedule[0] = _numDays;\n\n                return paymentSchedule;\n            }\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.SEMI_ANNUAL) {\n            if (_numDays >= 180) {\n                uint256 numHalfYears = _numDays / 180;\n                uint256[] memory paymentSchedule = new uint256[](numHalfYears);\n\n                for (uint256 i = 0; i < numHalfYears; i++) {\n                    uint256 j = i + 1;\n                    paymentSchedule[i] = j * 180;\n                }\n\n                return paymentSchedule;\n            } else if (_numDays > 0) {\n                uint256[] memory paymentSchedule = new uint256[](1);\n                paymentSchedule[0] = _numDays;\n\n                return paymentSchedule;\n            }\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.QUARTERLY) {\n            if (_numDays >= 90) {\n                uint256 numQuarters = _numDays / 90;\n                uint256[] memory paymentSchedule = new uint256[](numQuarters);\n\n                for (uint256 i = 0; i < numQuarters; i++) {\n                    uint256 j = i + 1;\n                    paymentSchedule[i] = j * 90;\n                }\n\n                return paymentSchedule;\n            } else if (_numDays > 0) {\n                uint256[] memory paymentSchedule = new uint256[](1);\n                paymentSchedule[0] = _numDays;\n\n                return paymentSchedule;\n            }\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.MONTHLY) {\n            if (_numDays >= 30) {\n                uint256 numMonths = _numDays / 30;\n                uint256[] memory paymentSchedule = new uint256[](numMonths);\n\n                for (uint256 i = 0; i < numMonths; i++) {\n                    uint256 j = i + 1;\n                    paymentSchedule[i] = j * 30;\n                }\n\n                return paymentSchedule;\n            } else if (_numDays > 0) {\n                uint256[] memory paymentSchedule = new uint256[](1);\n                paymentSchedule[0] = _numDays;\n\n                return paymentSchedule;\n            }\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.FORWARD) {\n            uint256[] memory paymentSchedule = new uint256[](1);\n            paymentSchedule[0] = _numDays;\n\n            return paymentSchedule;\n        }\n    }\n\n    /**\n     * @dev Triggers to get discount factor fractions.\n     * @param _numDays Number of days in term\n     */\n    function getDfFrac(uint256 _numDays) internal pure returns (uint256) {\n        if (_numDays >= 365) {\n            return 10000;\n        } else if (_numDays < 365) {\n            uint256 sectors = uint256(360) / _numDays;\n            return uint256(10000) / sectors;\n        }\n    }\n\n    /**\n     * @dev Triggers to get number of coupon payments.\n     * @param _numDays Number of days in term\n     * @param _frequency Payment frequency (like annual, semi-annual, etc.)\n     */\n    function getNumPayments(uint256 _numDays, uint8 _frequency) internal pure returns (uint256) {\n        if (PaymentFrequency(_frequency) == PaymentFrequency.ANNUAL) {\n            if (_numDays >= 365) {\n                return _numDays / 365;\n            } else if (_numDays > 0) {\n                return 1;\n            } else return 0;\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.SEMI_ANNUAL) {\n            if (_numDays >= 365) {\n                uint256 _monthConvention = _numDays - (_numDays / 365) * 5;\n                return _monthConvention / 180;\n            } else if (_numDays >= 180) {\n                return _numDays / 180;\n            } else if (_numDays > 0) {\n                return 1;\n            } else return 0;\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.QUARTERLY) {\n            if (_numDays >= 365) {\n                uint256 _monthConvention = _numDays - (_numDays / 365) * 5;\n                return _monthConvention / 90;\n            } else if (_numDays >= 90) {\n                return _numDays / 90;\n            } else if (_numDays > 0) {\n                return 1;\n            } else return 0;\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.MONTHLY) {\n            if (_numDays >= 365) {\n                uint256 _monthConvention = _numDays - (_numDays / 365) * 5;\n                return _monthConvention / 30;\n            } else if (_numDays >= 30) {\n                return _numDays / 30;\n            } else if (_numDays > 0) {\n                return 1;\n            } else return 0;\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.FORWARD) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n}\n"
    },
    "contracts/mixins/MixinAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/Contracts.sol\";\nimport \"../interfaces/IAddressResolver.sol\";\nimport \"../interfaces/ICloseOutNetting.sol\";\nimport \"../interfaces/ICollateralAggregatorV2.sol\";\nimport \"../interfaces/ICollateralVault.sol\";\nimport \"../interfaces/ICrosschainAddressResolver.sol\";\nimport \"../interfaces/ICurrencyController.sol\";\nimport \"../interfaces/IMarkToMarket.sol\";\nimport \"../interfaces/ILendingMarketController.sol\";\nimport \"../interfaces/ILiquidations.sol\";\nimport \"../interfaces/IPaymentAggregator.sol\";\nimport \"../interfaces/IProductAddressResolver.sol\";\nimport \"../interfaces/ISettlementEngine.sol\";\nimport \"../interfaces/ITermStructure.sol\";\n\ncontract MixinAddressResolver {\n    event CacheUpdated(bytes32 name, address destination);\n\n    IAddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    modifier onlyAcceptedContracts() {\n        require(isAcceptedContract(msg.sender), \"Only Accepted Contracts\");\n        _;\n    }\n\n    /**\n     * @dev Returns required contract names in this contract\n     */\n    function requiredContracts() public pure virtual returns (bytes32[] memory contracts) {}\n\n    /**\n     * @dev Returns contract names that can call this contract.\n     */\n    function acceptedContracts() public pure virtual returns (bytes32[] memory contracts) {}\n\n    function buildCache() public {\n        // The resolver must call this function whenever it updates its state\n        bytes32[] memory contractNames = requiredContracts();\n        for (uint256 i = 0; i < contractNames.length; i++) {\n            bytes32 name = contractNames[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination = resolver.getAddress(\n                name,\n                string(abi.encodePacked(\"Resolver missing target: \", name))\n            );\n            addressCache[name] = destination;\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory contractNames = requiredContracts();\n        for (uint256 i = 0; i < contractNames.length; i++) {\n            bytes32 name = contractNames[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (\n                resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Register the Address Resolver contract\n     * @param _resolver The address of the Address Resolver contract\n     */\n    function registerAddressResolver(address _resolver) internal {\n        require(address(resolver) == address(0), \"resolver registered already\");\n        resolver = IAddressResolver(_resolver);\n    }\n\n    function getAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\n        return _foundAddress;\n    }\n\n    function isAcceptedContract(address account) internal view virtual returns (bool) {\n        bytes32[] memory contractNames = acceptedContracts();\n        for (uint256 i = 0; i < contractNames.length; i++) {\n            if (account == getAddress(contractNames[i])) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function closeOutNetting() internal view returns (ICloseOutNetting) {\n        return ICloseOutNetting(getAddress(Contracts.CLOSE_OUT_NETTING));\n    }\n\n    function collateralAggregator() internal view returns (ICollateralAggregator) {\n        return ICollateralAggregator(getAddress(Contracts.COLLATERAL_AGGREGATOR));\n    }\n\n    function collateralVault() internal view returns (ICollateralVault) {\n        return ICollateralVault(getAddress(Contracts.COLLATERAL_VAULT));\n    }\n\n    function crosschainAddressResolver() internal view returns (ICrosschainAddressResolver) {\n        return ICrosschainAddressResolver(getAddress(Contracts.CROSSCHAIN_ADDRESS_RESOLVER));\n    }\n\n    function currencyController() internal view returns (ICurrencyController) {\n        return ICurrencyController(getAddress(Contracts.CURRENCY_CONTROLLER));\n    }\n\n    function markToMarket() internal view returns (IMarkToMarket) {\n        return IMarkToMarket(getAddress(Contracts.MARK_TO_MARKET));\n    }\n\n    function lendingMarketController() internal view returns (ILendingMarketController) {\n        return ILendingMarketController(getAddress(Contracts.LENDING_MARKET_CONTROLLER));\n    }\n\n    function liquidations() internal view returns (ILiquidations) {\n        return ILiquidations(getAddress(Contracts.LIQUIDATIONS));\n    }\n\n    function paymentAggregator() internal view returns (IPaymentAggregator) {\n        return IPaymentAggregator(getAddress(Contracts.PAYMENT_AGGREGATOR));\n    }\n\n    function productAddressResolver() internal view returns (IProductAddressResolver) {\n        return IProductAddressResolver(getAddress(Contracts.PRODUCT_ADDRESS_RESOLVER));\n    }\n\n    function settlementEngine() internal view returns (ISettlementEngine) {\n        return ISettlementEngine(getAddress(Contracts.SETTLEMENT_ENGINE));\n    }\n\n    function termStructure() internal view returns (ITermStructure) {\n        return ITermStructure(getAddress(Contracts.TERM_STRUCTURE));\n    }\n}\n"
    },
    "contracts/storages/TermStructureStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../types/ProtocolTypes.sol\";\n\nlibrary TermStructureStorage {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.termStructure\");\n\n    struct Storage {\n        mapping(uint256 => uint256) terms;\n        mapping(bytes4 => mapping(bytes32 => EnumerableSet.UintSet)) termsForProductAndCcy;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "contracts/libraries/Contracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary Contracts {\n    bytes32 internal constant CLOSE_OUT_NETTING = \"CloseOutNetting\";\n    bytes32 internal constant COLLATERAL_AGGREGATOR = \"CollateralAggregator\";\n    bytes32 internal constant COLLATERAL_VAULT = \"CollateralVault\";\n    bytes32 internal constant CROSSCHAIN_ADDRESS_RESOLVER = \"CrosschainAddressResolver\";\n    bytes32 internal constant CURRENCY_CONTROLLER = \"CurrencyController\";\n    bytes32 internal constant LENDING_MARKET_CONTROLLER = \"LendingMarketController\";\n    bytes32 internal constant LIQUIDATIONS = \"Liquidations\";\n    bytes32 internal constant MARK_TO_MARKET = \"MarkToMarket\";\n    bytes32 internal constant PAYMENT_AGGREGATOR = \"PaymentAggregator\";\n    bytes32 internal constant PRODUCT_ADDRESS_RESOLVER = \"ProductAddressResolver\";\n    bytes32 internal constant SETTLEMENT_ENGINE = \"SettlementEngine\";\n    bytes32 internal constant TERM_STRUCTURE = \"TermStructure\";\n}\n"
    },
    "contracts/interfaces/ICloseOutNetting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ICloseOutNetting {\n    event AddCloseOutPayments(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    );\n    event RemoveCloseOutPayments(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    );\n    event SettleCloseOut(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 netPayment,\n        bytes32 txHash\n    );\n    event VerifyCloseOut(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 netPayment,\n        bytes32 txHash\n    );\n\n    function addPayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) external;\n\n    function checkDefault(address _party) external view returns (bool);\n\n    function removePayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) external;\n}\n"
    },
    "contracts/interfaces/ICollateralAggregatorV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ICollateralAggregator {\n    event Register(address indexed addr);\n    event Release(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    );\n    event Liquidate(address indexed from, address indexed to, bytes32 ccy, uint256 amount);\n    event ReleaseUnsettled(address indexed party, bytes32 ccy, uint256 amount);\n    event SettleCollateral(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    );\n    event UpdatePV(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    );\n    event UseCollateral(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    );\n    event UseUnsettledCollateral(address indexed party, bytes32 ccy, uint256 amount);\n\n    function checkRegisteredUser(address addr) external view returns (bool);\n\n    function getCcyExposures(\n        address partyA,\n        address partyB,\n        bytes32 ccy\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getCoverage(address _party0, address _party1) external view returns (uint256, uint256);\n\n    function getExposedCurrencies(address partyA, address partyB)\n        external\n        view\n        returns (bytes32[] memory);\n\n    function getMaxCollateralBookWidthdraw(address _user)\n        external\n        view\n        returns (uint256 maxWithdraw);\n\n    function getMaxCollateralWidthdraw(address _party0, address _party1)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getNetAndTotalPV(address _party0, address _party1)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getRebalanceCollateralAmounts(address _party0, address _party1)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getTotalUnsettledExp(address _user) external view returns (uint256);\n\n    function getUnsettledCoverage(address _user) external view returns (uint256 coverage);\n\n    function isCovered(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) external view returns (bool, bool);\n\n    function isCoveredUnsettled(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) external view returns (bool);\n\n    function liquidate(\n        address from,\n        address to,\n        uint256 liquidationInETH\n    ) external;\n\n    function liquidate(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 liquidationAmount,\n        uint256 pv,\n        bool isSettled\n    ) external;\n\n    function register() external;\n\n    function register(string[] memory _addresses, uint256[] memory _chainIds) external;\n\n    function releaseCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external;\n\n    function releaseUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external;\n\n    function settleCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    ) external;\n\n    function updatePV(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) external;\n\n    function useCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external;\n\n    function useUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external;\n\n    function getUnsettledCollateral(address user, bytes32 ccy) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICollateralVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ICollateralVault {\n    event Deposit(address user, bytes32 ccy, uint256 amount);\n    event PositionDeposit(address user, address counterparty, bytes32 ccy, uint256 amount);\n    event RebalanceBetween(\n        address user,\n        address fromCounterparty,\n        address toCounterparty,\n        bytes32 ccy,\n        uint256 amount\n    );\n    event RebalanceFrom(address user, address counterparty, bytes32 ccy, uint256 amount);\n    event RebalanceTo(address user, address counterparty, bytes32 ccy, uint256 amount);\n    event Withdraw(address from, bytes32 ccy, uint256 amount);\n    event PositionWithdraw(address from, address counterparty, bytes32 ccy, uint256 amount);\n    event Liquidate(address from, address to, bytes32 ccy, uint256 amount);\n    event LiquidateIndependent(address from, address to, bytes32 ccy, uint256 amount);\n\n    function deposit(\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _amount\n    ) external;\n\n    function deposit(bytes32 _ccy, uint256 _amount) external payable;\n\n    function getIndependentCollateral(address _user, bytes32 _ccy) external view returns (uint256);\n\n    function getIndependentCollateralInETH(address _user, bytes32 _ccy)\n        external\n        view\n        returns (uint256);\n\n    function getLockedCollateral(address _user, bytes32 _ccy) external view returns (uint256);\n\n    function getLockedCollateralInETH(address _user, bytes32 _ccy) external view returns (uint256);\n\n    function getLockedCollateral(\n        address _partyA,\n        address _partyB,\n        bytes32 _ccy\n    ) external view returns (uint256, uint256);\n\n    function getLockedCollateralInETH(\n        address _partyA,\n        address _partyB,\n        bytes32 _ccy\n    ) external view returns (uint256, uint256);\n\n    function liquidate(\n        address _from,\n        address _to,\n        uint256 _liquidationTarget\n    ) external returns (bool);\n\n    function rebalanceCollateral(\n        address _party0,\n        address _party1,\n        uint256 _rebalanceTarget,\n        bool isRebalanceFrom\n    ) external returns (bool);\n\n    function rebalanceBetween(\n        address _user,\n        address _fromParty,\n        address _toParty,\n        bytes32 _ccy,\n        uint256 _amountETH\n    ) external returns (uint256);\n\n    function withdraw(bytes32 _ccy, uint256 _amount) external;\n\n    function withdrawFrom(\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _amount\n    ) external;\n\n    function getUsedCurrencies(address user) external view returns (bytes32[] memory);\n\n    function getUsedCurrencies(address party0, address party1)\n        external\n        view\n        returns (bytes32[] memory);\n\n    function getTotalIndependentCollateralInETH(address _party) external view returns (uint256);\n\n    function getTotalLockedCollateralInETH(address _party0, address _party1)\n        external\n        view\n        returns (uint256, uint256);\n}\n"
    },
    "contracts/interfaces/ICrosschainAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ICrosschainAddressResolver {\n    event UpdateAddress(address _user, uint256 _chainId, string _address);\n\n    /**\n     * @dev Trigers to register multiple cross-chain addresses per chainId for user\n     * @param _user Secured Finance user ETH address\n     * @param _chainIds Array of chain ID number\n     * @param _addresses Array of the target blockchain addresses\n     *\n     * @notice This function triggers by the Collateral Aggregator while user is registered in a system\n     *\n     */\n    function updateAddresses(\n        address _user,\n        uint256[] memory _chainIds,\n        string[] memory _addresses\n    ) external;\n\n    /**\n     * @dev Trigers to register cross-chain address per chainId by user\n     * @param _chainId Chain ID number\n     * @param _address Target blockchain address\n     *\n     */\n    function updateAddress(uint256 _chainId, string memory _address) external;\n\n    /**\n     * @dev Trigers to register cross-chain address per chainId by user\n     * @param _user Secured Finance user ETH address\n     * @param _chainId Chain ID number\n     * @param _address Target blockchain address\n     *\n     */\n    function updateAddress(\n        address _user,\n        uint256 _chainId,\n        string memory _address\n    ) external;\n\n    /**\n     * @dev Trigers to get target blockchain address for a specific user.\n     * @param _user Ethereum address of the Secured Finance user\n     * @param _user Chain ID number\n     */\n    function getUserAddress(address _user, uint256 _chainId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/ICurrencyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../types/ProtocolTypes.sol\";\n\n/**\n * @dev Currency Controller contract is responsible for managing supported\n * currencies in Secured Finance Protocol\n *\n * Contract links new currencies to ETH Chainlink price feeds, without existing price feed\n * contract owner is not able to add a new currency into the protocol\n */\ninterface ICurrencyController {\n    event CcyAdded(bytes32 indexed ccy, string name, uint16 chainId, uint256 haircut);\n    event CcyCollateralUpdate(bytes32 indexed ccy, bool isCollateral);\n    event CcySupportUpdate(bytes32 indexed ccy, bool isSupported);\n    event HaircutUpdated(bytes32 indexed ccy, uint256 haircut);\n    event MinMarginUpdated(bytes32 indexed ccy, uint256 minMargin);\n    event PriceFeedAdded(bytes32 ccy, string secondCcy, address indexed priceFeed);\n    event PriceFeedRemoved(bytes32 ccy, string secondCcy, address indexed priceFeed);\n\n    function convertBulkToETH(bytes32 _ccy, uint256[] memory _amounts)\n        external\n        view\n        returns (uint256[] memory);\n\n    function convertFromETH(bytes32 _ccy, uint256 _amountETH) external view returns (uint256);\n\n    function convertToETH(bytes32 _ccy, uint256 _amount) external view returns (uint256);\n\n    function getCurrencies(bytes32) external view returns (ProtocolTypes.Currency memory);\n\n    function getEthDecimals(bytes32) external view returns (uint8);\n\n    function getUsdDecimals(bytes32) external view returns (uint8);\n\n    function getHaircut(bytes32 _ccy) external view returns (uint256);\n\n    function getHistoricalETHPrice(bytes32 _ccy, uint80 _roundId) external view returns (int256);\n\n    function getHistoricalUSDPrice(bytes32 _ccy, uint80 _roundId) external view returns (int256);\n\n    function getLastETHPrice(bytes32 _ccy) external view returns (int256);\n\n    function getLastUSDPrice(bytes32 _ccy) external view returns (int256);\n\n    function getMinMargin(bytes32 _ccy) external view returns (uint256);\n\n    function getChainId(bytes32 _ccy) external view returns (uint16);\n\n    function isCollateral(bytes32) external view returns (bool);\n\n    function isSupportedCcy(bytes32 _ccy) external view returns (bool);\n\n    function linkPriceFeed(\n        bytes32 _ccy,\n        address _priceFeedAddr,\n        bool _isEthPriceFeed\n    ) external returns (bool);\n\n    function removePriceFeed(bytes32 _ccy, bool _isEthPriceFeed) external;\n\n    function supportCurrency(\n        bytes32 _ccy,\n        string memory _name,\n        uint16 _chainId,\n        address _ethPriceFeed,\n        uint256 _haircut,\n        address _tokenAddress\n    ) external;\n\n    function updateCcyHaircut(bytes32 _ccy, uint256 _haircut) external;\n\n    function updateCollateralSupport(bytes32 _ccy, bool _isSupported) external;\n\n    function updateCurrencySupport(bytes32 _ccy, bool _isSupported) external;\n\n    function updateMinMargin(bytes32 _ccy, uint256 _minMargin) external;\n\n    function getTokenAddresses(bytes32) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IMarkToMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IMarkToMarket {\n    function updatePV(bytes32 dealId) external;\n\n    function updatePVs(bytes32[] memory dealIds) external;\n}\n"
    },
    "contracts/interfaces/ILendingMarketController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../types/ProtocolTypes.sol\";\n\nstruct Order {\n    bytes32 ccy;\n    uint256 term;\n    ProtocolTypes.Side side;\n    uint256 amount;\n    uint256 rate;\n}\n\ninterface ILendingMarketController {\n    event LendingMarketCreated(bytes32 ccy, uint256 term, address indexed marketAddr);\n    event LendingMarketsPaused(bytes32 ccy);\n    event LendingMarketsUnpaused(bytes32 ccy);\n\n    function deployLendingMarket(bytes32 _ccy, uint256 _term) external returns (address market);\n\n    function getBorrowRatesForCcy(bytes32 _ccy) external view returns (uint256[] memory rates);\n\n    function getDiscountFactorsForCcy(bytes32 _ccy)\n        external\n        view\n        returns (uint256[] memory, uint256[] memory);\n\n    function getLendRatesForCcy(bytes32 _ccy) external view returns (uint256[] memory rates);\n\n    function getMidRatesForCcy(bytes32 _ccy) external view returns (uint256[] memory rates);\n\n    function getLendingMarket(bytes32, uint256) external view returns (address);\n\n    function pauseLendingMarkets(bytes32 _ccy) external returns (bool);\n\n    function placeBulkOrders(Order[] memory orders) external returns (bool);\n\n    function unpauseLendingMarkets(bytes32 _ccy) external returns (bool);\n\n    function getSupportedTerms(bytes32 _ccy) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/interfaces/ILiquidations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface ILiquidations {\n    event DealAddedToLiquidationQueue(address party0, address party1, bytes32 dealId);\n    event DealRemovedFromLiquidationQueue(address party0, address party1, bytes32 dealId);\n    event LiquidationAgentAdded(address indexed liquidationAgent);\n    event LiquidationAgentRemoved(address indexed liquidationAgent);\n    event OffsetUpdated(uint256 oldOffset, uint256 newOffset);\n\n    function addDealToLiquidationQueue(\n        address party0,\n        address party1,\n        bytes32 dealId\n    ) external;\n\n    function addLiquidationAgent(address _liquidationAgent) external;\n\n    function liquidateDeals(\n        address party0,\n        address party1,\n        bytes32[] memory dealIds\n    ) external;\n\n    function liquidateDeals(address party0, address party1) external;\n\n    function getOffset() external view returns (uint256);\n\n    function removeDealFromLiquidationQueue(\n        address party0,\n        address party1,\n        bytes32 dealId\n    ) external;\n\n    function removeLiquidationAgent(address _liquidationAgent) external;\n\n    function updateLiquidationOffset(uint256 _offset) external;\n}\n"
    },
    "contracts/interfaces/IPaymentAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nstruct Slot {\n    uint256 totalPayment0;\n    uint256 totalPayment1;\n    uint256 netPayment;\n    bool flipped;\n    bytes32 paymentProof;\n    address verificationParty;\n    bool isSettled;\n}\n\ninterface IPaymentAggregator {\n    event RegisterPayment(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        bytes32 timeSlot,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 payment0,\n        uint256 payment1\n    );\n    event VerifyPayment(\n        address indexed verifier,\n        address indexed counterparty,\n        bytes32 ccy,\n        bytes32 timeSlot,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 payment,\n        bytes32 settlementId\n    );\n    event SettlePayment(\n        address indexed verifier,\n        address indexed counterparty,\n        bytes32 ccy,\n        bytes32 timeSlot,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        bytes32 settlementId\n    );\n    event RemovePayment(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        bytes32 timeSlot,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 payment0,\n        uint256 payment1\n    );\n\n    function registerPayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] memory timestamps,\n        uint256[] memory payments0,\n        uint256[] memory payments1\n    ) external;\n\n    function removePayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] calldata timestamps,\n        uint256[] calldata payments0,\n        uint256[] calldata payments1\n    ) external;\n\n    function verifyPayment(\n        address verifier,\n        address counterparty,\n        bytes32 ccy,\n        uint256 timestamp,\n        uint256 payment,\n        bytes32 settlementId\n    ) external;\n\n    function isSettled(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 timestamp\n    ) external view returns (bool status);\n\n    function getDealsFromSlot(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slotPosition\n    ) external view returns (bytes32[] memory);\n\n    // function getTimeSlotByDate(\n    //     address party0,\n    //     address party1,\n    //     bytes32 ccy,\n    //     uint256 year,\n    //     uint256 month,\n    //     uint256 day\n    // ) external view returns (Slot memory timeSlot);\n\n    // function getTimeSlotBySlotId(\n    //     address party0,\n    //     address party1,\n    //     bytes32 ccy,\n    //     bytes32 slot\n    // ) external view returns (Slot memory timeSlot);\n\n    function checkSettlementWindow(uint256 targetTime) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IProductAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IProductAddressResolver {\n    event RegisterProduct(bytes4 prefix, address indexed product, address indexed controller);\n\n    /**\n     * @dev Triggers to register new product type in a address resolver\n     * @param _prefix Bytes4 prefix for product type\n     * @param _contract Product contract address\n     * @param _controller Market controller address\n     *\n     * @notice Triggers only be contract owner\n     * @notice Reverts on saving contract which is not supporting a common interface\n     */\n    function registerProduct(\n        bytes4 _prefix,\n        address _contract,\n        address _controller\n    ) external;\n\n    /**\n     * @dev Triggers to register several product types in a address resolver\n     * @param _prefixes Array of Bytes4 prefixes for each product type\n     * @param _contracts Array of smart contract addresses for each product\n     * @param _controllers Array of market controller addresses\n     *\n     * @notice Triggers only be contract owner\n     * @notice Reverts on saving contract which is not supporting common interface\n     */\n    function registerProducts(\n        bytes4[] calldata _prefixes,\n        address[] calldata _contracts,\n        address[] calldata _controllers\n    ) external;\n\n    /**\n     * @dev Triggers to get product address by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     * @notice To work with the contract this address should be wrapped around IProduct interface\n     */\n    function getProductContract(bytes4 _prefix) external view returns (address);\n\n    /**\n     * @dev Triggers to get product addresses\n     * @notice To work with the contract this address should be wrapped around IProduct interface\n     */\n    function getProductContracts() external view returns (address[] memory);\n\n    /**\n     * @dev Triggers to get product address by deal id\n     * @param _dealId Product deal idenfitier\n     * @notice To work with the contract this address should be wrapped around IProduct interface\n     */\n    function getProductContractByDealId(bytes32 _dealId) external view returns (address);\n\n    /**\n     * @dev Triggers to get market controller address by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\n     */\n    function getControllerContract(bytes4 _prefix) external view returns (address);\n\n    /**\n     * @dev Triggers to get market controller address by deal id\n     * @param _dealId Product deal idenfitier\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\n     */\n    function getControllerContractByDealId(bytes32 _dealId) external view returns (address);\n\n    /**\n     * @dev Triggers to verify if a specific product is supported by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     */\n    function isSupportedProduct(bytes4 _prefix) external view returns (bool);\n\n    /**\n     * @dev Triggers to verify if a specific product is supported by deal id.\n     * @param _dealId Product deal idenfitier\n     */\n    function isSupportedProductByDealId(bytes32 _dealId) external view returns (bool);\n\n    /**\n     * @dev Triggers to verify if a specific product contract is registered.\n     * @param _product Product contract address\n     */\n    function isRegisteredProductContract(address _product) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ISettlementEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity ^0.8.9;\n\nimport \"./IExternalAdapterTxResponse.sol\";\nimport \"../types/ProtocolTypes.sol\";\n\ninterface ISettlementEngine {\n    event CrosschainSettlementRequested(\n        address payer,\n        address receiver,\n        uint16 chainId,\n        uint256 timestamp,\n        string txHash,\n        bytes32 requestId\n    );\n    event CrosschainSettlementRequestFulfilled(\n        string payer,\n        string receiver,\n        uint16 chainId,\n        uint256 amount,\n        uint256 timestamp,\n        string txHash,\n        bytes32 settlementId\n    );\n    event ExternalAdapterAdded(address indexed adapter, bytes32 ccy);\n\n    function addExternalAdapter(address _adapter, bytes32 _ccy) external;\n\n    function getExternalAdapters(bytes32) external view returns (address);\n\n    function fulfillSettlementRequest(\n        bytes32 _requestId,\n        IExternalAdapterTxResponse.FulfillData calldata _txData,\n        bytes32 _ccy\n    ) external;\n\n    function getVersion() external view returns (uint16);\n\n    function getSettlementRequests(bytes32)\n        external\n        view\n        returns (ProtocolTypes.SettlementRequest memory);\n\n    function verifyPayment(\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _payment,\n        uint256 _timestamp,\n        string calldata _txHash\n    ) external payable returns (bytes32);\n}\n"
    },
    "contracts/types/ProtocolTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @dev ProtocolTypes is a base-level contract that holds common Secured Finance protocol types\n * @author Secured Finance\n */\nlibrary ProtocolTypes {\n    // Constant values\n    uint256 public constant BP = 10000; // basis point\n    uint256 public constant PCT = 10000; // percentage point in basis\n    uint256 public constant PENALTYLEVEL = 1000; // 10% settlement failure penalty\n    uint256 public constant MKTMAKELEVEL = 2000; // 20% for market making\n\n    // Lending market common types\n    enum Side {\n        LEND,\n        BORROW\n    }\n    enum Ccy {\n        ETH,\n        FIL,\n        USDC,\n        BTC\n    }\n\n    // Loan common types\n    enum LoanState {\n        REGISTERED,\n        WORKING,\n        DUE,\n        PAST_DUE,\n        CLOSED,\n        TERMINATED\n    }\n    enum DFTERM {\n        _3m,\n        _6m,\n        _1y,\n        _2y,\n        _3y,\n        _4y,\n        _5y\n    }\n\n    // Collateral common types\n    enum CollateralState {\n        EMPTY,\n        AVAILABLE,\n        IN_USE,\n        MARGIN_CALL,\n        LIQUIDATION_IN_PROGRESS,\n        LIQUIDATION\n    }\n\n    // FXMarket common types\n    enum CcyPair {\n        FILETH,\n        FILUSDC,\n        ETHUSDC,\n        BTCUSDC,\n        BTCETH,\n        BTCFIL\n    }\n    enum FXSide {\n        BID,\n        OFFER\n    }\n\n    enum PaymentFrequency {\n        ANNUAL,\n        SEMI_ANNUAL,\n        QUARTERLY,\n        MONTHLY,\n        FORWARD\n    }\n\n    struct Currency {\n        bool isSupported;\n        string name;\n        uint16 chainId; // chain id for address conversion\n    }\n\n    struct SettlementRequest {\n        address payer;\n        address receiver;\n        uint16 chainId;\n        uint256 timestamp;\n        string txHash;\n    }\n}\n"
    },
    "contracts/interfaces/IExternalAdapterTxResponse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IExternalAdapterTxResponse {\n    struct FulfillData {\n        string from;\n        string to;\n        uint256 value;\n        uint256 timestamp;\n        string txHash;\n    }\n}\n"
    },
    "contracts/test/TermStructureTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../TermStructure.sol\";\n\ncontract TermStructureTest is TermStructure {\n    function getGasCostOfGetTerm(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        getTerm(_numDays, frequency);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetTermSchedule(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        getTermSchedule(_numDays, frequency);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetNumDays(uint256 _numDays) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        getNumDays(_numDays);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetDfFrac(uint256 _numDays) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        getDfFrac(_numDays);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetNumPayments(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        getNumPayments(_numDays, frequency);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfIsSupportedTerm(\n        uint256 _numDays,\n        bytes4 _product,\n        bytes32 _ccy\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        isSupportedTerm(_numDays, _product, _ccy);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetTermsForProductAndCcy(\n        bytes4 _product,\n        bytes32 _ccy,\n        bool sort\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        getTermsForProductAndCcy(_product, _ccy, sort);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/storages/SettlementEngineStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../types/ProtocolTypes.sol\";\n\nlibrary SettlementEngineStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.settlementEngine\");\n\n    struct Storage {\n        // Mapping to external providers addresses by Chain Ids\n        // for ETH-based currencies there is no need for external adapters\n        mapping(uint16 => address) externalAdapters;\n        // Mapping of cross-chain settlement requests per requestId\n        mapping(bytes32 => ProtocolTypes.SettlementRequest) settlementRequests;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "contracts/SettlementEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./libraries/Strings.sol\";\nimport \"./libraries/SafeTransfer.sol\";\nimport \"./interfaces/IExternalAdapter.sol\";\nimport \"./interfaces/ISettlementEngine.sol\";\nimport \"./interfaces/IExternalAdapterTxResponse.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\nimport \"./utils/Ownable.sol\";\nimport \"./utils/Proxyable.sol\";\nimport \"./types/ProtocolTypes.sol\";\nimport {SettlementEngineStorage as Storage} from \"./storages/SettlementEngineStorage.sol\";\n\n/**\n * @title Settlement Engine contract is used in settlement operations\n * of the Secured Finance protocol. Settlement is divided per 1 calendar\n * day and verified by either external adapters (for cross-chain transaction)\n * or native ETH-chain settlement.\n *\n * Contract linked to the PaymentAggregator contract and all External Adapters per target chain.\n */\ncontract SettlementEngine is\n    ISettlementEngine,\n    IExternalAdapterTxResponse,\n    MixinAddressResolver,\n    SafeTransfer,\n    Ownable,\n    Proxyable\n{\n    using Address for address;\n    using Strings for string;\n\n    uint16 private constant VERSION = 1;\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(\n        address owner,\n        address resolver,\n        address WETH9\n    ) public initializer onlyProxy {\n        _transferOwnership(owner);\n        _registerToken(WETH9);\n        registerAddressResolver(resolver);\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](3);\n        contracts[0] = Contracts.CROSSCHAIN_ADDRESS_RESOLVER;\n        contracts[1] = Contracts.CURRENCY_CONTROLLER;\n        contracts[2] = Contracts.PAYMENT_AGGREGATOR;\n    }\n\n    /**\n     * @dev Triggers to add new external adapter for specific `_ccy`\n     * @param _adapter External adapter contract address\n     * @param _ccy Short identifier of a currency\n     *\n     * @notice Triggers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function addExternalAdapter(address _adapter, bytes32 _ccy) public override onlyOwner {\n        require(_adapter.isContract(), \"NOT_CONTRACT\");\n        require(currencyController().isSupportedCcy(_ccy), \"NON_SUPPORTED_CCY\");\n\n        uint16 chainId = currencyController().getChainId(_ccy);\n        require(chainId != 60, \"NOT_ANOTHER_CHAIN\");\n\n        Storage.slot().externalAdapters[chainId] = _adapter;\n\n        emit ExternalAdapterAdded(_adapter, _ccy);\n    }\n\n    /**\n     * @dev Triggers to get external adapter for specific currency.\n     * @param _ccy Short identifier of a currency\n     */\n    function getExternalAdapters(bytes32 _ccy) external view returns (address) {\n        uint16 chainId = currencyController().getChainId(_ccy);\n        return Storage.slot().externalAdapters[chainId];\n    }\n\n    /**\n     * @dev Triggers to get settlement request\n     * @param _requestId The id to specify a request\n     */\n    function getSettlementRequests(bytes32 _requestId)\n        external\n        view\n        returns (ProtocolTypes.SettlementRequest memory)\n    {\n        return Storage.slot().settlementRequests[_requestId];\n    }\n\n    /**\n     * @dev External function to verify payment by msg.sender as a part of a settlement process\n     * It could validate either a cross-chain settlement or native settlement\n     * @param _counterparty Counterparty address\n     * @param _ccy Main payment settlement currency\n     * @param _payment Payment amount in currency\n     * @param _timestamp Timeslot timestamp for settlement operation\n     * @param _txHash Cross-chain transfer txHash\n     */\n    function verifyPayment(\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _payment,\n        uint256 _timestamp,\n        string memory _txHash\n    ) external payable override returns (bytes32) {\n        // TODO: add a way for third party to trigger ERC20 approved coupon payments\n        uint16 chainId = currencyController().getChainId(_ccy);\n        bytes32 requestId;\n\n        require(\n            !paymentAggregator().isSettled(msg.sender, _counterparty, _ccy, _timestamp),\n            \"TIMESLOT_SETTLED_ALREADY\"\n        );\n\n        if (chainId == 60) {\n            _performNativeSettlement(msg.sender, _counterparty, _ccy, _payment, _timestamp);\n        } else {\n            requestId = _performCrosschainSettlement(\n                msg.sender,\n                _counterparty,\n                chainId,\n                _timestamp,\n                _txHash\n            );\n        }\n\n        return requestId;\n    }\n\n    /**\n     * @dev External function to fulfill cross-chain settlement request.\n     * Expects to get transaction object to validate the correct settlement values\n     * on the PaymentAggregator contract level\n     * @param _txData Transaction object from external adapter\n     * @param _ccy Main currency of the external adapter\n     *\n     * @notice Triggers only be external adapter for specific chain\n     */\n    function fulfillSettlementRequest(\n        bytes32 _requestId,\n        FulfillData memory _txData,\n        bytes32 _ccy\n    ) external override {\n        uint16 chainId = currencyController().getChainId(_ccy);\n        require(Storage.slot().externalAdapters[chainId] == msg.sender, \"NOT_EXTERNAL_ADAPTER\");\n\n        ProtocolTypes.SettlementRequest memory request = Storage.slot().settlementRequests[\n            _requestId\n        ];\n        _validateSettlementRequest(chainId, request, _txData);\n\n        bytes32 _settlementId = keccak256(abi.encodePacked(_txData.txHash));\n\n        paymentAggregator().verifyPayment(\n            request.payer,\n            request.receiver,\n            _ccy,\n            request.timestamp,\n            _txData.value,\n            _settlementId\n        );\n\n        emit CrosschainSettlementRequestFulfilled(\n            _txData.from,\n            _txData.to,\n            chainId,\n            _txData.value,\n            _txData.timestamp,\n            _txData.txHash,\n            _settlementId\n        );\n\n        delete Storage.slot().settlementRequests[_requestId];\n    }\n\n    // TODO: Add cancel external adapter request function\n\n    /**\n     * @dev Internal function to create a settlement validation request for an external adapter\n     * @param _payer Payer of the settlement transfer\n     * @param _counterparty Receiver of the settlement transfer\n     * @param _chainId Target chain id\n     * @param _txHash Target chain transaction hash\n     */\n    function _performCrosschainSettlement(\n        address _payer,\n        address _counterparty,\n        uint16 _chainId,\n        uint256 _timestamp,\n        string memory _txHash\n    ) internal returns (bytes32) {\n        require(msg.value == 0, \"INCORRECT_ETH_VALUE\");\n        require(paymentAggregator().checkSettlementWindow(_timestamp), \"OUT_OF_SETTLEMENT_WINDOW\");\n\n        address adapterAddr = Storage.slot().externalAdapters[_chainId];\n        require(adapterAddr != address(0), \"ADAPTER_DOESN'T_EXIST\");\n        IExternalAdapter adapter = IExternalAdapter(adapterAddr);\n\n        bytes32 requestId = adapter.createRequest(_txHash);\n        // TODO: make sure we're not duplicating requests with the same txHashes\n        // on external adapter contract\n\n        Storage.slot().settlementRequests[requestId] = ProtocolTypes.SettlementRequest({\n            payer: _payer,\n            receiver: _counterparty,\n            chainId: _chainId,\n            timestamp: _timestamp,\n            txHash: _txHash\n        });\n\n        emit CrosschainSettlementRequested(\n            _payer,\n            _counterparty,\n            _chainId,\n            _timestamp,\n            _txHash,\n            requestId\n        );\n\n        return requestId;\n    }\n\n    /**\n     * @dev Internal function to settle payments on native ETH-based settlement.\n     * If currency is a ERC20 token it would transfer the `_payment` amount of tokens\n     * from msg.sender to `_counterparty` address.\n     * If currency is ETH, native Ether would be transfered accordingly\n     *\n     * @param _payer Payment sender address\n     * @param _counterparty Payment receiver address\n     * @param _ccy Main payment settlement currency\n     * @param _payment Payment amount in currency\n     */\n    function _performNativeSettlement(\n        address _payer,\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _payment,\n        uint256 _timestamp\n    ) internal {\n        if (_ccy == \"ETH\") {\n            require(msg.value == _payment, \"INCORRECT_ETH_VALUE\");\n            _safeTransferETH(_counterparty, msg.value);\n        } else {\n            require(msg.value == 0, \"INCORRECT_ETH_VALUE\");\n            address token = currencyController().getTokenAddresses(_ccy);\n            require(token != address(0), \"INVALID_TOKEN_ADDRESS\");\n            _safeTransferFrom(token, _payer, _counterparty, _payment);\n        }\n\n        bytes32 _settlementId = keccak256(\n            abi.encodePacked(_payer, _counterparty, _ccy, _payment, _timestamp)\n        );\n\n        paymentAggregator().verifyPayment(\n            _payer,\n            _counterparty,\n            _ccy,\n            _timestamp,\n            _payment,\n            _settlementId\n        );\n    }\n\n    /**\n     * @dev Internal function to cross-chain settlement request against\n     * a transaction object from an external adapter\n     */\n    function _validateSettlementRequest(\n        uint16 _chainId,\n        ProtocolTypes.SettlementRequest memory _request,\n        FulfillData memory _txData\n    ) internal view {\n        require(_request.txHash.isEqual(_txData.txHash), \"INCORRECT_TX_HASH\");\n\n        string memory payerAddress = crosschainAddressResolver().getUserAddress(\n            _request.payer,\n            _chainId\n        );\n\n        string memory receiverAddress = crosschainAddressResolver().getUserAddress(\n            _request.receiver,\n            _chainId\n        );\n\n        require(payerAddress.isEqual(_txData.from), \"INCORRECT_ADDRESS_FROM\");\n        require(receiverAddress.isEqual(_txData.to), \"INCORRECT_ADDRESS_TO\");\n    }\n\n    /**\n     * @dev Get the version of the underlying contract\n     * @return implementation version\n     */\n    function getVersion() public pure override returns (uint16) {\n        return VERSION;\n    }\n}\n"
    },
    "contracts/libraries/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary Strings {\n    /**\n     * @dev Helper function to check wether strings are equal\n     * @param text0 First string to compare\n     * @param text1 Second string to compare\n     * @return Boolean statement\n     */\n    function isEqual(string memory text0, string memory text1) internal pure returns (bool) {\n        return keccak256(abi.encodePacked(text0)) == keccak256(abi.encodePacked(text1));\n    }\n\n    function toHex(bytes32 data) public pure returns (string memory) {\n        return\n            string(abi.encodePacked(\"0x\", toHex16(bytes16(data)), toHex16(bytes16(data << 128))));\n    }\n\n    function toHex16(bytes16 data) internal pure returns (bytes32 result) {\n        result =\n            (bytes32(data) & 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000) |\n            ((bytes32(data) & 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000) >>\n                64);\n        result =\n            (result & 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000) |\n            ((result & 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000) >> 32);\n        result =\n            (result & 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000) |\n            ((result & 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000) >> 16);\n        result =\n            (result & 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000) |\n            ((result & 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000) >> 8);\n        result =\n            ((result & 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000) >> 4) |\n            ((result & 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00) >> 8);\n        result = bytes32(\n            0x3030303030303030303030303030303030303030303030303030303030303030 +\n                uint256(result) +\n                (((uint256(result) +\n                    0x0606060606060606060606060606060606060606060606060606060606060606) >> 4) &\n                    0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F) *\n                7\n        );\n    }\n}\n"
    },
    "contracts/libraries/SafeTransfer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../interfaces/IWETH9.sol\";\n\nabstract contract SafeTransfer {\n    address public WETH9;\n\n    function _registerToken(address _WETH9) internal {\n        require(WETH9 == address(0), \"WETH9 registered already\");\n        WETH9 = _WETH9;\n    }\n\n    receive() external payable {\n        require(msg.sender == WETH9, \"Not WETH9\");\n    }\n\n    function _depositAssets(\n        address _token,\n        address _payer,\n        address _receiver,\n        uint256 _amount\n    ) internal {\n        if (address(_token) == WETH9 && address(this).balance >= _amount) {\n            _wrapWETH(_receiver, _amount);\n        } else if (_receiver == address(this)) {\n            _safeTransferFrom(_token, _payer, _amount);\n        } else {\n            _safeTransferFrom(_token, _payer, _receiver, _amount);\n        }\n    }\n\n    function _withdrawAssets(\n        address _token,\n        address _receiver,\n        uint256 _amount\n    ) internal {\n        if (address(_token) == WETH9) {\n            _unwrapWETH(_receiver, _amount);\n        } else {\n            _safeTransfer(_token, _receiver, _amount);\n        }\n    }\n\n    function _wrapWETH(address _receiver, uint256 _amount) internal {\n        _amount = msg.value;\n\n        IWETH9(WETH9).deposit{value: _amount}();\n        IWETH9(WETH9).transfer(_receiver, _amount);\n    }\n\n    function _unwrapWETH(address _receiver, uint256 _amount) internal {\n        uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));\n        require(balanceWETH9 >= _amount, \"Insufficient WETH9\");\n\n        if (balanceWETH9 > 0) {\n            IWETH9(WETH9).withdraw(_amount);\n            _safeTransferETH(_receiver, _amount);\n        }\n    }\n\n    /// @dev Transfer helper from UniswapV2 Router\n    function _safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    /**\n     * There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2\n     * Im trying to make it a habit to put external calls last (reentrancy)\n     * You can put this in an internal function if you like.\n     */\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // 0xa9059cbb = bytes4(keccak256(\"transfer(address,uint256)\"))\n            abi.encodeWithSelector(0xa9059cbb, to, amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        ); // ERC20 Transfer failed\n    }\n\n    function _safeTransferFrom(\n        address token,\n        address from,\n        uint256 amount\n    ) internal virtual {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // 0x23b872dd = bytes4(keccak256(\"transferFrom(address,address,uint256)\"))\n            abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        ); // ERC20 TransferFrom failed\n    }\n\n    function _safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/interfaces/IExternalAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IExternalAdapter {\n    function createRequest(string memory _txHash) external returns (bytes32 requestId);\n\n    function cancelRequest(\n        string memory _txHash,\n        bytes32 _requestId,\n        bytes4 _callbackFunctionId,\n        uint256 _expiration\n    ) external;\n\n    function fulfill(\n        bytes32 _requestId,\n        string calldata _from,\n        string calldata _to,\n        uint256 _value,\n        uint256 _timestamp\n    ) external;\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH9 is IERC20 {\n    event Deposit(address user, uint256 amount);\n    event Withdrawal(address user, uint256 amount);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/ProductAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/IProductAddressResolver.sol\";\nimport \"./libraries/DealId.sol\";\nimport \"./utils/Ownable.sol\";\nimport \"./utils/Proxyable.sol\";\nimport {ProductAddressResolverStorage as Storage} from \"./storages/ProductAddressResolverStorage.sol\";\n\n/**\n * @title ProductAddressResolver contract is used to store addresses for each product\n * type supported on the protocol. Addresses stored per bytes4 prefixes which\n * are a simple identifiers of the product type\n */\ncontract ProductAddressResolver is IProductAddressResolver, Ownable, Proxyable {\n    using Address for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @dev Modifier to check if passed prefix is valid\n     */\n    modifier validPrefix(bytes4 _prefix) {\n        require(Storage.slot().productContracts[_prefix] != address(0), \"INVALID_ADDRESS\");\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(address owner) public initializer onlyProxy {\n        _transferOwnership(owner);\n    }\n\n    /**\n     * @dev Triggers to register new product type in a address resolver\n     * @param _prefix Bytes4 prefix for product type\n     * @param _product Product contract address\n     * @param _controller Controller contract address\n     *\n     * @notice Triggers only be contract owner\n     * @notice Reverts on saving contract which is not supporting a common interface\n     */\n    function registerProduct(\n        bytes4 _prefix,\n        address _product,\n        address _controller\n    ) public override onlyOwner {\n        require(_product.isContract(), \"Can't add non-contract address\");\n        require(_controller.isContract(), \"Can't add non-contract address\");\n\n        address prevProduct = Storage.slot().productContracts[_prefix];\n        Storage.slot().productContracts[_prefix] = _product;\n        Storage.slot().controllerContracts[_prefix] = _controller;\n\n        Storage.slot().productPrefix[prevProduct] = \"\";\n        Storage.slot().productPrefix[_product] = _prefix;\n\n        Storage.slot().productAddresses.add(_product);\n\n        emit RegisterProduct(_prefix, _product, _controller);\n    }\n\n    /**\n     * @dev Triggers to register several product types in a address resolver\n     * @param _prefixes Array of Bytes4 prefixes for each product type\n     * @param _contracts Array of smart contract addresses for each product\n     *\n     * @notice Triggers only be contract owner\n     * @notice Reverts on saving contract which is not supporting common interface\n     */\n    function registerProducts(\n        bytes4[] calldata _prefixes,\n        address[] calldata _contracts,\n        address[] calldata _controllers\n    ) public override onlyOwner {\n        require(_prefixes.length == _contracts.length, \"Invalid input lengths\");\n\n        for (uint256 i = 0; i < _prefixes.length; i++) {\n            bytes4 prefix = _prefixes[i];\n            address product = _contracts[i];\n            address controller = _controllers[i];\n            registerProduct(prefix, product, controller);\n        }\n    }\n\n    /**\n     * @dev Triggers to get product address by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     * @notice To work with the contract this address should be wrapped around IProduct interface\n     */\n    function getProductContract(bytes4 _prefix) public view override returns (address) {\n        return Storage.slot().productContracts[_prefix];\n    }\n\n    /**\n     * @dev Trigers to get product addresses\n     * @notice To work with the contract this address should be wrapped around IProduct interface\n     */\n    function getProductContracts() public view override returns (address[] memory) {\n        return Storage.slot().productAddresses.values();\n    }\n\n    /**\n     * @dev Triggers to get product address by deal id\n     * @param _dealId Product deal idenfitier\n     * @notice To work with the contract this address should be wrapped around IProduct interface\n     */\n    function getProductContractByDealId(bytes32 _dealId) public view override returns (address) {\n        bytes4 prefix = DealId.getPrefix(_dealId);\n        return Storage.slot().productContracts[prefix];\n    }\n\n    /**\n     * @dev Triggers to get market controller address by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\n     */\n    function getControllerContract(bytes4 _prefix) public view override returns (address) {\n        return Storage.slot().controllerContracts[_prefix];\n    }\n\n    /**\n     * @dev Triggers to get market controller address by deal id\n     * @param _dealId Product deal idenfitier\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\n     */\n    function getControllerContractByDealId(bytes32 _dealId) public view override returns (address) {\n        bytes4 prefix = DealId.getPrefix(_dealId);\n        return Storage.slot().controllerContracts[prefix];\n    }\n\n    /**\n     * @dev Triggers to verify if a specific product is supported by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     */\n    function isSupportedProduct(bytes4 _prefix) public view override returns (bool) {\n        return Storage.slot().productContracts[_prefix] != address(0);\n    }\n\n    /**\n     * @dev Triggers to verify if a specific product is supported by deal id.\n     * @param _dealId Product deal idenfitier\n     */\n    function isSupportedProductByDealId(bytes32 _dealId) public view override returns (bool) {\n        bytes4 prefix = DealId.getPrefix(_dealId);\n        return Storage.slot().productContracts[prefix] != address(0);\n    }\n\n    /**\n     * @dev Triggers to verify if a specific product contract is registered.\n     * @param _product Product contract address\n     */\n    function isRegisteredProductContract(address _product) public view override returns (bool) {\n        return Storage.slot().productPrefix[_product] != \"\";\n    }\n}\n"
    },
    "contracts/libraries/DealId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary DealId {\n    /**\n     * @dev Generates a deal id using a product prefix and deal number\n     * @param prefix Product type prefix in bytes4\n     * @param counter Number of deal to be generated\n     * @return id in bytes32 with prefix on the left and counter on the right side\n     */\n    function generate(bytes32 prefix, uint256 counter) public pure returns (bytes32 id) {\n        uint224 num = toUint224(counter);\n        bytes4 r;\n        bytes32 zero = 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000;\n        assembly {\n            r := and(prefix, zero)\n            id := add(r, num)\n        }\n    }\n\n    /**\n     * @dev Returns product based prefix from deal id\n     * @param id Deal unique identification string\n     * @return prefix in bytes4\n     */\n    function getPrefix(bytes32 id) public pure returns (bytes4 prefix) {\n        assembly {\n            prefix := shl(0, id)\n        }\n    }\n\n    /**\n     * @dev Returns converted number from uint256 to uint224\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"NUMBER_OVERFLOW\");\n        return uint224(value);\n    }\n}\n"
    },
    "contracts/storages/ProductAddressResolverStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary ProductAddressResolverStorage {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.productAddressResolver\");\n\n    struct Storage {\n        // Mapping from prefix to product contract address\n        mapping(bytes4 => address) productContracts;\n        // Mapping from prefix to controller contract address\n        mapping(bytes4 => address) controllerContracts;\n        // Mapping from product contract address to prefix for product type\n        mapping(address => bytes4) productPrefix;\n        // Registered product addresses\n        EnumerableSet.AddressSet productAddresses;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "contracts/test/ProductAddressResolverTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../ProductAddressResolver.sol\";\n\ncontract ProductAddressResolverTest is ProductAddressResolver {\n    function getGasCostOfGetProductContract(bytes4 _prefix) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        getProductContract(_prefix);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetControllerContract(bytes4 _prefix) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        getControllerContract(_prefix);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetProductContractWithTypeConversion(bytes32 _dealID)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        bytes4 _prefix;\n\n        assembly {\n            _prefix := shl(0, _dealID)\n        }\n\n        getProductContract(_prefix);\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetControllerContractWithTypeConversion(bytes32 _dealID)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        bytes4 _prefix;\n        assembly {\n            _prefix := shr(0, _dealID)\n        }\n\n        getControllerContract(_prefix);\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/storages/PaymentAggregatorStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../libraries/TimeSlot.sol\";\n\nlibrary PaymentAggregatorStorage {\n    using TimeSlot for TimeSlot.Slot;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.paymentAggregator\");\n\n    struct Storage {\n        // Mapping structure for storing TimeSlots\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) timeSlots;\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => EnumerableSet.Bytes32Set))) deals;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "contracts/libraries/TimeSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./BokkyPooBahsDateTimeLibrary.sol\";\nimport \"./AddressPacking.sol\";\n\nlibrary TimeSlot {\n    using BokkyPooBahsDateTimeLibrary for uint256;\n\n    /**\n     * @dev Slot keeps track of total payments to be settled per one day\n     * by two counterparties per currency, net payment and\n     * an indicator if parties obligations are flipped\n     */\n    struct Slot {\n        uint256 totalPayment0;\n        uint256 totalPayment1;\n        uint256 netPayment;\n        uint256 paidAmount;\n        bool flipped;\n        bool isSettled;\n        mapping(bytes32 => PaymentConfirmation) confirmations;\n    }\n\n    struct PaymentConfirmation {\n        address verificationParty;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Computes the time slot position in the mapping by preconfigured time\n     * @param year Year in which to find a timeslot\n     * @param month Month in which to find a timeslot\n     * @param day Day in which to find a timeslot\n     */\n    function position(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(year, month, day));\n    }\n\n    /**\n     * @dev Returns the time slot information from the mapping and preconfigured time\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param year Year in which to find a timeslot\n     * @param month Month in which to find a timeslot\n     * @param day Day in which to find a timeslot\n     */\n    function get(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 year,\n        uint256 month,\n        uint256 day\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        )\n    {\n        return\n            getBySlotId(self, party0, party1, ccy, keccak256(abi.encodePacked(year, month, day)));\n    }\n\n    /**\n     * @dev Returns timeSlot payment confirmation for a transaction with specified `txHash`\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param year Year in which to find a timeslot\n     * @param month Month in which to find a timeslot\n     * @param day Day in which to find a timeslot\n     * @param settlementId Unique settlement id to find payment confirmation for\n     */\n    function getPaymentConfirmation(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        bytes32 settlementId\n    ) internal view returns (address, uint256) {\n        return\n            getPaymentConfirmationById(\n                self,\n                party0,\n                party1,\n                ccy,\n                keccak256(abi.encodePacked(year, month, day)),\n                settlementId\n            );\n    }\n\n    /**\n     * @dev Returns timeSlot payment confirmation for a transaction with specified `txHash`\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slotId Time slot identifier\n     * @param settlementId Unique settlement id to find payment confirmation for\n     */\n    function getPaymentConfirmationById(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slotId,\n        bytes32 settlementId\n    ) internal view returns (address, uint256) {\n        (bytes32 addr, ) = AddressPacking.pack(party0, party1);\n        TimeSlot.Slot storage timeSlot = self[addr][ccy][slotId];\n\n        TimeSlot.PaymentConfirmation memory confirmation = timeSlot.confirmations[settlementId];\n\n        return (confirmation.verificationParty, confirmation.amount);\n    }\n\n    /**\n     * @dev Returns the time slot information from the mapping\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slotId Time slot identifier\n     */\n    function getBySlotId(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slotId\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        )\n    {\n        (bytes32 addr, bool flipped) = AddressPacking.pack(party0, party1);\n        TimeSlot.Slot storage timeSlot = self[addr][ccy][slotId];\n        uint256 totalPayment0 = timeSlot.totalPayment0;\n        uint256 totalPayment1 = timeSlot.totalPayment1;\n        uint256 netPayment = timeSlot.netPayment;\n\n        if (flipped) {\n            uint256 oldPayment0 = totalPayment0;\n            uint256 oldPayment1 = totalPayment1;\n            totalPayment0 = oldPayment1;\n            totalPayment1 = oldPayment0;\n        }\n\n        if (totalPayment1 > totalPayment0) {\n            netPayment = totalPayment1 - totalPayment0;\n            flipped = true;\n        } else {\n            netPayment = totalPayment0 - totalPayment1;\n            flipped = false;\n        }\n\n        return (\n            totalPayment0,\n            totalPayment1,\n            netPayment,\n            timeSlot.paidAmount,\n            flipped,\n            timeSlot.isSettled\n        );\n    }\n\n    /**\n     * @dev Adds payment into the time slot with provided information\n     * @param self The mapping with all time slots\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slot Time slot identifier to be updated\n     * @param payment0 Payment obligated to the first counterparty\n     * @param payment1 Payment obligated to the second counterparty\n     */\n    function addPayment(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot,\n        uint256 payment0,\n        uint256 payment1\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n        TimeSlot.Slot storage timeSlot = self[packedAddrs][ccy][slot];\n        require(!timeSlot.isSettled, \"TIMESLOT SETTLED ALREADY\");\n\n        timeSlot.totalPayment0 = flipped\n            ? timeSlot.totalPayment0 + payment1\n            : timeSlot.totalPayment0 + payment0;\n        timeSlot.totalPayment1 = flipped\n            ? timeSlot.totalPayment1 + payment0\n            : timeSlot.totalPayment1 + payment1;\n    }\n\n    /**\n     * @dev Removes payment from the time slot with provided information\n     * @param self The mapping with all time slots\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slot Time slot identifier to be updated\n     * @param payment0 Payment amount to remove for the first counterparty\n     * @param payment1 Payment amount to remove for the second counterparty\n     */\n    function removePayment(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot,\n        uint256 payment0,\n        uint256 payment1\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n        TimeSlot.Slot storage timeSlot = self[packedAddrs][ccy][slot];\n        if (timeSlot.isSettled) return;\n\n        timeSlot.totalPayment0 = flipped\n            ? timeSlot.totalPayment0 - payment1\n            : timeSlot.totalPayment0 - payment0;\n        timeSlot.totalPayment1 = flipped\n            ? timeSlot.totalPayment1 - payment0\n            : timeSlot.totalPayment1 - payment1;\n    }\n\n    /**\n     * @dev Verifies the net payment for time slot\n     * @param self The mapping with all time slots\n     * @param sender Payment sender address\n     * @param recipient Resipient's counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slot Time slot identifier to be verified\n     * @param payment Net payment amount\n     * @param settlementId Unique settlement id of the successfull payment\n     */\n    function verifyPayment(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) storage self,\n        address sender,\n        address recipient,\n        bytes32 ccy,\n        bytes32 slot,\n        uint256 payment,\n        bytes32 settlementId\n    ) internal {\n        (bytes32 addr, bool flipped) = AddressPacking.pack(sender, recipient);\n        TimeSlot.Slot storage timeSlot = self[addr][ccy][slot];\n        require(!timeSlot.isSettled, \"TIMESLOT SETTLED ALREADY\");\n        uint256 netPayment;\n\n        if (flipped) {\n            require(\n                timeSlot.totalPayment1 > timeSlot.totalPayment0,\n                \"Incorrect verification party\"\n            );\n            netPayment = timeSlot.totalPayment1 - timeSlot.totalPayment0;\n        } else {\n            require(\n                timeSlot.totalPayment0 > timeSlot.totalPayment1,\n                \"Incorrect verification party\"\n            );\n            netPayment = timeSlot.totalPayment0 - timeSlot.totalPayment1;\n        }\n\n        timeSlot.paidAmount = timeSlot.paidAmount + payment;\n        require(timeSlot.paidAmount <= netPayment, \"Payment overflow\");\n\n        TimeSlot.PaymentConfirmation memory confirmation;\n        confirmation.amount = payment;\n        confirmation.verificationParty = sender;\n        timeSlot.confirmations[settlementId] = confirmation;\n\n        if (netPayment - timeSlot.paidAmount == 0) {\n            timeSlot.isSettled = true;\n        }\n    }\n\n    /**\n     * @dev Clears the time slot, triggered only when the timeslot has empty payments for both parties and 0 net payment\n     * @param self The mapping with all time slots\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slot TimeSlot identifier to be cleared\n     */\n    function clear(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot\n    ) internal {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        delete self[packedAddrs][ccy][slot];\n    }\n\n    /**\n     * @dev Verifies if TimeSlot was settled\n     * @param self The mapping with all time slots\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slot TimeSlot identifier to be cleared\n     * @return Boolean of settlement status\n     */\n    function isSettled(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot\n    ) internal view returns (bool) {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        return self[packedAddrs][ccy][slot].isSettled;\n    }\n}\n"
    },
    "contracts/libraries/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    uint256 constant DOW_MON = 1;\n    uint256 constant DOW_TUE = 2;\n    uint256 constant DOW_WED = 3;\n    uint256 constant DOW_THU = 4;\n    uint256 constant DOW_FRI = 5;\n    uint256 constant DOW_SAT = 6;\n    uint256 constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days = _day -\n            32075 +\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\n            4 +\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n            12 -\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n            4 -\n            OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function timestampFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n\n    function timestampFromDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 timestamp) {\n        timestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            hour *\n            SECONDS_PER_HOUR +\n            minute *\n            SECONDS_PER_MINUTE +\n            second;\n    }\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint256 daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n\n    function isValidDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n\n    function isLeapYear(uint256 timestamp) internal pure returns (bool leapYear) {\n        (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n\n    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n\n    function getDaysInMonth(uint256 timestamp) internal pure returns (uint256 daysInMonth) {\n        (uint256 year, uint256 month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n\n    function _getDaysInMonth(uint256 year, uint256 month)\n        internal\n        pure\n        returns (uint256 daysInMonth)\n    {\n        if (\n            month == 1 ||\n            month == 3 ||\n            month == 5 ||\n            month == 7 ||\n            month == 8 ||\n            month == 10 ||\n            month == 12\n        ) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint256 timestamp) internal pure returns (uint256 dayOfWeek) {\n        uint256 _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = ((_days + 3) % 7) + 1;\n    }\n\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n\n    function getMinute(uint256 timestamp) internal pure returns (uint256 minute) {\n        uint256 secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n\n    function getSecond(uint256 timestamp) internal pure returns (uint256 second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint256 timestamp, uint256 _years)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMonths(uint256 timestamp, uint256 _months)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = ((month - 1) % 12) + 1;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addDays(uint256 timestamp, uint256 _days)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addHours(uint256 timestamp, uint256 _hours)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMinutes(uint256 timestamp, uint256 _minutes)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addSeconds(uint256 timestamp, uint256 _seconds)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint256 timestamp, uint256 _years)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp <= timestamp);\n    }\n\n    function subMonths(uint256 timestamp, uint256 _months)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = (yearMonth % 12) + 1;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp <= timestamp);\n    }\n\n    function subDays(uint256 timestamp, uint256 _days)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subHours(uint256 timestamp, uint256 _hours)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subMinutes(uint256 timestamp, uint256 _minutes)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subSeconds(uint256 timestamp, uint256 _seconds)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _years)\n    {\n        require(fromTimestamp <= toTimestamp);\n        (uint256 fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint256 toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _months)\n    {\n        require(fromTimestamp <= toTimestamp);\n        (uint256 fromYear, uint256 fromMonth, ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint256 toYear, uint256 toMonth, ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _days)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _hours)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _minutes)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _seconds)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}\n"
    },
    "contracts/libraries/AddressPacking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary AddressPacking {\n    /**\n     * @dev Packs two addresses into one hash to reduce the number of arguments\n     * @param addr0 First address\n     * @param addr1 Second address\n     * @return Boolean to identify if addresses were flipped\n     */\n    function pack(address addr0, address addr1) internal pure returns (bytes32, bool) {\n        require(addr0 != addr1, \"Identical addresses\");\n        (address _addr0, address _addr1) = addr0 < addr1 ? (addr0, addr1) : (addr1, addr0);\n        require(_addr0 != address(0), \"Invalid address\");\n\n        if (_addr0 != addr0) {\n            return (keccak256(abi.encode(_addr0, _addr1)), true);\n        } else {\n            return (keccak256(abi.encode(_addr0, _addr1)), false);\n        }\n    }\n}\n"
    },
    "contracts/test/TimeSlotTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"../libraries/TimeSlot.sol\";\nimport \"../libraries/AddressPacking.sol\";\n\ncontract TimeSlotTest {\n    using TimeSlot for TimeSlot.Slot;\n\n    mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) _timeSlots;\n    bytes32 public ccy = \"0xSampleCCY\";\n\n    function position(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) external pure returns (bytes32) {\n        return TimeSlot.position(year, month, day);\n    }\n\n    function getGasCostOfPosition(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        TimeSlot.position(year, month, day);\n\n        return gasBefore - gasleft();\n    }\n\n    function get(\n        address party0,\n        address party1,\n        uint256 year,\n        uint256 month,\n        uint256 day\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        )\n    {\n        return TimeSlot.get(_timeSlots, party0, party1, ccy, year, month, day);\n    }\n\n    function getPaymentConfirmation(\n        address party0,\n        address party1,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        bytes32 settlementId\n    ) external view returns (address, uint256) {\n        return\n            TimeSlot.getPaymentConfirmation(\n                _timeSlots,\n                party0,\n                party1,\n                ccy,\n                year,\n                month,\n                day,\n                settlementId\n            );\n    }\n\n    function addPayment(\n        address party0,\n        address party1,\n        bytes32 slot,\n        uint256 payment0,\n        uint256 payment1\n    ) external {\n        (bytes32 addrPack, bool flipped) = AddressPacking.pack(party0, party1);\n        TimeSlot.Slot storage timeSlot = _timeSlots[addrPack][ccy][slot];\n\n        uint256 totalPaymentBefore0 = timeSlot.totalPayment0;\n        uint256 totalPaymentBefore1 = timeSlot.totalPayment1;\n\n        TimeSlot.addPayment(_timeSlots, party0, party1, ccy, slot, payment0, payment1);\n\n        timeSlot = _timeSlots[addrPack][ccy][slot];\n\n        if (flipped) {\n            require(\n                timeSlot.totalPayment0 == totalPaymentBefore0 + payment1,\n                \"PAYMENT1 CHANGED INCORRECTLY\"\n            );\n            require(\n                timeSlot.totalPayment1 == totalPaymentBefore1 + payment0,\n                \"PAYMENT0 CHANGED INCORRECTLY\"\n            );\n        } else {\n            require(\n                timeSlot.totalPayment0 == totalPaymentBefore0 + payment0,\n                \"PAYMENT0 CHANGED INCORRECTLY\"\n            );\n            require(\n                timeSlot.totalPayment1 == totalPaymentBefore1 + payment1,\n                \"PAYMENT1 CHANGED INCORRECTLY\"\n            );\n        }\n    }\n\n    function removePayment(\n        address party0,\n        address party1,\n        bytes32 slot,\n        uint256 payment0,\n        uint256 payment1\n    ) external {\n        (bytes32 addrPack, bool flipped) = AddressPacking.pack(party0, party1);\n        TimeSlot.Slot storage timeSlot = _timeSlots[addrPack][ccy][slot];\n        require(!timeSlot.isSettled, \"TIMESLOT SETTLED ALREADY\");\n\n        uint256 totalPaymentBefore0 = timeSlot.totalPayment0;\n        uint256 totalPaymentBefore1 = timeSlot.totalPayment1;\n\n        TimeSlot.removePayment(_timeSlots, party0, party1, ccy, slot, payment0, payment1);\n\n        timeSlot = _timeSlots[addrPack][ccy][slot];\n\n        if (flipped) {\n            require(\n                timeSlot.totalPayment0 == totalPaymentBefore0 - payment1,\n                \"PAYMENT1 REMOVED INCORRECTLY\"\n            );\n            require(\n                timeSlot.totalPayment1 == totalPaymentBefore1 - payment0,\n                \"PAYMENT0 REMOVED INCORRECTLY\"\n            );\n        } else {\n            require(\n                timeSlot.totalPayment0 == totalPaymentBefore0 - payment0,\n                \"PAYMENT0 REMOVED INCORRECTLY\"\n            );\n            require(\n                timeSlot.totalPayment1 == totalPaymentBefore1 - payment1,\n                \"PAYMENT1 REMOVED INCORRECTLY\"\n            );\n        }\n    }\n\n    function verifyPayment(\n        address counterparty,\n        bytes32 slot,\n        uint256 payment,\n        bytes32 settlementId\n    ) external {\n        (bytes32 addrPack, ) = AddressPacking.pack(msg.sender, counterparty);\n        TimeSlot.Slot storage timeSlot = _timeSlots[addrPack][ccy][slot];\n        TimeSlot.verifyPayment(\n            _timeSlots,\n            msg.sender,\n            counterparty,\n            ccy,\n            slot,\n            payment,\n            settlementId\n        );\n\n        timeSlot = _timeSlots[addrPack][ccy][slot];\n\n        require(\n            timeSlot.confirmations[settlementId].verificationParty == msg.sender,\n            \"INCORRECT VERIFIER\"\n        );\n        require(timeSlot.confirmations[settlementId].amount == payment, \"INCORRECT PAYMENT AMOUNT\");\n    }\n\n    function clear(\n        address party0,\n        address party1,\n        bytes32 slot\n    ) public {\n        (bytes32 addrPack, ) = AddressPacking.pack(party0, party1);\n        TimeSlot.clear(_timeSlots, party0, party1, ccy, slot);\n\n        require(_timeSlots[addrPack][ccy][slot].totalPayment0 == 0, \"PAYMENT NOT CLEARED\");\n        require(_timeSlots[addrPack][ccy][slot].totalPayment1 == 0, \"PAYMENT NOT CLEARED\");\n    }\n\n    function isSettled(\n        address party0,\n        address party1,\n        bytes32 slot\n    ) external view returns (bool) {\n        return TimeSlot.isSettled(_timeSlots, party0, party1, ccy, slot);\n    }\n\n    function getGasCostOfIsSettled(\n        address party0,\n        address party1,\n        bytes32 slot\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        TimeSlot.isSettled(_timeSlots, party0, party1, ccy, slot);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/test/CloseOutTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"../libraries/AddressPacking.sol\";\nimport \"../libraries/CloseOut.sol\";\n\ncontract CloseOutTest {\n    mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) _closeOuts;\n    bytes32 ccy = \"0xSampleCCY\";\n\n    function get(address party0, address party1)\n        external\n        view\n        returns (CloseOut.Payment memory payment)\n    {\n        payment = CloseOut.get(_closeOuts, party0, party1, ccy);\n    }\n\n    function addPayments(\n        address party0,\n        address party1,\n        uint256 payment0,\n        uint256 payment1\n    ) external {\n        CloseOut.addPayments(_closeOuts, party0, party1, ccy, payment0, payment1);\n    }\n\n    function removePayments(\n        address party0,\n        address party1,\n        uint256 payment0,\n        uint256 payment1\n    ) external {\n        CloseOut.removePayments(_closeOuts, party0, party1, ccy, payment0, payment1);\n    }\n\n    function close(address party0, address party1) external {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        CloseOut.close(_closeOuts, party0, party1, ccy);\n        require(_closeOuts[packedAddrs][ccy].closed == true, \"PAYMENTS NOT SETTLED\");\n    }\n\n    function clear(address party0, address party1) external {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        CloseOut.clear(_closeOuts, party0, party1, ccy);\n        require(_closeOuts[packedAddrs][ccy].netPayment == 0, \"PAYMENTS NOT CLEARED\");\n    }\n}\n"
    },
    "contracts/libraries/CloseOut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./AddressPacking.sol\";\n\nlibrary CloseOut {\n    /**\n     * @dev Payment keeps track of net payment for close out netting\n     * and an indicator if party's obligations are flipped\n     */\n    struct Payment {\n        uint256 netPayment;\n        bool flipped;\n        bool closed;\n    }\n\n    /**\n     * @dev Returns the close out payment between 2 counterparties\n     * @param self The mapping with all close out netting payments\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the close out\n     */\n    function get(\n        mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) internal view returns (CloseOut.Payment memory payment) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n        payment = self[packedAddrs][ccy];\n\n        flipped ? payment.flipped = !payment.flipped : payment.flipped = payment.flipped;\n    }\n\n    struct CloseOutLocalVars {\n        bytes32 packedAddrs;\n        bool flipped;\n        uint256 payment0;\n        uint256 payment1;\n    }\n\n    /**\n     * @dev Adds payments into the close out with provided information\n     * @param self The mapping with all close out netting payments\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the close out\n     * @param payment0 New payment obligated to the first counterparty\n     * @param payment1 New payment obligated to the second counterparty\n     * @return Boolean wether close out net amount was flipped during the update, if close out is flipped the net payment obligated to the second party and vice versa\n     */\n    function addPayments(\n        mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) internal returns (bool) {\n        CloseOutLocalVars memory vars;\n        (vars.packedAddrs, vars.flipped) = AddressPacking.pack(party0, party1);\n\n        if (vars.flipped) {\n            vars.payment0 = payment1;\n            vars.payment1 = payment0;\n        } else {\n            vars.payment0 = payment0;\n            vars.payment1 = payment1;\n        }\n\n        CloseOut.Payment storage closeOut = self[vars.packedAddrs][ccy];\n\n        if (closeOut.flipped) {\n            if (vars.payment0 > closeOut.netPayment && vars.payment1 < vars.payment0) {\n                closeOut.netPayment = vars.payment0 - closeOut.netPayment - vars.payment1;\n                closeOut.flipped = false;\n            } else {\n                closeOut.netPayment = closeOut.netPayment + vars.payment1 - vars.payment0;\n            }\n        } else {\n            if (vars.payment1 > closeOut.netPayment && vars.payment0 < vars.payment1) {\n                closeOut.netPayment = vars.payment1 - closeOut.netPayment - vars.payment0;\n                closeOut.flipped = true;\n            } else {\n                closeOut.netPayment = closeOut.netPayment + vars.payment0 - vars.payment1;\n            }\n        }\n\n        return closeOut.flipped;\n    }\n\n    /**\n     * @dev Removes payments from the close out with provided information\n     * @param self The mapping with all close out netting payments\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the close out\n     * @param payment0 Payment to remove for the first counterparty\n     * @param payment1 Payment to remove for the second counterparty\n     * @return Boolean wether close out net amount was flipped during the update, if close out is flipped the net payment obligated to the second party and vice versa\n     */\n    function removePayments(\n        mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) internal returns (bool) {\n        CloseOutLocalVars memory vars;\n        (vars.packedAddrs, vars.flipped) = AddressPacking.pack(party0, party1);\n\n        if (vars.flipped) {\n            vars.payment0 = payment1;\n            vars.payment1 = payment0;\n        } else {\n            vars.payment0 = payment0;\n            vars.payment1 = payment1;\n        }\n\n        CloseOut.Payment storage closeOut = self[vars.packedAddrs][ccy];\n        uint256 paymentDelta = vars.payment0 > vars.payment1\n            ? vars.payment0 - vars.payment1\n            : vars.payment1 - vars.payment0;\n        bool substraction;\n\n        if (closeOut.flipped) {\n            substraction = vars.payment0 >= vars.payment1 ? false : true;\n        } else {\n            substraction = vars.payment0 >= vars.payment1 ? true : false;\n        }\n\n        if (paymentDelta >= closeOut.netPayment && substraction) {\n            closeOut.netPayment = paymentDelta - closeOut.netPayment;\n            closeOut.flipped = !closeOut.flipped;\n        } else {\n            closeOut.netPayment = substraction\n                ? closeOut.netPayment - paymentDelta\n                : closeOut.netPayment + paymentDelta;\n        }\n\n        return closeOut.flipped;\n    }\n\n    /**\n     * @dev Closes the close out payment if both parties don't have any trading activities anymore\n     * @param self The mapping with all close out netting payments\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the close out\n     */\n    function close(\n        mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) internal {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        CloseOut.Payment storage closeOut = self[packedAddrs][ccy];\n\n        closeOut.closed = true;\n    }\n\n    /**\n     * @dev Clears the state of close out payment\n     * @param self The mapping with all close out netting payments\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the close out\n     */\n    function clear(\n        mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) internal {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        delete self[packedAddrs][ccy];\n    }\n}\n"
    },
    "contracts/storages/CloseOutNettingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../libraries/CloseOut.sol\";\n\nlibrary CloseOutNettingStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.closeOutNetting\");\n\n    struct Storage {\n        // Mapping structure for storing Close Out payments\n        mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) closeOuts;\n        // Mapping structure for storing default boolean per address\n        mapping(address => bool) isDefaulted;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/utils/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\";\n\ncontract UpgradeabilityProxy is ERC1967Proxy {\n    constructor(address _logic, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(msg.sender);\n    }\n\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeTo(newImplementation);\n    }\n\n    function changeAdmin(address newAdmin) external ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    function admin() external view returns (address) {\n        return _getAdmin();\n    }\n\n    function implementation() external view returns (address) {\n        return ERC1967Proxy._implementation();\n    }\n}\n"
    },
    "contracts/ProxyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IAddressResolver.sol\";\nimport \"./interfaces/IProxyController.sol\";\nimport \"./interfaces/IProductAddressResolver.sol\";\nimport \"./libraries/Contracts.sol\";\nimport \"./libraries/ProductPrefixes.sol\";\nimport \"./utils/UpgradeabilityProxy.sol\";\n\ncontract ProxyController is IProxyController, Ownable {\n    IAddressResolver private resolver;\n    bytes32 private constant ADDRESS_RESOLVER = \"AddressResolver\";\n\n    /**\n     * @dev Contract constructor function.\n     * @param _resolver The address of the Address Resolver contract\n     *\n     * @notice Set a proxy contract address of AddressResolver if it already exists.\n     * If not, set zero address here and call `setAddressResolverImpl` using the implementation\n     * address of AddressResolver to create a proxy contract.\n     */\n    constructor(address _resolver) Ownable() {\n        if (_resolver != address(0)) {\n            UpgradeabilityProxy proxy = UpgradeabilityProxy(payable(_resolver));\n            require(proxy.implementation() != address(0), \"Proxy address not found\");\n            resolver = IAddressResolver(_resolver);\n        }\n    }\n\n    /**\n     * @dev Gets the proxy address of AddressResolver\n     */\n    function getAddressResolverAddress() public view returns (address) {\n        return (address(resolver));\n    }\n\n    /**\n     * @dev Gets the proxy address to specified name\n     * @param name The cache name of the contract\n     */\n    function getAddress(bytes32 name) public view returns (address proxyAddress) {\n        proxyAddress = resolver.getAddress(name, \"Address not found\");\n        UpgradeabilityProxy proxy = UpgradeabilityProxy(payable(proxyAddress));\n\n        require(proxy.implementation() != address(0), \"Proxy address not found\");\n    }\n\n    /**\n     * @dev Gets the product proxy address to specified prefix\n     * @param prefix Bytes4 prefix for product type\n     */\n    function getProductAddress(bytes4 prefix) public view returns (address) {\n        IProductAddressResolver productAddressResolver = IProductAddressResolver(\n            getAddress(Contracts.PRODUCT_ADDRESS_RESOLVER)\n        );\n        address proxyAddress = productAddressResolver.getProductContract(prefix);\n        UpgradeabilityProxy proxy = UpgradeabilityProxy(payable(proxyAddress));\n\n        require(proxy.implementation() != address(0), \"Proxy address not found\");\n\n        return proxyAddress;\n    }\n\n    /**\n     * @dev Sets the implementation contract of AddressResolver\n     * @param newImpl The address of implementation contract\n     */\n    function setAddressResolverImpl(address newImpl) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\"initialize(address)\", msg.sender);\n        address proxyAddress = _updateImpl(ADDRESS_RESOLVER, newImpl, data);\n        resolver = IAddressResolver(proxyAddress);\n    }\n\n    /**\n     * @dev Sets the implementation contract of CloseOutNetting\n     * @param newImpl The address of implementation contract\n     */\n    function setCloseOutNettingImpl(address newImpl) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\"initialize(address)\", resolver);\n        _updateImpl(Contracts.CLOSE_OUT_NETTING, newImpl, data);\n    }\n\n    /**\n     * @dev  Sets the implementation contract of CollateralAggregator\n     * @param newImpl The address of implementation contract\n     */\n    function setCollateralAggregatorImpl(address newImpl) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\n            \"initialize(address,address,uint256,uint256,uint256,uint256)\",\n            msg.sender,\n            resolver,\n            15000,\n            12500,\n            12000,\n            2500\n        );\n        _updateImpl(Contracts.COLLATERAL_AGGREGATOR, newImpl, data);\n    }\n\n    /**\n     * @dev  Sets the implementation contract of CollateralVault\n     * @param newImpl The address of implementation contract\n     * @param _WETH9 The address of WETH\n     */\n    function setCollateralVaultImpl(address newImpl, address _WETH9) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\n            \"initialize(address,address,address)\",\n            msg.sender,\n            resolver,\n            _WETH9\n        );\n        _updateImpl(Contracts.COLLATERAL_VAULT, newImpl, data);\n    }\n\n    /**\n     * @dev Sets the implementation contract of CrosschainAddressResolver\n     * @param newImpl The address of implementation contract\n     */\n    function setCrosschainAddressResolverImpl(address newImpl) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\"initialize(address)\", resolver);\n        _updateImpl(Contracts.CROSSCHAIN_ADDRESS_RESOLVER, newImpl, data);\n    }\n\n    /**\n     * @dev Sets the implementation contract of CurrencyController\n     * @param newImpl The address of implementation contract\n     */\n    function setCurrencyControllerImpl(address newImpl) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\"initialize(address)\", msg.sender);\n        _updateImpl(Contracts.CURRENCY_CONTROLLER, newImpl, data);\n    }\n\n    /**\n     * @dev Sets the implementation contract of LendingMarketController\n     * @param newImpl The address of implementation contract\n     */\n    function setLendingMarketControllerImpl(address newImpl) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\n            \"initialize(address,address)\",\n            msg.sender,\n            resolver\n        );\n        _updateImpl(Contracts.LENDING_MARKET_CONTROLLER, newImpl, data);\n    }\n\n    /**\n     * @dev Sets the implementation contract of Liquidations\n     * @param newImpl The address of implementation contract\n     */\n    function setLiquidationsImpl(address newImpl, uint256 offset) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\n            \"initialize(address,address,uint256)\",\n            msg.sender,\n            resolver,\n            offset\n        );\n        _updateImpl(Contracts.LIQUIDATIONS, newImpl, data);\n    }\n\n    /**\n     * @dev Sets the implementation contract of MarkToMarket\n     * @param newImpl The address of implementation contract\n     */\n    function setMarkToMarketImpl(address newImpl) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\"initialize(address)\", resolver);\n        _updateImpl(Contracts.MARK_TO_MARKET, newImpl, data);\n    }\n\n    /**\n     * @dev Sets the implementation contract of PaymentAggregator\n     * @param newImpl The address of implementation contract\n     */\n    function setPaymentAggregatorImpl(address newImpl) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\"initialize(address)\", resolver);\n        _updateImpl(Contracts.PAYMENT_AGGREGATOR, newImpl, data);\n    }\n\n    /**\n     * @dev Sets the implementation contract of ProductAddressResolver\n     * @param newImpl The address of implementation contract\n     */\n    function setProductAddressResolverImpl(address newImpl) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\"initialize(address)\", msg.sender);\n        _updateImpl(Contracts.PRODUCT_ADDRESS_RESOLVER, newImpl, data);\n    }\n\n    /**\n     * @dev Sets the implementation contract of SettlementEngine\n     * @param newImpl The address of implementation contract\n     */\n    function setSettlementEngineImpl(address newImpl, address _WETH9) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\n            \"initialize(address,address,address)\",\n            msg.sender,\n            resolver,\n            _WETH9\n        );\n        _updateImpl(Contracts.SETTLEMENT_ENGINE, newImpl, data);\n    }\n\n    /**\n     * @dev Sets the implementation contract of TermStructure\n     * @param newImpl The address of implementation contract\n     */\n    function setTermStructureImpl(address newImpl) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\n            \"initialize(address,address)\",\n            msg.sender,\n            resolver\n        );\n        _updateImpl(Contracts.TERM_STRUCTURE, newImpl, data);\n    }\n\n    /**\n     * @dev Sets the implementation contract of Loan product\n     * @param newImpl The address of implementation contract\n     */\n    function setLoanImpl(address newImpl) external onlyOwner {\n        bytes memory data = abi.encodeWithSignature(\n            \"initialize(address,address)\",\n            msg.sender,\n            resolver\n        );\n        _updateImpl(ProductPrefixes.LOAN, newImpl, data);\n    }\n\n    /**\n     * @dev Updates admin addresses of proxy contract\n     * @param newAdmin The address of new admin\n     * @param destinations The destination contract addresses\n     */\n    function changeProxyAdmins(address newAdmin, address[] calldata destinations)\n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i < destinations.length; i++) {\n            UpgradeabilityProxy proxy = UpgradeabilityProxy(payable(destinations[i]));\n            proxy.changeAdmin(newAdmin);\n        }\n    }\n\n    /**\n     * @dev Sets the implementation contract of specified contract\n     * The first time the contract address is set, `UpgradeabilityProxy` is created.\n     * From the second time, the contract address set in the created `UpgradeabilityProxy`\n     * will be updated.\n     *\n     * @param name The cache name of the contract\n     * @param newAddress The address of implementation contract\n     * @param data the data in a delegate call to a specified function\n     */\n    function _updateImpl(\n        bytes32 name,\n        address newAddress,\n        bytes memory data\n    ) internal returns (address proxyAddress) {\n        proxyAddress = _getAddress(name);\n        UpgradeabilityProxy proxy;\n\n        if (proxyAddress == address(0)) {\n            proxy = new UpgradeabilityProxy(payable(newAddress), data);\n            proxyAddress = address(proxy);\n\n            emit ProxyCreated(name, proxyAddress, newAddress);\n        } else {\n            proxy = UpgradeabilityProxy(payable(proxyAddress));\n            address oldAddress = proxy.implementation();\n            proxy.upgradeTo(newAddress);\n            emit ProxyUpdated(name, proxyAddress, newAddress, oldAddress);\n        }\n    }\n\n    function _getAddress(bytes32 name) internal view returns (address) {\n        if (name == ADDRESS_RESOLVER) {\n            return address(resolver);\n        } else {\n            return resolver.getAddress(name);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/interfaces/IProxyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IProxyController {\n    event ProxyCreated(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address indexed implementationAddress\n    );\n\n    event ProxyUpdated(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address indexed newImplementationAddress,\n        address oldImplementationAddress\n    );\n}\n"
    },
    "contracts/libraries/ProductPrefixes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary ProductPrefixes {\n    bytes4 internal constant LOAN = 0x21aaa47b;\n}\n"
    },
    "contracts/test/DealIdTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"../libraries/DealId.sol\";\nimport \"../libraries/ProductPrefixes.sol\";\n\ncontract DealIdTest {\n    function generate(uint256 number) external pure returns (bytes32 id) {\n        id = DealId.generate(ProductPrefixes.LOAN, number);\n    }\n\n    function getGasCostOfGenerate(uint256 number) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        DealId.generate(ProductPrefixes.LOAN, number);\n\n        return gasBefore - gasleft();\n    }\n\n    function getPrefix(bytes32 id) external pure returns (bytes4 prefix) {\n        prefix = DealId.getPrefix(id);\n    }\n\n    function getGasCostOfGetPrefix(bytes32 id) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        DealId.getPrefix(id);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/LoanV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./interfaces/IProductWithOneLeg.sol\";\nimport \"./libraries/DealId.sol\";\nimport \"./libraries/DiscountFactor.sol\";\nimport \"./libraries/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"./libraries/ProductPrefixes.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\nimport \"./types/ProtocolTypes.sol\";\nimport \"./utils/Ownable.sol\";\nimport \"./utils/Proxyable.sol\";\nimport {LoanV2Storage as Storage} from \"./storages/LoanV2Storage.sol\";\n\n/**\n * @title LoanV2 contract is used to store Lending deals in Secured Finance\n * protocol. This contract handle the PV updates on lending market rate changes\n * also allowing parties to mutually terminate their lending deals\n *\n * Contract linked to Lending Market contracts, LendingMarketController and Collateral contract.\n */\ncontract LoanV2 is IProductWithOneLeg, MixinAddressResolver, Ownable, Proxyable {\n    uint256 constant NOTICE = 2 weeks;\n    uint256 constant SETTLE = 2 days;\n    uint256 constant MAXPAYNUM = 6;\n    uint16 private constant VERSION = 1;\n\n    /**\n     * @dev Modifier to check if LendingMarket contract linked with this contract\n     * @param _ccy LendingMarket currency\n     * @param _term LendingMarket term\n     */\n    modifier lendingMarketExists(bytes32 _ccy, uint256 _term) {\n        require(Storage.slot().lendingMarkets[_ccy][_term] == msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the loan deal is active.\n     * @param loanId Loan deal ID\n     */\n    modifier workingLoan(bytes32 loanId) {\n        require(Storage.slot().isSettled[loanId], \"loan is not working\");\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(address owner, address resolver) public initializer onlyProxy {\n        Storage.slot().paymentFrequency = uint8(ProtocolTypes.PaymentFrequency.ANNUAL);\n        _transferOwnership(owner);\n        registerAddressResolver(resolver);\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](4);\n        contracts[0] = Contracts.COLLATERAL_AGGREGATOR;\n        contracts[1] = Contracts.LENDING_MARKET_CONTROLLER;\n        contracts[2] = Contracts.PAYMENT_AGGREGATOR;\n        contracts[3] = Contracts.TERM_STRUCTURE;\n    }\n\n    /**\n     * @dev Get if loan ownership can be transferred.\n     */\n    function isTransferable() public view returns (bool) {\n        return Storage.slot().isTransferable;\n    }\n\n    /**\n     * @dev Get the last loan ID.\n     */\n    function lastLoanId() public view returns (uint256) {\n        return Storage.slot().lastLoanId;\n    }\n\n    /**\n     * @dev Get the lending market address for specific currency and term.\n     */\n    function lendingMarkets(bytes32 _ccy, uint256 _term) public view returns (address) {\n        return Storage.slot().lendingMarkets[_ccy][_term];\n    }\n\n    /**\n     * @dev Triggers to change ability to transfer loan ownership by lenders.\n     * @param isAccepted Boolean to\n     *\n     * @notice Executed only by contract owner\n     */\n    function setIsTransferable(bool isAccepted) public onlyOwner {\n        Storage.slot().isTransferable = isAccepted;\n    }\n\n    /**\n     * @dev Triggers to link with existing LendingMarket.\n     * @param _ccy LendingMarket main currency\n     * @param _term LendingMarket term\n     * @param addr LendingMarket contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function addLendingMarket(\n        bytes32 _ccy,\n        uint256 _term,\n        address addr\n    ) public onlyOwner {\n        require(\n            Storage.slot().lendingMarkets[_ccy][_term] == address(0),\n            \"Couldn't rewrite existing market\"\n        );\n        Storage.slot().lendingMarkets[_ccy][_term] = addr;\n    }\n\n    /**\n     * @dev Internal function to generate deal id based on product prefix and deals counter\n     */\n    function _generateDealId() internal returns (bytes32 id) {\n        Storage.slot().lastLoanId += 1;\n        id = DealId.generate(ProductPrefixes.LOAN, Storage.slot().lastLoanId);\n    }\n\n    /**\n     * @dev Triggered to register new loan deal, also locks borrowers collateral.\n     * @param maker LendingMarket order market maker\n     * @param taker LendingMarket order market taker\n     * @param side MarketOrder side\n     * @param ccy Loan deal main currency\n     * @param term Loan deal term\n     * @param notional Notional amount of funds to lend/borrow\n     * @param rate Loan deal annual interest rate\n     *\n     * @notice Callable only by LendingMarket after matching orders\n     */\n    function register(\n        address maker,\n        address taker,\n        uint8 side,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate\n    ) public override lendingMarketExists(ccy, term) returns (bytes32 loanId) {\n        require(maker != taker, \"Same person deal is not allowed\");\n        address lender;\n        address borrower;\n\n        if (ProtocolTypes.Side(side) == ProtocolTypes.Side.LEND) {\n            lender = maker;\n            borrower = taker;\n        } else if (ProtocolTypes.Side(side) == ProtocolTypes.Side.BORROW) {\n            lender = taker;\n            borrower = maker;\n        }\n\n        collateralAggregator().releaseUnsettledCollateral(\n            lender,\n            ccy,\n            (notional * ProtocolTypes.MKTMAKELEVEL) / ProtocolTypes.PCT\n        );\n        collateralAggregator().useCollateral(\n            lender,\n            borrower,\n            ccy,\n            (notional * ProtocolTypes.MKTMAKELEVEL) / ProtocolTypes.PCT,\n            notional,\n            false\n        );\n\n        Storage.LoanDeal memory deal;\n        deal.lender = lender;\n        deal.borrower = borrower;\n        deal.ccy = ccy;\n        deal.term = term;\n        deal.notional = notional;\n        deal.rate = rate;\n        deal.start = block.timestamp;\n        deal.end = block.timestamp + deal.term * 86400;\n\n        loanId = _generateDealId();\n        Storage.slot().loans[loanId] = deal;\n\n        _registerPaymentSchedule(loanId, deal);\n        // liquidations.addDealToLiquidationQueue(lender, borrower, loanId);\n\n        emit Register(lender, borrower, ccy, term, notional, rate, loanId);\n    }\n\n    /**\n     * @dev Triggers to get settlement status of loan deal.\n     * @param loanId Loan deal ID\n     */\n    function getDealSettlementStatus(bytes32 loanId) public view override returns (bool) {\n        return Storage.slot().isSettled[loanId];\n    }\n\n    /**\n     * @dev Triggers to get main currency the deal by `dealId`.\n     * @param loanId Loan deal ID\n     */\n    function getDealCurrency(bytes32 loanId) public view override returns (bytes32) {\n        return Storage.slot().loans[loanId].ccy;\n    }\n\n    /**\n     * @dev Triggers to get current information about Loan deal.\n     * @param loanId Loan deal ID\n     */\n    function getLoanDeal(bytes32 loanId) public view returns (Storage.LoanDeal memory) {\n        return Storage.slot().loans[loanId];\n    }\n\n    /**\n     * @dev Triggers to get termination state for loan with `loanId`.\n     * @param loanId Loan deal ID\n     */\n    function getTerminationState(bytes32 loanId) public view returns (Storage.Termination memory) {\n        return Storage.slot().terminations[loanId];\n    }\n\n    /**\n     * @dev Returns the payment schedule for a deal by `loanId`\n     * @param loanId Loan deal ID\n     */\n    function getPaymentSchedule(bytes32 loanId)\n        public\n        view\n        override\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            bool[] memory\n        )\n    {\n        Storage.LoanDeal memory deal = Storage.slot().loans[loanId];\n\n        return _constructSchedule(deal, true);\n    }\n\n    /**\n     * @dev Returns the timestamp of the last settled payment in payment schedule\n     * @param loanId Loan deal ID\n     */\n    function getLastSettledPayment(bytes32 loanId) external view returns (uint256 settlementTime) {\n        Storage.LoanDeal memory deal = Storage.slot().loans[loanId];\n\n        uint256 payNums = termStructure().getNumPayments(\n            deal.term,\n            Storage.slot().paymentFrequency\n        );\n        uint256[] memory daysArr = termStructure().getTermSchedule(\n            deal.term,\n            Storage.slot().paymentFrequency\n        );\n\n        for (uint256 i = payNums; i > 0; i--) {\n            uint256 time = _timeShift(deal.start, daysArr[i - 1]);\n            bool status = paymentAggregator().isSettled(deal.lender, deal.borrower, deal.ccy, time);\n\n            if (status) {\n                settlementTime = time;\n            }\n        }\n    }\n\n    /**\n     * @dev Triggers to get stored present value of loan deal.\n     * @param loanId Loan ID to update PV for\n     */\n    function getDealLastPV(\n        address party0,\n        address party1,\n        bytes32 loanId\n    ) public view override returns (uint256, uint256) {\n        Storage.LoanDeal memory deal = Storage.slot().loans[loanId];\n\n        if (deal.pv == 0) {\n            deal.pv = getDealPV(loanId);\n        }\n\n        if (party0 == deal.lender && party1 == deal.borrower) {\n            return (0, deal.pv);\n        } else if (party0 == deal.borrower && party1 == deal.lender) {\n            return (deal.pv, 0);\n        }\n\n        return (0, 0);\n    }\n\n    // =========== EARLY TERMINATION SECTION ===========\n\n    /**\n     * @dev Triggers to request early termination of the loan.\n     * @param loanId Loan deal ID\n     *\n     * @notice Executed only for working loan deal\n     */\n    function requestTermination(bytes32 loanId) public override {\n        Storage.Termination storage termination = Storage.slot().terminations[loanId];\n        Storage.LoanDeal memory deal = Storage.slot().loans[loanId];\n        require(msg.sender == deal.lender || msg.sender == deal.borrower, \"parties must request\");\n        require(updateLoanPV(loanId), \"failed MtM\");\n\n        termination.terminationAsker = msg.sender;\n\n        emit RequestTermination(loanId, msg.sender);\n    }\n\n    /**\n     * @dev Triggers to accept early termination of the loan.\n     * @param loanId Loan deal ID\n     *\n     * @notice Executed only for working loan deal\n     */\n    function acceptTermination(bytes32 loanId) public override {\n        Storage.Termination storage termination = Storage.slot().terminations[loanId];\n        require(termination.terminationAsker != address(0), \"no termination request\");\n\n        Storage.LoanDeal memory deal = Storage.slot().loans[loanId];\n\n        if (termination.terminationAsker == deal.lender) {\n            require(msg.sender == deal.borrower, \"borrower must accept\");\n        } else {\n            require(msg.sender == deal.lender, \"lender must accept\");\n        }\n\n        require(updateLoanPV(loanId), \"failed MtM\");\n\n        if (Storage.slot().isSettled[loanId]) {\n            (uint256[] memory payments, , bool[] memory settlements) = _constructSchedule(\n                deal,\n                true\n            );\n\n            uint256 i;\n            for (i = 0; i < settlements.length; i++) {\n                if (settlements[i] == false) break;\n            }\n\n            uint256 deltaDays;\n\n            if (i == 0) {\n                deltaDays = BokkyPooBahsDateTimeLibrary.diffDays(deal.start, block.timestamp);\n            } else {\n                deltaDays = BokkyPooBahsDateTimeLibrary.diffDays(payments[i - 1], block.timestamp);\n            }\n\n            uint256 interestRatePerDay = (deal.rate * 1e18) / 36500;\n            uint256 accuredInterestRate = interestRatePerDay * deltaDays;\n            uint256 accuredInterest = (deal.notional * accuredInterestRate) / 1e20;\n            uint256 totalPayment = accuredInterest + deal.pv;\n            collateralAggregator().liquidate(\n                deal.borrower,\n                deal.lender,\n                deal.ccy,\n                totalPayment,\n                deal.pv,\n                true\n            );\n\n            emit EarlyTermination(loanId, msg.sender, totalPayment);\n        } else {\n            emit EarlyTermination(loanId, msg.sender, 0);\n        }\n\n        _liquidateLoan(loanId);\n    }\n\n    /**\n     * @dev Triggers to reject early termination of the loan.\n     * @param loanId Loan deal ID\n     *\n     * @notice Executed only for working loan deal\n     */\n    function rejectTermination(bytes32 loanId) public override {\n        Storage.Termination memory termination = Storage.slot().terminations[loanId];\n        require(termination.terminationAsker != address(0), \"no termination request\");\n\n        Storage.LoanDeal memory deal = Storage.slot().loans[loanId];\n        require(msg.sender == deal.lender || msg.sender == deal.borrower, \"parties must reject\");\n        require(updateLoanPV(loanId), \"failed MtM\");\n\n        delete Storage.slot().terminations[loanId];\n\n        emit RejectTermination(loanId, msg.sender);\n    }\n\n    /**\n     * @dev Triggers to transfer loan ownership.\n     * @param loanId Loan deal ID\n     * @param newOwner Address of new owner (lender)\n     *\n     * @notice Executed only by original lender\n     */\n    function novation(bytes32 loanId, address newOwner) public override workingLoan(loanId) {\n        Storage.LoanDeal storage deal = Storage.slot().loans[loanId];\n        require(Storage.slot().isTransferable, \"transfers not allowed\");\n\n        address prevLender = deal.lender;\n        require(msg.sender == prevLender, \"lender must trasfer\");\n\n        _removePaymentSchedule(loanId, deal);\n        collateralAggregator().releaseCollateral(\n            prevLender,\n            deal.borrower,\n            deal.ccy,\n            0,\n            deal.pv,\n            true\n        );\n\n        deal.lender = newOwner;\n\n        _registerPaymentSchedule(loanId, deal);\n        collateralAggregator().useCollateral(newOwner, deal.borrower, deal.ccy, 0, deal.pv, true);\n\n        emit Novation(loanId, newOwner);\n    }\n\n    function liquidate(bytes32 loanId) external override {\n        _liquidateLoan(loanId);\n    }\n\n    // =========== MARK-TO-MARKET SECTION ===========\n\n    /**\n     * @dev Main function for mark-to-market: updates present value,\n     * loan state and liquidates loan deal if collateral coverage <125%\n     * for every liquidation msg.sender get rewarded ~5% of loan deal PV.\n     * @param loanId Loan ID to update PV for\n     */\n    function markToMarket(bytes32 loanId) external override returns (bool) {\n        _verifyNotionalExchange(loanId);\n        require(updateLoanPV(loanId), \"failed update PV\");\n\n        return true;\n    }\n\n    /**\n     * @dev Triggers to update present value of loan.\n     * @param loanId Loan ID to update PV for\n     *\n     * @notice Calculates discount factors based on lending markets rates,\n     * and updates the state of the loan. Can be triggered to liquidate loan deal\n     * if borrower's collateral not enough.\n     */\n    function updateLoanPV(bytes32 loanId) internal returns (bool) {\n        uint256 pv = getDealPV(loanId);\n\n        if (pv != 0) {\n            Storage.LoanDeal storage deal = Storage.slot().loans[loanId];\n            if (!Storage.slot().isSettled[loanId]) return true;\n\n            uint256 oldPV = deal.pv == 0 ? deal.notional : deal.pv;\n            deal.pv = pv;\n\n            collateralAggregator().updatePV(\n                deal.lender,\n                deal.borrower,\n                deal.ccy,\n                0,\n                oldPV,\n                0,\n                deal.pv\n            );\n\n            emit MarkToMarket(loanId, oldPV, pv);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Triggers to recalculate present value of loan deal.\n     * @param loanId Loan ID to update PV for\n     */\n    function getDealPV(bytes32 loanId) public view override returns (uint256 pv) {\n        Storage.LoanDeal memory deal = Storage.slot().loans[loanId];\n        if (!Storage.slot().isSettled[loanId]) return deal.notional;\n\n        (uint256[] memory dfs, uint256[] memory terms) = lendingMarketController()\n            .getDiscountFactorsForCcy(deal.ccy);\n\n        (uint256[] memory payments, uint256[] memory amounts, ) = _constructSchedule(deal, false);\n\n        for (uint256 i = 0; i < payments.length; i++) {\n            if (payments[i] < block.timestamp) continue;\n            uint256 d = DiscountFactor.interpolateDF(dfs, terms, payments[i]);\n\n            pv = pv + amounts[i] * d;\n        }\n\n        return pv / ProtocolTypes.BP;\n    }\n\n    /**\n     * @dev Internal function to liquidate loan deal and remove all payments in timeslots\n     * @param loanId Loan deal ID\n     */\n    function _liquidateLoan(bytes32 loanId) internal {\n        Storage.LoanDeal memory deal = Storage.slot().loans[loanId];\n        _removePaymentSchedule(loanId, deal);\n\n        emit Liquidate(loanId);\n        delete Storage.slot().loans[loanId];\n    }\n\n    /**\n     * @dev Internal function to get TimeSlot position after adding days\n     * @param timestamp Timestamp to add days\n     * @param numDays number of days to add\n     * @return Updated timestamp and TimeSlot position\n     */\n    function _timeShift(uint256 timestamp, uint256 numDays) internal pure returns (uint256) {\n        timestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, numDays);\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Internal function for registering payment schedule while registering new loan\n     * @param loanId Loan deal ID\n     * @param deal LoanDeal structure\n     */\n    function _registerPaymentSchedule(bytes32 loanId, Storage.LoanDeal memory deal) internal {\n        (uint256[] memory payments, uint256[] memory amounts, ) = _constructSchedule(deal, false);\n\n        uint256[] memory lenderLeg = new uint256[](payments.length);\n        lenderLeg[0] = deal.notional;\n\n        paymentAggregator().registerPayments(\n            deal.lender,\n            deal.borrower,\n            deal.ccy,\n            loanId,\n            payments,\n            lenderLeg,\n            amounts\n        );\n    }\n\n    /**\n     * @dev Internal function for registering payment schedule while registering new loan\n     * @param loanId Loan deal ID\n     * @param deal LoanDeal structure\n     */\n    function _removePaymentSchedule(bytes32 loanId, Storage.LoanDeal memory deal) internal {\n        (uint256[] memory payments, uint256[] memory amounts, ) = _constructSchedule(deal, false);\n\n        uint256[] memory lenderLeg = new uint256[](payments.length);\n        if (!Storage.slot().isSettled[loanId]) {\n            lenderLeg[0] = deal.notional;\n        }\n\n        paymentAggregator().removePayments(\n            deal.lender,\n            deal.borrower,\n            deal.ccy,\n            loanId,\n            payments,\n            lenderLeg,\n            amounts\n        );\n    }\n\n    struct ScheduleConstructionLocalVars {\n        uint256 payNums;\n        uint256[] daysArr;\n        uint256 dfFrac;\n        uint256 coupon;\n        uint256 time;\n        bool status;\n    }\n\n    /**\n     * @dev Internal function to construct payment schedule using deal parameters\n     * @param deal Loan deal structure\n     * @param settlementStatus Boolean wether settlement status should be returned\n     * @return Payment schedule structure\n     */\n    function _constructSchedule(Storage.LoanDeal memory deal, bool settlementStatus)\n        internal\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            bool[] memory\n        )\n    {\n        ScheduleConstructionLocalVars memory vars;\n\n        vars.payNums = termStructure().getNumPayments(deal.term, Storage.slot().paymentFrequency);\n        vars.daysArr = termStructure().getTermSchedule(deal.term, Storage.slot().paymentFrequency);\n        vars.dfFrac = termStructure().getDfFrac(deal.term);\n\n        vars.coupon =\n            (deal.notional * deal.rate * vars.dfFrac) /\n            ProtocolTypes.BP /\n            ProtocolTypes.BP;\n\n        uint256 len = vars.payNums + 1;\n        uint256[] memory payments = new uint256[](len);\n        uint256[] memory amounts = new uint256[](len);\n        bool[] memory settlements = new bool[](len);\n\n        for (uint256 i = 1; i <= vars.payNums; i++) {\n            uint256 time = _timeShift(deal.start, vars.daysArr[i - 1]);\n\n            payments[i] = time;\n            if (i == vars.payNums) {\n                amounts[i] = deal.notional + vars.coupon;\n            } else {\n                amounts[i] = vars.coupon;\n            }\n\n            if (settlementStatus) {\n                vars.status = paymentAggregator().isSettled(\n                    deal.lender,\n                    deal.borrower,\n                    deal.ccy,\n                    vars.time\n                );\n                settlements[i] = vars.status;\n            }\n        }\n\n        uint256 settlement = _timeShift(deal.start, 2);\n        payments[0] = settlement;\n\n        return (payments, amounts, settlements);\n    }\n\n    /**\n     * @dev Internal function to verify the settlement of notional exchange\n     * @param loanId Loan deal id\n     */\n    function _verifyNotionalExchange(bytes32 loanId) internal {\n        if (!Storage.slot().isSettled[loanId]) {\n            Storage.LoanDeal memory deal = Storage.slot().loans[loanId];\n            uint256 time = _timeShift(deal.start, 2);\n            bool status = paymentAggregator().isSettled(deal.lender, deal.borrower, deal.ccy, time);\n\n            if (status) {\n                Storage.slot().isSettled[loanId] = true;\n                collateralAggregator().releaseCollateral(\n                    deal.lender,\n                    deal.borrower,\n                    deal.ccy,\n                    (deal.notional * ProtocolTypes.MKTMAKELEVEL) / ProtocolTypes.PCT,\n                    0,\n                    false\n                );\n                collateralAggregator().settleCollateral(\n                    deal.lender,\n                    deal.borrower,\n                    deal.ccy,\n                    0,\n                    deal.notional\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Triggers to return loan product implementation version\n     * @return implementation version\n     */\n    function getVersion() public pure override returns (uint16) {\n        return VERSION;\n    }\n}\n"
    },
    "contracts/interfaces/IProductWithOneLeg.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./IProduct.sol\";\n\n/**\n * @title IProductWithOneLeg is an extention over IProduct interface for\n * products with one leg of cashflows\n */\ninterface IProductWithOneLeg is IProduct {\n    struct Schedule {\n        uint256[] payments;\n        uint256[] amounts;\n        bool[] isSettled;\n    }\n\n    event Register(\n        address indexed lender,\n        address indexed borrower,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate,\n        bytes32 indexed dealId\n    );\n\n    event Novation(bytes32 indexed dealId, address currLender);\n\n    /**\n     * Triggered to register new deal for this product type\n     *\n     * @param maker Order maker\n     * @param taker orderTaker\n     * @param side Order side\n     * @param ccy Settlement currency\n     * @param term Deal term\n     * @param notional Notional amount of funds\n     * @param rate Annual interest rate\n     * @return dealId bytes32 string.\n     */\n    function register(\n        address maker,\n        address taker,\n        uint8 side,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate\n    ) external returns (bytes32 dealId);\n\n    /**\n     * Triggered to transfer lending obligations from msg.sender ot newOwner\n     * @param dealId Deal unique id in bytes32 word.\n     * @param newOwner ETH address of new product lender\n     */\n    function novation(bytes32 dealId, address newOwner) external;\n\n    /**\n     * Returns the payment schedule of the deal\n     * @param dealId Deal unique id in bytes32 word.\n     *\n     * @return Payment schedule payment timestamps, payment amounts and settlement statuses\n     */\n    function getPaymentSchedule(bytes32 dealId)\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            bool[] memory\n        );\n}\n"
    },
    "contracts/libraries/DiscountFactor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary DiscountFactor {\n    uint256 internal constant BP = 10000; // basis point\n    uint256 internal constant NON_ANNUAL_TERMS = 3;\n\n    function determineDF(\n        uint256 rate,\n        uint256 term,\n        uint256[] memory cache,\n        uint256 dfSum,\n        uint256 index\n    ) internal pure returns (uint256 df) {\n        if (term < 365) {\n            df = (BP * BP) / (BP + ((rate * term) / 360));\n        } else if (term == 365) {\n            df = (BP * BP) / ((BP + rate));\n            dfSum = dfSum + df;\n        } else {\n            uint256 rateSum = (rate * dfSum) / BP;\n            if (rateSum > BP) {\n                df = 0;\n            } else {\n                df = (BP * (BP - ((rate * dfSum) / BP))) / (BP + rate);\n            }\n            dfSum = dfSum + df;\n        }\n\n        cache[index] = df;\n\n        return dfSum;\n    }\n\n    function calculateDFs(uint256[] memory rates, uint256[] memory terms)\n        public\n        pure\n        returns (uint256[] memory, uint256[] memory)\n    {\n        require(rates.length == terms.length, \"INVALID_PARAMS\");\n\n        (uint256[] memory bootstrapedRates, uint256[] memory bootstrapedTerms) = bootstrapTerms(\n            rates,\n            terms\n        );\n\n        uint256 len = bootstrapedTerms.length;\n        uint256[] memory dfs = new uint256[](len);\n        uint256 dfSum;\n\n        for (uint256 i = 0; i < len; i++) {\n            dfSum = determineDF(bootstrapedRates[i], bootstrapedTerms[i], dfs, dfSum, i);\n        }\n\n        return (dfs, bootstrapedTerms);\n    }\n\n    function maxDFs(uint256 maxTerm) internal pure returns (uint256) {\n        return maxTerm / 365 + NON_ANNUAL_TERMS;\n    }\n\n    struct TermBootstrapingLocalVars {\n        uint256 extendedTerms;\n        uint256 delta;\n        uint256 numItems;\n        uint256 lastKnownRate;\n        uint256 nextKnownRate;\n        uint256 nextKnownTerm;\n        bool upwards;\n        uint256 deltaRate;\n        uint256 step;\n    }\n\n    function bootstrapTerms(uint256[] memory rates, uint256[] memory terms)\n        public\n        pure\n        returns (uint256[] memory, uint256[] memory)\n    {\n        uint256 len = maxDFs(terms[terms.length - 1]);\n\n        uint256[] memory filledRates = new uint256[](len);\n        uint256[] memory filledTerms = new uint256[](len);\n        TermBootstrapingLocalVars memory vars;\n\n        for (uint256 i = 0; i < terms.length - 1; i++) {\n            if (terms[i] < 365) {\n                filledRates[i] = rates[i];\n                filledTerms[i] = terms[i];\n                continue;\n            }\n            vars.delta = terms[i + 1] - terms[i];\n\n            if (vars.delta <= 365) {\n                filledRates[i] = rates[i];\n                filledTerms[i] = terms[i];\n                continue;\n            }\n\n            vars.numItems = vars.delta / 365;\n            vars.lastKnownRate = rates[i];\n\n            if (vars.extendedTerms == 0) {\n                filledRates[i] = vars.lastKnownRate;\n                filledTerms[i] = terms[i];\n            }\n            vars.nextKnownRate = rates[i + 1];\n            vars.nextKnownTerm = terms[i + 1];\n            vars.upwards = vars.nextKnownRate > vars.lastKnownRate ? true : false;\n            vars.deltaRate = vars.upwards\n                ? vars.nextKnownRate - vars.lastKnownRate\n                : vars.lastKnownRate - vars.nextKnownRate;\n            vars.step = vars.deltaRate / vars.numItems;\n\n            for (uint256 j = 1; j < vars.numItems; j++) {\n                vars.extendedTerms = vars.extendedTerms + 1;\n\n                uint256 newIndex = i + vars.extendedTerms;\n                uint256 missedRate = vars.upwards\n                    ? filledRates[newIndex - 1] + vars.step\n                    : filledRates[newIndex - 1] - vars.step;\n                uint256 missedTerm = terms[i] + uint256(365) * j;\n\n                filledRates[newIndex] = missedRate;\n                filledTerms[newIndex] = missedTerm;\n\n                if (j == vars.numItems - 1) {\n                    uint256 shifterIndex = newIndex + 1;\n\n                    filledRates[shifterIndex] = vars.nextKnownRate;\n                    filledTerms[shifterIndex] = vars.nextKnownTerm;\n                }\n            }\n        }\n\n        return (filledRates, filledTerms);\n    }\n\n    struct DFInterpolationLocalVars {\n        uint256 timeDelta;\n        uint256 termSeconds;\n        uint256 prevTermSeconds;\n        uint256 left;\n        uint256 right;\n        uint256 total;\n    }\n\n    /**\n     * @dev Triggers to adjust discount factors by interpolating to current loan maturity\n     * @param discountFactors Discount factors array\n     * @param terms Array of terms\n     * @param date Date to calculate discount factors for\n     *\n     */\n    function interpolateDF(\n        uint256[] memory discountFactors,\n        uint256[] memory terms,\n        uint256 date\n    ) public view returns (uint256) {\n        DFInterpolationLocalVars memory vars;\n        vars.timeDelta = date - block.timestamp;\n\n        if (vars.timeDelta <= terms[0] * 86400) {\n            vars.termSeconds = terms[0] * 86400;\n            vars.left = vars.termSeconds - vars.timeDelta;\n\n            return (BP * vars.left + (discountFactors[0] * vars.timeDelta)) / (vars.termSeconds);\n        } else {\n            for (uint256 i = 1; i < terms.length; i++) {\n                vars.termSeconds = terms[i] * 86400;\n                vars.prevTermSeconds = terms[i - 1] * 86400;\n\n                if (vars.prevTermSeconds < vars.timeDelta && vars.timeDelta <= vars.termSeconds) {\n                    vars.left = vars.timeDelta - vars.prevTermSeconds;\n\n                    if (vars.left == 0) {\n                        return discountFactors[i]; // gas savings only\n                    }\n\n                    vars.right = vars.termSeconds - vars.timeDelta;\n                    if (vars.right == 0) {\n                        return discountFactors[i];\n                    }\n\n                    vars.total = vars.termSeconds - vars.prevTermSeconds;\n\n                    return\n                        (discountFactors[i - 1] * vars.right + discountFactors[i] * vars.left) /\n                        vars.total;\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/storages/LoanV2Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary LoanV2Storage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.loanV2\");\n\n    struct LoanDeal {\n        address lender;\n        address borrower;\n        bytes32 ccy;\n        uint256 term;\n        uint256 notional;\n        uint256 rate;\n        uint256 start;\n        uint256 end;\n        uint256 pv;\n        bytes32 startTxHash;\n    }\n\n    struct Termination {\n        address terminationAsker;\n        uint256 terminationDate;\n    }\n    struct Storage {\n        uint8 paymentFrequency;\n        // Mapping for all storing LoanDeals per loanIDs.\n        mapping(bytes32 => LoanDeal) loans;\n        mapping(bytes32 => Termination) terminations;\n        mapping(bytes32 => bool) isSettled;\n        bool isTransferable;\n        uint256 lastLoanId;\n        mapping(bytes32 => mapping(uint256 => address)) lendingMarkets;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IProduct.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title IProduct is a common interface for various products on secured finance protocol\n */\ninterface IProduct {\n    event Liquidate(bytes32 dealId);\n    event RequestTermination(bytes32 dealId, address indexed requestedBy);\n    event RejectTermination(bytes32 dealId, address indexed rejectedBy);\n    event EarlyTermination(bytes32 dealId, address indexed acceptedBy, uint256 payment);\n    event MarkToMarket(bytes32 dealId, uint256 prevPV, uint256 currPV);\n\n    /**\n     * Triggered to liquidate existing deal of this product type\n     * @param dealId Deal unique id in bytes32 word.\n     */\n    function liquidate(bytes32 dealId) external;\n\n    /**\n     * Triggered to request early termination of this specific deal\n     * @param dealId Deal unique id in bytes32 word.\n     */\n    function requestTermination(bytes32 dealId) external;\n\n    /**\n     * Triggered to reject previously requested early termination of this deal\n     * @param dealId Deal unique id in bytes32 word.\n     */\n    function rejectTermination(bytes32 dealId) external;\n\n    /**\n     * Triggered to accept previously requested early termination of this deal\n     * @param dealId Deal unique id in bytes32 word.\n     */\n    function acceptTermination(bytes32 dealId) external;\n\n    /**\n     * Triggered to update present value of the deal\n     * @param dealId Deal unique id in bytes32 word.\n     */\n    function markToMarket(bytes32 dealId) external returns (bool);\n\n    // /**\n    //  * Returns the state of the deal by `dealId`\n    //  * @param dealId Deal unique id in bytes32 word.\n    //  *\n    //  * @return State identifier\n    //  */\n    // function getDealState(bytes32 dealId) external view returns (uint8);\n\n    /**\n     * Returns the main currency of the deal.\n     * @param dealId Deal unique id in bytes32 word.\n     *\n     * @return Currency short identifier.\n     */\n    function getDealCurrency(bytes32 dealId) external view returns (bytes32);\n\n    /**\n     * Returns previously saved present value of the deal.\n     * @param dealId Deal unique id in bytes32 word.\n     *\n     * @return Present value previously saved during mark-to-market.\n     */\n    function getDealLastPV(\n        address party0,\n        address party1,\n        bytes32 dealId\n    ) external view returns (uint256, uint256);\n\n    /**\n     * Triggers to recalculate and return current present value of the deal.\n     * @param dealId Deal unique id in bytes32 word.\n     *\n     * @return Present value at the time of execution.\n     */\n    function getDealPV(bytes32 dealId) external view returns (uint256);\n\n    /**\n     * Returns settlement status of the deal by `dealId`\n     * @param dealId Deal unique id in bytes32 word.\n     *\n     * @return Settlement bool identifier\n     */\n    function getDealSettlementStatus(bytes32 dealId) external view returns (bool);\n\n    /**\n     * Get the version of the underlying contract.\n     *\n     * @return Version number.\n     */\n    function getVersion() external view returns (uint16);\n}\n"
    },
    "contracts/PaymentAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./libraries/TimeSlot.sol\";\nimport \"./libraries/AddressPacking.sol\";\nimport \"./libraries/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"./interfaces/IPaymentAggregator.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\nimport \"./utils/Proxyable.sol\";\nimport {PaymentAggregatorStorage as Storage} from \"./storages/PaymentAggregatorStorage.sol\";\n\n/**\n * @title Payment Aggregator contract is used to aggregate payments\n * between counterparties in bilateral relationships. Those payments\n * are defined per counterparties addresses (packed into one bytes32),\n * main settlement currency and payment date.\n *\n * Contract linked to all product based contracts like Loan, Swap, etc.\n */\ncontract PaymentAggregator is IPaymentAggregator, MixinAddressResolver, Proxyable {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    uint256 public constant SETTLEMENT_WINDOW = 2;\n\n    modifier onlySettlementEngine() {\n        require(msg.sender == address(settlementEngine()), \"NOT_SETTLEMENT_ENGINE\");\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(address resolver) public initializer onlyProxy {\n        registerAddressResolver(resolver);\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](3);\n        contracts[0] = Contracts.CLOSE_OUT_NETTING;\n        contracts[1] = Contracts.MARK_TO_MARKET;\n        contracts[2] = Contracts.PRODUCT_ADDRESS_RESOLVER;\n    }\n\n    function isAcceptedContract(address account) internal view override returns (bool) {\n        return\n            productAddressResolver().isRegisteredProductContract(account) ||\n            super.isAcceptedContract(account);\n    }\n\n    struct TimeSlotPaymentsLocalVars {\n        bytes32 packedAddrs;\n        bool flipped;\n        uint256 totalPayment0;\n        uint256 totalPayment1;\n        bytes32 slotPosition;\n        uint256 year;\n        uint256 month;\n        uint256 day;\n    }\n\n    /**\n     * @dev Triggered to add new payments for a deal\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main settlement currency in a deal\n     * @param dealId Deal unique ID with prefix\n     * @param timestamps Array of timestamps for timeslot identification\n     * @param payments0 Array of cashflows owed by the first party\n     * @param payments1 Array of cashflows owed by the second party\n     */\n    function registerPayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] memory timestamps,\n        uint256[] memory payments0,\n        uint256[] memory payments1\n    ) external override onlyAcceptedContracts {\n        TimeSlotPaymentsLocalVars memory vars;\n        (vars.packedAddrs, ) = AddressPacking.pack(party0, party1);\n\n        for (uint256 i = 0; i < timestamps.length; i++) {\n            if (timestamps[i] == 0) continue;\n\n            (vars.year, vars.month, vars.day) = BokkyPooBahsDateTimeLibrary.timestampToDate(\n                timestamps[i]\n            );\n            vars.slotPosition = TimeSlot.position(vars.year, vars.month, vars.day);\n            Storage.slot().deals[vars.packedAddrs][ccy][vars.slotPosition].add(dealId);\n\n            if (payments0[i] > 0) {\n                vars.totalPayment0 = vars.totalPayment0 + payments0[i];\n            }\n\n            if (payments1[i] > 0) {\n                vars.totalPayment1 = vars.totalPayment1 + payments1[i];\n            }\n\n            TimeSlot.addPayment(\n                Storage.slot().timeSlots,\n                party0,\n                party1,\n                ccy,\n                vars.slotPosition,\n                payments0[i],\n                payments1[i]\n            );\n\n            emit RegisterPayment(\n                party0,\n                party1,\n                ccy,\n                vars.slotPosition,\n                vars.year,\n                vars.month,\n                vars.day,\n                payments0[i],\n                payments1[i]\n            );\n        }\n\n        closeOutNetting().addPayments(party0, party1, ccy, vars.totalPayment0, vars.totalPayment1);\n    }\n\n    struct PaymentSettlementLocalVars {\n        bytes32 slotPosition;\n        uint256 payment;\n        address verifier;\n        address counterparty;\n        bytes32 ccy;\n        bytes32 settlementId;\n        uint256 year;\n        uint256 month;\n        uint256 day;\n        uint256 totalPayment0;\n        uint256 totalPayment1;\n        bool isSettled;\n    }\n\n    /**\n     * @dev External function to verify payment by msg.sender, uses timestamp to identify TimeSlot.\n     * @param verifier Payment verifier address\n     * @param counterparty Counterparty address\n     * @param ccy Main payment settlement currency\n     * @param timestamp Main timestamp for TimeSlot\n     * @param payment Main payment settlement currency\n     * @param settlementId Main payment settlement id\n     */\n    function verifyPayment(\n        address verifier,\n        address counterparty,\n        bytes32 ccy,\n        uint256 timestamp,\n        uint256 payment,\n        bytes32 settlementId\n    ) external override {\n        require(checkSettlementWindow(timestamp), \"OUT_OF_SETTLEMENT_WINDOW\");\n        PaymentSettlementLocalVars memory vars;\n\n        vars.payment = payment;\n        vars.settlementId = settlementId;\n        vars.verifier = verifier;\n        vars.counterparty = counterparty;\n        vars.ccy = ccy;\n\n        (vars.year, vars.month, vars.day) = BokkyPooBahsDateTimeLibrary.timestampToDate(timestamp);\n        vars.slotPosition = TimeSlot.position(vars.year, vars.month, vars.day);\n\n        TimeSlot.verifyPayment(\n            Storage.slot().timeSlots,\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.slotPosition,\n            vars.payment,\n            vars.settlementId\n        );\n\n        emit VerifyPayment(\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.slotPosition,\n            vars.year,\n            vars.month,\n            vars.day,\n            vars.payment,\n            vars.settlementId\n        );\n\n        vars.isSettled = TimeSlot.isSettled(\n            Storage.slot().timeSlots,\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.slotPosition\n        );\n\n        if (vars.isSettled) {\n            _settlePayment(vars);\n        }\n    }\n\n    /**\n     * @dev Internal function to settle payment using payment settlement local variables.\n     * @param vars Local variables used in verifyPayment function\n     */\n    function _settlePayment(PaymentSettlementLocalVars memory vars) internal {\n        // TODO: Rework the settlement workflow to reduce gas consumption\n        (vars.totalPayment0, vars.totalPayment1, , , , ) = TimeSlot.get(\n            Storage.slot().timeSlots,\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.year,\n            vars.month,\n            vars.day\n        );\n\n        bytes32[] memory dealIds = getDealsFromSlot(\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.slotPosition\n        );\n        markToMarket().updatePVs(dealIds);\n\n        closeOutNetting().removePayments(\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.totalPayment0,\n            vars.totalPayment1\n        );\n\n        emit SettlePayment(\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.slotPosition,\n            vars.year,\n            vars.month,\n            vars.day,\n            vars.settlementId\n        );\n    }\n\n    /**\n     * @dev Triggered to remove existing payments for a deal\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main settlement currency in a deal\n     * @param dealId Deal unique ID with prefix\n     * @param timestamps Array of timestamps for timeslot identification\n     * @param payments0 Array of cashflows owed by the first party\n     * @param payments1 Array of cashflows owed by the second party\n     */\n    function removePayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] calldata timestamps,\n        uint256[] calldata payments0,\n        uint256[] calldata payments1\n    ) external override onlyAcceptedContracts {\n        TimeSlotPaymentsLocalVars memory vars;\n        (vars.packedAddrs, ) = AddressPacking.pack(party0, party1);\n\n        for (uint256 i = 0; i < timestamps.length; i++) {\n            if (timestamps[i] == 0) continue;\n\n            (vars.year, vars.month, vars.day) = BokkyPooBahsDateTimeLibrary.timestampToDate(\n                timestamps[i]\n            );\n            vars.slotPosition = TimeSlot.position(vars.year, vars.month, vars.day);\n\n            require(\n                Storage.slot().deals[vars.packedAddrs][ccy][vars.slotPosition].remove(dealId),\n                \"NON_REGISTERED_DEAL\"\n            );\n\n            vars.totalPayment0 = vars.totalPayment0 + payments0[i];\n            vars.totalPayment1 = vars.totalPayment1 + payments1[i];\n\n            TimeSlot.removePayment(\n                Storage.slot().timeSlots,\n                party0,\n                party1,\n                ccy,\n                vars.slotPosition,\n                payments0[i],\n                payments1[i]\n            );\n\n            emit RemovePayment(\n                party0,\n                party1,\n                ccy,\n                vars.slotPosition,\n                vars.year,\n                vars.month,\n                vars.day,\n                payments0[i],\n                payments1[i]\n            );\n        }\n\n        closeOutNetting().removePayments(\n            party0,\n            party1,\n            ccy,\n            vars.totalPayment0,\n            vars.totalPayment1\n        );\n    }\n\n    /**\n     * @dev Returns the time slot between parties using slot id.\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     */\n    function getTimeSlotByDate(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 year,\n        uint256 month,\n        uint256 day\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        )\n    {\n        return TimeSlot.get(Storage.slot().timeSlots, party0, party1, ccy, year, month, day);\n    }\n\n    /**\n     * @dev Returns the time slot between parties using slot id.\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     * @param slot TimeSlot position\n     */\n    function getTimeSlotBySlotId(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        )\n    {\n        return TimeSlot.getBySlotId(Storage.slot().timeSlots, party0, party1, ccy, slot);\n    }\n\n    /**\n     * @dev Returns the time slot between parties using slot id.\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     * @param year Calendar year of the settlement\n     * @param month Calendar month of the settlement\n     * @param day Calendar day of the settlement\n     * @param settlementId Settlement payment confirmation identifier\n     */\n    function getTimeSlotPaymentConfirmation(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        bytes32 settlementId\n    ) public view returns (address, uint256) {\n        return\n            TimeSlot.getPaymentConfirmation(\n                Storage.slot().timeSlots,\n                party0,\n                party1,\n                ccy,\n                year,\n                month,\n                day,\n                settlementId\n            );\n    }\n\n    /**\n     * @dev Returns the time slot between parties using slot id.\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     * @param slot TimeSlot position\n     * @param settlementId Settlement payment confirmation identifier\n     */\n    function getTimeSlotPaymentConfirmationById(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot,\n        bytes32 settlementId\n    ) public view returns (address, uint256) {\n        return\n            TimeSlot.getPaymentConfirmationById(\n                Storage.slot().timeSlots,\n                party0,\n                party1,\n                ccy,\n                slot,\n                settlementId\n            );\n    }\n\n    /**\n     * @dev Internal function to get TimeSlot position after adding days\n     * @param timestamp Timestamp to add days\n     * @param numSeconds number of seconds to add\n     * @return Updated timestamp and TimeSlot position\n     */\n    function _slotPositionPlusDays(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (bytes32, uint256)\n    {\n        uint256 numDays = numSeconds / 86400;\n        timestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, numDays);\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(\n            timestamp\n        );\n        bytes32 slotPosition = TimeSlot.position(year, month, day);\n\n        return (slotPosition, timestamp);\n    }\n\n    /**\n     * @dev Internal function to get TimeSlot position\n     * @param timestamp Timestamp for conversion\n     * @return TimeSlot position\n     */\n    function _slotPosition(uint256 timestamp) internal pure returns (bytes32) {\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(\n            timestamp\n        );\n        bytes32 slotPosition = TimeSlot.position(year, month, day);\n\n        return slotPosition;\n    }\n\n    /**\n     * @dev Triggers settlement status of the time slot\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     * @param timestamp TimeSlot timestamp\n     * @return status Boolean if slot was settled\n     */\n    function isSettled(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 timestamp\n    ) external view override returns (bool status) {\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary.timestampToDate(\n            timestamp\n        );\n        bytes32 slotPosition = TimeSlot.position(year, month, day);\n\n        status = TimeSlot.isSettled(Storage.slot().timeSlots, party0, party1, ccy, slotPosition);\n    }\n\n    /**\n     * @dev Internal function to check if settlement payment is within available timeline\n     * @param targetTime target time for settlement of time slot\n     * @return Boolean if slot within the settlement window\n     */\n    function checkSettlementWindow(uint256 targetTime) public view override returns (bool) {\n        uint256 time = block.timestamp;\n        uint256 delta = BokkyPooBahsDateTimeLibrary.diffDays(time, targetTime);\n\n        return !(delta > SETTLEMENT_WINDOW);\n    }\n\n    function getDealsFromSlot(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slotPosition\n    ) public view override returns (bytes32[] memory) {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        EnumerableSet.Bytes32Set storage set = Storage.slot().deals[packedAddrs][ccy][slotPosition];\n\n        uint256 numDeals = set.length();\n        bytes32[] memory dealIds = new bytes32[](numDeals);\n\n        for (uint256 i = 0; i < numDeals; i++) {\n            bytes32 deal = set.at(i);\n            dealIds[i] = deal;\n        }\n\n        return dealIds;\n    }\n}\n"
    },
    "contracts/mocks/PaymentAggregatorCallerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../interfaces/IPaymentAggregator.sol\";\n\ncontract PaymentAggregatorCallerMock {\n    IPaymentAggregator public paymentAggregator;\n\n    constructor(address _paymentAggregator) {\n        paymentAggregator = IPaymentAggregator(_paymentAggregator);\n    }\n\n    function registerPayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] memory timestamps,\n        uint256[] memory payments0,\n        uint256[] memory payments1\n    ) public {\n        paymentAggregator.registerPayments(\n            party0,\n            party1,\n            ccy,\n            dealId,\n            timestamps,\n            payments0,\n            payments1\n        );\n    }\n\n    function removePayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] calldata timestamps,\n        uint256[] calldata payments0,\n        uint256[] calldata payments1\n    ) public {\n        paymentAggregator.removePayments(\n            party0,\n            party1,\n            ccy,\n            dealId,\n            timestamps,\n            payments0,\n            payments1\n        );\n    }\n\n    function verifyPayment(\n        address counterparty,\n        bytes32 ccy,\n        uint256 timestamp,\n        uint256 payment,\n        bytes32 settlementId\n    ) public {\n        paymentAggregator.verifyPayment(\n            msg.sender,\n            counterparty,\n            ccy,\n            timestamp,\n            payment,\n            settlementId\n        );\n    }\n\n    function isRegisteredProductContract(address _product) public pure returns (bool) {\n        return address(_product) != address(0);\n    }\n}\n"
    },
    "contracts/mocks/BokkyPooBahsDateTimeContract.sol": {
      "content": "// SPDX-License-Identifier: GNU Lesser General Public License 3.0\npragma solidity ^0.8.9;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.00 - Contract Instance\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.\n//\n// GNU Lesser General Public License 3.0\n// https://www.gnu.org/licenses/lgpl-3.0.en.html\n// ----------------------------------------------------------------------------\n\nimport \"../libraries/BokkyPooBahsDateTimeLibrary.sol\";\n\ncontract BokkyPooBahsDateTimeContract {\n    uint256 public constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 public constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 public constant SECONDS_PER_MINUTE = 60;\n    int256 public constant OFFSET19700101 = 2440588;\n\n    uint256 public constant DOW_MON = 1;\n    uint256 public constant DOW_TUE = 2;\n    uint256 public constant DOW_WED = 3;\n    uint256 public constant DOW_THU = 4;\n    uint256 public constant DOW_FRI = 5;\n    uint256 public constant DOW_SAT = 6;\n    uint256 public constant DOW_SUN = 7;\n\n    function _now() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    function _nowDateTime()\n        public\n        view\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(\n            block.timestamp\n        );\n    }\n\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) public pure returns (uint256 _days) {\n        return BokkyPooBahsDateTimeLibrary._daysFromDate(year, month, day);\n    }\n\n    function _daysToDate(uint256 _days)\n        public\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        return BokkyPooBahsDateTimeLibrary._daysToDate(_days);\n    }\n\n    function timestampFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) public pure returns (uint256 timestamp) {\n        return BokkyPooBahsDateTimeLibrary.timestampFromDate(year, month, day);\n    }\n\n    function timestampFromDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) public pure returns (uint256 timestamp) {\n        return\n            BokkyPooBahsDateTimeLibrary.timestampFromDateTime(\n                year,\n                month,\n                day,\n                hour,\n                minute,\n                second\n            );\n    }\n\n    function timestampToDate(uint256 timestamp)\n        public\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = BokkyPooBahsDateTimeLibrary.timestampToDate(timestamp);\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n        public\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(\n            timestamp\n        );\n    }\n\n    function isValidDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) public pure returns (bool valid) {\n        valid = BokkyPooBahsDateTimeLibrary.isValidDate(year, month, day);\n    }\n\n    function isValidDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) public pure returns (bool valid) {\n        valid = BokkyPooBahsDateTimeLibrary.isValidDateTime(year, month, day, hour, minute, second);\n    }\n\n    function isLeapYear(uint256 timestamp) public pure returns (bool leapYear) {\n        leapYear = BokkyPooBahsDateTimeLibrary.isLeapYear(timestamp);\n    }\n\n    function _isLeapYear(uint256 year) public pure returns (bool leapYear) {\n        leapYear = BokkyPooBahsDateTimeLibrary._isLeapYear(year);\n    }\n\n    function isWeekDay(uint256 timestamp) public pure returns (bool weekDay) {\n        weekDay = BokkyPooBahsDateTimeLibrary.isWeekDay(timestamp);\n    }\n\n    function isWeekEnd(uint256 timestamp) public pure returns (bool weekEnd) {\n        weekEnd = BokkyPooBahsDateTimeLibrary.isWeekEnd(timestamp);\n    }\n\n    function getDaysInMonth(uint256 timestamp) public pure returns (uint256 daysInMonth) {\n        daysInMonth = BokkyPooBahsDateTimeLibrary.getDaysInMonth(timestamp);\n    }\n\n    function _getDaysInMonth(uint256 year, uint256 month)\n        public\n        pure\n        returns (uint256 daysInMonth)\n    {\n        daysInMonth = BokkyPooBahsDateTimeLibrary._getDaysInMonth(year, month);\n    }\n\n    function getDayOfWeek(uint256 timestamp) public pure returns (uint256 dayOfWeek) {\n        dayOfWeek = BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp);\n    }\n\n    function getYear(uint256 timestamp) public pure returns (uint256 year) {\n        year = BokkyPooBahsDateTimeLibrary.getYear(timestamp);\n    }\n\n    function getMonth(uint256 timestamp) public pure returns (uint256 month) {\n        month = BokkyPooBahsDateTimeLibrary.getMonth(timestamp);\n    }\n\n    function getDay(uint256 timestamp) public pure returns (uint256 day) {\n        day = BokkyPooBahsDateTimeLibrary.getDay(timestamp);\n    }\n\n    function getHour(uint256 timestamp) public pure returns (uint256 hour) {\n        hour = BokkyPooBahsDateTimeLibrary.getHour(timestamp);\n    }\n\n    function getMinute(uint256 timestamp) public pure returns (uint256 minute) {\n        minute = BokkyPooBahsDateTimeLibrary.getMinute(timestamp);\n    }\n\n    function getSecond(uint256 timestamp) public pure returns (uint256 second) {\n        second = BokkyPooBahsDateTimeLibrary.getSecond(timestamp);\n    }\n\n    function addYears(uint256 timestamp, uint256 _years)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addYears(timestamp, _years);\n    }\n\n    function getGasCostofAddYears(uint256 timestamp, uint256 _years) public view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        BokkyPooBahsDateTimeLibrary.addYears(timestamp, _years);\n\n        return gasBefore - gasleft();\n    }\n\n    function addMonths(uint256 timestamp, uint256 _months)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(timestamp, _months);\n    }\n\n    function getGasCostofAddMonths(uint256 timestamp, uint256 _months)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        BokkyPooBahsDateTimeLibrary.addMonths(timestamp, _months);\n\n        return gasBefore - gasleft();\n    }\n\n    function addDays(uint256 timestamp, uint256 _days) public pure returns (uint256 newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, _days);\n    }\n\n    function getGasCostofAddDays(uint256 timestamp, uint256 _days) public view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        BokkyPooBahsDateTimeLibrary.addDays(timestamp, _days);\n\n        return gasBefore - gasleft();\n    }\n\n    function addHours(uint256 timestamp, uint256 _hours)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addHours(timestamp, _hours);\n    }\n\n    function addMinutes(uint256 timestamp, uint256 _minutes)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addMinutes(timestamp, _minutes);\n    }\n\n    function addSeconds(uint256 timestamp, uint256 _seconds)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addSeconds(timestamp, _seconds);\n    }\n\n    function getGasCostofAddSeconds(uint256 timestamp, uint256 _seconds)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        BokkyPooBahsDateTimeLibrary.addSeconds(timestamp, _seconds);\n\n        return gasBefore - gasleft();\n    }\n\n    function subYears(uint256 timestamp, uint256 _years)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subYears(timestamp, _years);\n    }\n\n    function subMonths(uint256 timestamp, uint256 _months)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subMonths(timestamp, _months);\n    }\n\n    function subDays(uint256 timestamp, uint256 _days) public pure returns (uint256 newTimestamp) {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subDays(timestamp, _days);\n    }\n\n    function subHours(uint256 timestamp, uint256 _hours)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subHours(timestamp, _hours);\n    }\n\n    function subMinutes(uint256 timestamp, uint256 _minutes)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subMinutes(timestamp, _minutes);\n    }\n\n    function subSeconds(uint256 timestamp, uint256 _seconds)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subSeconds(timestamp, _seconds);\n    }\n\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _years)\n    {\n        _years = BokkyPooBahsDateTimeLibrary.diffYears(fromTimestamp, toTimestamp);\n    }\n\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _months)\n    {\n        _months = BokkyPooBahsDateTimeLibrary.diffMonths(fromTimestamp, toTimestamp);\n    }\n\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _days)\n    {\n        _days = BokkyPooBahsDateTimeLibrary.diffDays(fromTimestamp, toTimestamp);\n    }\n\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _hours)\n    {\n        _hours = BokkyPooBahsDateTimeLibrary.diffHours(fromTimestamp, toTimestamp);\n    }\n\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _minutes)\n    {\n        _minutes = BokkyPooBahsDateTimeLibrary.diffMinutes(fromTimestamp, toTimestamp);\n    }\n\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _seconds)\n    {\n        _seconds = BokkyPooBahsDateTimeLibrary.diffSeconds(fromTimestamp, toTimestamp);\n    }\n}\n"
    },
    "contracts/migrations/MigrationAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../mixins/MixinAddressResolver.sol\";\n\ncontract MigrationAddressResolver {\n    function buildCaches(address[] calldata _addresses) external {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            MixinAddressResolver destination = MixinAddressResolver(_addresses[i]);\n            if (!destination.isResolverCached()) {\n                destination.buildCache();\n            }\n        }\n    }\n}\n"
    },
    "contracts/MarkToMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./interfaces/IMarketController.sol\";\nimport \"./interfaces/IMarkToMarket.sol\";\nimport \"./interfaces/IProduct.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\nimport \"./utils/Proxyable.sol\";\n\ncontract MarkToMarket is IMarkToMarket, MixinAddressResolver, Proxyable {\n    uint256 constant NOTICE = 2 weeks;\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(address resolver) public initializer onlyProxy {\n        registerAddressResolver(resolver);\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](1);\n        contracts[0] = Contracts.PRODUCT_ADDRESS_RESOLVER;\n    }\n\n    struct PresentValueCalcLocalVars {\n        bytes4 prefix;\n        address controller;\n        IMarketController controllerContract;\n        address product;\n        IProduct productContract;\n    }\n\n    /**\n     * @dev Triggers to update present value for a single deal.\n     * @param dealId Deal ID to update PV for\n     */\n    function updatePV(bytes32 dealId) public override {\n        address product = productAddressResolver().getProductContractByDealId(dealId);\n\n        require(IProduct(product).markToMarket(dealId), \"CAN'T DO MARK-TO-MARKET\");\n    }\n\n    /**\n     * @dev Triggers to update present value for a multiple deals.\n     * @param dealIds Array of Deal IDs to update PV for\n     */\n    function updatePVs(bytes32[] memory dealIds) public override {\n        PresentValueCalcLocalVars memory vars;\n\n        for (uint256 i = 0; i < dealIds.length; i++) {\n            bytes32 dealId = dealIds[i];\n\n            vars.product = productAddressResolver().getProductContractByDealId(dealId);\n\n            require(IProduct(vars.product).markToMarket(dealId), \"CAN'T DO MARK-TO-MARKET\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IMarketController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IMarketController {\n    function getBorrowRatesForCcy(bytes32 _ccy) external view returns (uint256[] memory rates);\n\n    function getDiscountFactorsForCcy(bytes32 _ccy)\n        external\n        view\n        returns (uint256[] memory, uint256[] memory);\n\n    function getLendRatesForCcy(bytes32 _ccy) external view returns (uint256[] memory rates);\n\n    function getMidRatesForCcy(bytes32 _ccy) external view returns (uint256[] memory rates);\n}\n"
    },
    "contracts/Liquidations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./libraries/AddressPacking.sol\";\nimport \"./interfaces/IProduct.sol\";\nimport \"./interfaces/ILiquidations.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\nimport \"./utils/Ownable.sol\";\nimport \"./utils/Proxyable.sol\";\nimport {LiquidationsStorage as Storage} from \"./storages/LiquidationsStorage.sol\";\n\ncontract Liquidations is ILiquidations, MixinAddressResolver, Ownable, Proxyable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /**\n     * @dev Modifier to make a function callable only by liquidation agent.\n     */\n    modifier onlyLiquidationAgent() {\n        require(Storage.slot().liquidationAgents.contains(msg.sender), \"INVALID ACCESS\");\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(\n        address owner,\n        address resolver,\n        uint256 offset\n    ) public initializer onlyProxy {\n        _transferOwnership(owner);\n        registerAddressResolver(resolver);\n        Storage.slot().liquidationAgents.add(owner);\n        Storage.slot().offset = offset;\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](3);\n        contracts[0] = Contracts.COLLATERAL_AGGREGATOR;\n        contracts[1] = Contracts.CURRENCY_CONTROLLER;\n        contracts[2] = Contracts.PRODUCT_ADDRESS_RESOLVER;\n    }\n\n    function isAcceptedContract(address account) internal view override returns (bool) {\n        return\n            productAddressResolver().isRegisteredProductContract(account) ||\n            super.isAcceptedContract(account);\n    }\n\n    /**\n     * @dev Updates offset for maximum number of deals liquidated per one execution.\n     * @param _offset New liquidation offset\n     */\n    function updateLiquidationOffset(uint256 _offset) public override onlyOwner {\n        require(_offset > 0, \"INCORRECT_OFFSET\");\n        emit OffsetUpdated(Storage.slot().offset, _offset);\n        Storage.slot().offset = _offset;\n    }\n\n    /**\n     * @dev Adds liquidation agent address into the set.\n     * @param _liquidationAgent Liquidation agent address\n     */\n    function addLiquidationAgent(address _liquidationAgent) public override onlyOwner {\n        Storage.slot().liquidationAgents.add(_liquidationAgent);\n        emit LiquidationAgentAdded(_liquidationAgent);\n    }\n\n    /**\n     * @dev Removes liquidation agent address from the set.\n     * @param _liquidationAgent Liquidation agent address\n     */\n    function removeLiquidationAgent(address _liquidationAgent) public override onlyOwner {\n        Storage.slot().liquidationAgents.remove(_liquidationAgent);\n        emit LiquidationAgentRemoved(_liquidationAgent);\n    }\n\n    function addDealToLiquidationQueue(\n        address party0,\n        address party1,\n        bytes32 dealId\n    ) public override onlyAcceptedContracts {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        EnumerableSet.Bytes32Set storage set = Storage.slot().liquidationQueue[packedAddrs];\n\n        require(!set.contains(dealId), \"ALREADY EXISTING DEAL\");\n        set.add(dealId);\n\n        emit DealAddedToLiquidationQueue(party0, party1, dealId);\n    }\n\n    function removeDealFromLiquidationQueue(\n        address party0,\n        address party1,\n        bytes32 dealId\n    ) public override onlyAcceptedContracts {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        EnumerableSet.Bytes32Set storage set = Storage.slot().liquidationQueue[packedAddrs];\n\n        require(set.contains(dealId), \"NON EXISTING DEAL\");\n        set.remove(dealId);\n\n        emit DealRemovedFromLiquidationQueue(party0, party1, dealId);\n    }\n\n    /**\n     * @dev Triggers to liquidate multiple deals according to the liquidation queue\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     */\n    function liquidateDeals(address party0, address party1) public override onlyLiquidationAgent {\n        (bool coverage0, bool coverage1) = collateralAggregator().isCovered(\n            party0,\n            party1,\n            \"\",\n            0,\n            0,\n            false\n        );\n        if (coverage0 && coverage1) return;\n\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        EnumerableSet.Bytes32Set storage set = Storage.slot().liquidationQueue[packedAddrs];\n\n        uint256 numDeals = set.length();\n        uint256 numLiquidations;\n        numDeals > Storage.slot().offset\n            ? numLiquidations = Storage.slot().offset\n            : numLiquidations = numDeals;\n        bytes32[] memory dealIds = new bytes32[](numLiquidations);\n\n        for (uint256 i = 0; i < numLiquidations; i++) {\n            bytes32 dealId = set.at(i);\n            dealIds[i] = dealId;\n        }\n\n        _liquidateDeals(party0, party1, dealIds);\n    }\n\n    /**\n     * @dev Triggers to liquidate multiple deals with specific `_dealIds`.\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param dealIds Array of Deal ID to liquidate\n     */\n    function liquidateDeals(\n        address party0,\n        address party1,\n        bytes32[] memory dealIds\n    ) public override onlyLiquidationAgent {\n        require(dealIds.length < Storage.slot().offset, \"TOO MUCH DEALS\");\n        (bool coverage0, bool coverage1) = collateralAggregator().isCovered(\n            party0,\n            party1,\n            \"\",\n            0,\n            0,\n            false\n        );\n        if (coverage0 && coverage1) return;\n\n        _liquidateDeals(party0, party1, dealIds);\n    }\n\n    /**\n     * @dev Triggers to get liquidation offset.\n     */\n    function getOffset() external view returns (uint256) {\n        return Storage.slot().offset;\n    }\n\n    struct LiquidationLocalVars {\n        bytes32 dealId;\n        uint256 dealPV0;\n        uint256 dealPV1;\n        uint256 totalLiquidationPVInETH0;\n        uint256 totalLiquidationPVInETH1;\n        uint256 exchangeRate;\n        bytes32 currency;\n        address product;\n    }\n\n    function _liquidateDeals(\n        address party0,\n        address party1,\n        bytes32[] memory dealIds\n    ) internal {\n        LiquidationLocalVars memory vars;\n\n        for (uint256 i = 0; i < dealIds.length; i++) {\n            vars.dealId = dealIds[i];\n            vars.product = productAddressResolver().getProductContractByDealId(vars.dealId);\n\n            vars.currency = IProduct(vars.product).getDealCurrency(vars.dealId);\n\n            (vars.dealPV0, vars.dealPV1) = IProduct(vars.product).getDealLastPV(\n                party0,\n                party1,\n                vars.dealId\n            );\n            vars.exchangeRate = uint256(currencyController().getLastETHPrice(vars.currency));\n\n            vars.dealPV0 = (vars.dealPV0 * vars.exchangeRate) / 1e18;\n            vars.dealPV1 = (vars.dealPV1 * vars.exchangeRate) / 1e18;\n\n            vars.totalLiquidationPVInETH0 = vars.totalLiquidationPVInETH0 + vars.dealPV0;\n            vars.totalLiquidationPVInETH1 = vars.totalLiquidationPVInETH1 + vars.dealPV1;\n\n            IProduct(vars.product).liquidate(vars.dealId);\n        }\n\n        if (vars.totalLiquidationPVInETH0 > 0) {\n            collateralAggregator().liquidate(party0, party1, vars.totalLiquidationPVInETH0);\n        }\n\n        if (vars.totalLiquidationPVInETH1 > 0) {\n            collateralAggregator().liquidate(party1, party0, vars.totalLiquidationPVInETH1);\n        }\n    }\n}\n"
    },
    "contracts/storages/LiquidationsStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary LiquidationsStorage {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.liquidations\");\n\n    struct Storage {\n        uint256 offset;\n        EnumerableSet.AddressSet liquidationAgents;\n        EnumerableSet.AddressSet linkedContracts;\n        // Mapping structure for storing liquidation queue to bilateral position\n        mapping(bytes32 => EnumerableSet.Bytes32Set) liquidationQueue;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "contracts/LendingMarketController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./libraries/QuickSort.sol\";\nimport \"./libraries/DiscountFactor.sol\";\nimport \"./LendingMarket.sol\";\nimport \"./interfaces/ILendingMarketController.sol\";\nimport \"./interfaces/ILendingMarket.sol\";\nimport \"./libraries/ProductPrefixes.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\nimport \"./utils/Ownable.sol\";\nimport \"./utils/Proxyable.sol\";\nimport {LendingMarketControllerStorage as Storage} from \"./storages/LendingMarketControllerStorage.sol\";\n\n/**\n * @dev Lending Market Controller contract is managing separated lending\n * order-book markets (per term) and responsible to calculate Discount Factors per currency\n * and construct yield curve\n *\n * It will store lending market addresses by ccy and term in lendingMarkets mapping.\n */\ncontract LendingMarketController is\n    ILendingMarketController,\n    MixinAddressResolver,\n    Ownable,\n    Proxyable\n{\n    using QuickSort for uint256[];\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(address owner, address resolver) public initializer onlyProxy {\n        _transferOwnership(owner);\n        registerAddressResolver(resolver);\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](2);\n        contracts[0] = Contracts.CURRENCY_CONTROLLER;\n        contracts[1] = Contracts.TERM_STRUCTURE;\n    }\n\n    // =========== YIELD CURVE FUNCTIONS ===========\n\n    /**\n     * @dev Triggers to get borrow rates for selected currency.\n     * @param _ccy Currency\n     */\n    function getBorrowRatesForCcy(bytes32 _ccy) external view override returns (uint256[] memory) {\n        uint256[] memory terms = Storage.slot().supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint256 i = 0; i < terms.length; i++) {\n            uint256 term = terms[i];\n            ILendingMarket market = ILendingMarket(Storage.slot().lendingMarkets[_ccy][term]);\n            rates[i] = market.getBorrowRate();\n        }\n\n        return rates;\n    }\n\n    /**\n     * @dev Triggers to get lend rates for selected currency.\n     * @param _ccy Currency\n     */\n    function getLendRatesForCcy(bytes32 _ccy) external view override returns (uint256[] memory) {\n        uint256[] memory terms = Storage.slot().supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint256 i = 0; i < terms.length; i++) {\n            uint256 term = terms[i];\n            ILendingMarket market = ILendingMarket(Storage.slot().lendingMarkets[_ccy][term]);\n            rates[i] = market.getLendRate();\n        }\n\n        return rates;\n    }\n\n    /**\n     * @dev Triggers to get mid rates for selected currency.\n     * @param _ccy Currency\n     */\n    function getMidRatesForCcy(bytes32 _ccy) public view override returns (uint256[] memory) {\n        uint256[] memory terms = Storage.slot().supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint256 i = 0; i < terms.length; i++) {\n            uint256 term = terms[i];\n            ILendingMarket market = ILendingMarket(Storage.slot().lendingMarkets[_ccy][term]);\n            rates[i] = market.getMidRate();\n        }\n\n        return rates;\n    }\n\n    /**\n     * @dev Triggers to get lending market.\n     * @param _ccy Currency for Lending Market\n     * @param _term Term for Lending Market\n     */\n    function getLendingMarket(bytes32 _ccy, uint256 _term)\n        external\n        view\n        override\n        returns (address)\n    {\n        return Storage.slot().lendingMarkets[_ccy][_term];\n    }\n\n    // =========== DISCOUNT FACTORS CALCULATION ===========\n\n    /**\n     * @dev Triggers to discount factor for selected currency.\n     * @param _ccy Currency\n     */\n    function getDiscountFactorsForCcy(bytes32 _ccy)\n        external\n        view\n        override\n        returns (uint256[] memory, uint256[] memory)\n    {\n        uint256[] memory rates = getMidRatesForCcy(_ccy);\n        return DiscountFactor.calculateDFs(rates, Storage.slot().supportedTerms[_ccy]);\n    }\n\n    /**\n     * @dev Triggers to supported terms for selected currency.\n     * @param _ccy Currency\n     */\n    function getSupportedTerms(bytes32 _ccy) external view override returns (uint256[] memory) {\n        return Storage.slot().supportedTerms[_ccy];\n    }\n\n    // =========== MARKET DEPLOYMENT FUNCTIONS ===========\n\n    /**\n     * @dev Deploys new Lending Market and save address at lendingMarkets mapping.\n     * @param _ccy Main currency for new lending market\n     * @param _term Term for new Lending Market\n     *\n     * @notice Reverts on deployment market with existing currency and term\n     */\n    function deployLendingMarket(bytes32 _ccy, uint256 _term)\n        external\n        override\n        onlyOwner\n        returns (address market)\n    {\n        require(currencyController().isSupportedCcy(_ccy), \"NON SUPPORTED CCY\");\n        require(\n            termStructure().isSupportedTerm(_term, ProductPrefixes.LOAN, _ccy),\n            \"NON SUPPORTED TERM\"\n        );\n        require(\n            Storage.slot().lendingMarkets[_ccy][_term] == address(0),\n            \"Couldn't rewrite existing market\"\n        );\n        market = address(new LendingMarket(address(resolver), _ccy, _term));\n        Storage.slot().lendingMarkets[_ccy][_term] = market;\n\n        Storage.slot().supportedTerms[_ccy].push(_term);\n        Storage.slot().supportedTerms[_ccy] = Storage.slot().supportedTerms[_ccy].sort();\n\n        emit LendingMarketCreated(_ccy, _term, market);\n        return market;\n    }\n\n    // =========== LENDING MARKETS MANAGEMENT FUNCTIONS ===========\n\n    /**\n     * @dev Pauses previously deployed lending market by currency\n     * @param _ccy Currency for pausing all lending markets\n     */\n    function pauseLendingMarkets(bytes32 _ccy) external override onlyOwner returns (bool) {\n        uint256[] memory terms = Storage.slot().supportedTerms[_ccy];\n\n        for (uint256 i = 0; i < terms.length; i++) {\n            uint256 term = terms[i];\n            ILendingMarket market = ILendingMarket(Storage.slot().lendingMarkets[_ccy][term]);\n            market.pauseMarket();\n        }\n\n        emit LendingMarketsPaused(_ccy);\n        return true;\n    }\n\n    /**\n     * @dev Unpauses previously deployed lending market by currency\n     * @param _ccy Currency for pausing all lending markets\n     */\n    function unpauseLendingMarkets(bytes32 _ccy) external override onlyOwner returns (bool) {\n        uint256[] memory terms = Storage.slot().supportedTerms[_ccy];\n\n        for (uint256 i = 0; i < terms.length; i++) {\n            uint256 term = terms[i];\n            ILendingMarket market = ILendingMarket(Storage.slot().lendingMarkets[_ccy][term]);\n            market.unpauseMarket();\n        }\n\n        emit LendingMarketsUnpaused(_ccy);\n        return true;\n    }\n\n    // =========== BULK TRADE FUNCTIONS ===========\n\n    /**\n     * @dev Places orders in multiple Lending Markets.\n     * @param orders Lending Market orders array with ccy and terms to identify right market\n     */\n    function placeBulkOrders(Order[] memory orders) external override returns (bool) {\n        for (uint8 i = 0; i < orders.length; i++) {\n            Order memory order = orders[i];\n\n            ILendingMarket market = ILendingMarket(\n                Storage.slot().lendingMarkets[order.ccy][order.term]\n            );\n            market.order(order.side, order.amount, order.rate);\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/LendingMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/ILendingMarket.sol\";\nimport \"./interfaces/ILoanV2.sol\";\nimport \"./libraries/HitchensOrderStatisticsTreeLib.sol\";\nimport \"./libraries/ProductPrefixes.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\nimport \"./types/ProtocolTypes.sol\";\n\n/**\n * @dev Lending Market contract module which allows lending market participants\n * to create/take/cancel market orders.\n *\n * It will store market orders in structured red-black tree and doubly linked list in each node.\n */\ncontract LendingMarket is ILendingMarket, MixinAddressResolver, ReentrancyGuard, Pausable {\n    using HitchensOrderStatisticsTreeLib for HitchensOrderStatisticsTreeLib.Tree;\n\n    uint256 public last_order_id;\n    bytes32 public MarketCcy;\n    uint256 public MarketTerm;\n\n    /**\n     * @dev Order Book mapping for all Market Orders.\n     */\n    mapping(uint256 => MarketOrder) public orders;\n    HitchensOrderStatisticsTreeLib.Tree lendOrders;\n    HitchensOrderStatisticsTreeLib.Tree borrowOrders;\n\n    /**\n     * @dev Constructor.\n     * @param _ccy The main currency for order book lending deals\n     * @param _term The main term for order book lending deals\n     */\n    constructor(\n        address _resolver,\n        bytes32 _ccy,\n        uint256 _term\n    ) {\n        registerAddressResolver(_resolver);\n        MarketCcy = _ccy;\n        MarketTerm = _term;\n        buildCache();\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](3);\n        contracts[0] = Contracts.COLLATERAL_AGGREGATOR;\n        contracts[1] = Contracts.LENDING_MARKET_CONTROLLER;\n        contracts[2] = Contracts.PRODUCT_ADDRESS_RESOLVER;\n    }\n\n    function acceptedContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](1);\n        contracts[0] = Contracts.LENDING_MARKET_CONTROLLER;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by order maker.\n     * @param orderId Market order id\n     */\n    modifier onlyMaker(uint256 orderId) {\n        require(msg.sender == getMaker(orderId), \"No access to cancel order\");\n        _;\n    }\n\n    /**\n     * @dev Triggers to get order maker address.\n     * @param orderId Market order id\n     */\n    function getMaker(uint256 orderId) public view override returns (address maker) {\n        return orders[orderId].maker;\n    }\n\n    /**\n     * @dev Triggers to get highest borrow rate.\n     */\n    function getBorrowRate() public view override returns (uint256 rate) {\n        return borrowOrders.last();\n    }\n\n    /**\n     * @dev Triggers to get highest lend rate.\n     */\n    function getLendRate() public view override returns (uint256 rate) {\n        return lendOrders.last();\n    }\n\n    /**\n     * @dev Triggers to get mid rate.\n     */\n    function getMidRate() public view override returns (uint256 rate) {\n        uint256 borrowRate = getBorrowRate();\n        uint256 lendRate = getLendRate();\n        uint256 combinedRate = borrowRate + lendRate;\n\n        return combinedRate / 2;\n    }\n\n    /**\n     * @dev Triggers to get market order information.\n     * @param orderId Market order id\n     */\n    function getOrder(uint256 orderId) public view override returns (MarketOrder memory) {\n        return orders[orderId];\n    }\n\n    function getOrderFromTree(uint256 orderId)\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        MarketOrder memory marketOrder = orders[orderId];\n\n        if (marketOrder.side == ProtocolTypes.Side.LEND) {\n            return lendOrders.getOrderById(marketOrder.rate, orderId);\n        } else {\n            return borrowOrders.getOrderById(marketOrder.rate, orderId);\n        }\n    }\n\n    /**\n     * @dev Internally triggered to increase and return id of last order in order book.\n     */\n    function _next_id() internal returns (uint256) {\n        last_order_id++;\n        return last_order_id;\n    }\n\n    /**\n     * @dev Triggered to cancel market order.\n     * @param orderId Market order id\n     *\n     * Requirements:\n     * - Order has to be cancelable by market maker\n     */\n    function cancelOrder(uint256 orderId)\n        public\n        override\n        onlyMaker(orderId)\n        returns (bool success)\n    {\n        _beforeMarketOrder();\n\n        MarketOrder memory marketOrder = orders[orderId];\n        if (marketOrder.side == ProtocolTypes.Side.LEND) {\n            lendOrders.remove(marketOrder.amount, marketOrder.rate, orderId);\n        } else if (marketOrder.side == ProtocolTypes.Side.BORROW) {\n            borrowOrders.remove(marketOrder.amount, marketOrder.rate, orderId);\n        }\n        delete orders[orderId];\n\n        collateralAggregator().releaseUnsettledCollateral(\n            marketOrder.maker,\n            MarketCcy,\n            (marketOrder.amount * ProtocolTypes.MKTMAKELEVEL) / ProtocolTypes.PCT\n        );\n        emit CancelOrder(\n            orderId,\n            marketOrder.maker,\n            marketOrder.side,\n            marketOrder.amount,\n            marketOrder.rate\n        );\n\n        success = true;\n    }\n\n    /**\n     * @dev Triggered to make new market order.\n     * @param _side Borrow or Lend order position\n     * @param _amount Amount of funds maker wish to borrow/lend\n     * @param _rate Preferable interest rate\n     */\n    function makeOrder(\n        ProtocolTypes.Side _side,\n        uint256 _amount,\n        uint256 _rate\n    ) internal returns (uint256 orderId) {\n        MarketOrder memory marketOrder;\n\n        require(_amount > 0, \"Can't place empty amount\");\n        require(_rate > 0, \"Can't place empty rate\");\n        _beforeMarketOrder();\n\n        marketOrder.side = _side;\n        marketOrder.amount = _amount;\n        marketOrder.rate = _rate;\n        marketOrder.maker = msg.sender;\n        orderId = _next_id();\n\n        orders[orderId] = marketOrder;\n        collateralAggregator().useUnsettledCollateral(\n            msg.sender,\n            MarketCcy,\n            (_amount * ProtocolTypes.MKTMAKELEVEL) / ProtocolTypes.PCT\n        );\n        if (marketOrder.side == ProtocolTypes.Side.LEND) {\n            lendOrders.insert(marketOrder.amount, marketOrder.rate, orderId);\n        } else if (marketOrder.side == ProtocolTypes.Side.BORROW) {\n            borrowOrders.insert(marketOrder.amount, marketOrder.rate, orderId);\n        }\n\n        emit MakeOrder(\n            orderId,\n            marketOrder.maker,\n            marketOrder.side,\n            MarketCcy,\n            MarketTerm,\n            marketOrder.amount,\n            marketOrder.rate\n        );\n    }\n\n    /**\n     * @dev Triggered to take market order.\n     * @param orderId Market Order id in Order Book\n     * @param _amount Amount of funds taker wish to borrow/lend\n     *\n     * Requirements:\n     * - Market order has to be active\n     */\n    function takeOrder(\n        ProtocolTypes.Side side,\n        uint256 orderId,\n        uint256 _amount\n    ) internal returns (bool) {\n        MarketOrder memory marketOrder = orders[orderId];\n        require(_amount <= marketOrder.amount, \"Insuficient amount\");\n        require(marketOrder.maker != msg.sender, \"Maker couldn't take its order\");\n        _beforeMarketOrder();\n\n        orders[orderId].amount = marketOrder.amount - _amount;\n        if (marketOrder.side == ProtocolTypes.Side.LEND) {\n            require(\n                lendOrders.fillOrder(marketOrder.rate, orderId, _amount),\n                \"Couldn't fill order\"\n            );\n        } else if (marketOrder.side == ProtocolTypes.Side.BORROW) {\n            require(\n                borrowOrders.fillOrder(marketOrder.rate, orderId, _amount),\n                \"Couldn't fill order\"\n            );\n        }\n\n        address productAddress = productAddressResolver().getProductContract(ProductPrefixes.LOAN);\n\n        ILoanV2(productAddress).register(\n            marketOrder.maker,\n            msg.sender,\n            uint8(marketOrder.side),\n            MarketCcy,\n            MarketTerm,\n            _amount,\n            marketOrder.rate\n        );\n\n        emit TakeOrder(orderId, msg.sender, side, _amount, marketOrder.rate);\n\n        if (marketOrder.amount == 0) {\n            delete orders[orderId];\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Triggered to get matching market order.\n     * @param side Market order side it can be borrow or lend\n     * @param amount Amount of funds taker wish to borrow/lend\n     * @param rate Amount of interest rate taker wish to borrow/lend\n     *\n     * Returns zero if didn't find a matched order, reverts if no orders for specified interest rate\n     */\n    function matchOrders(\n        ProtocolTypes.Side side,\n        uint256 amount,\n        uint256 rate\n    ) external view override returns (uint256) {\n        if (side == ProtocolTypes.Side.LEND) {\n            require(borrowOrders.exists(rate), \"No orders exists for selected interest rate\");\n            return borrowOrders.findOrderIdForAmount(rate, amount);\n        } else {\n            require(lendOrders.exists(rate), \"No orders exists for selected interest rate\");\n            return lendOrders.findOrderIdForAmount(rate, amount);\n        }\n    }\n\n    /**\n     * @dev Triggered to execute market order, if order matched it takes order, if not matched places new order.\n     * @param side Market order side it can be borrow or lend\n     * @param amount Amount of funds maker/taker wish to borrow/lend\n     * @param rate Amount of interest rate maker/taker wish to borrow/lend\n     *\n     * Returns true after successful execution\n     */\n    function order(\n        ProtocolTypes.Side side,\n        uint256 amount,\n        uint256 rate\n    ) external override nonReentrant returns (bool) {\n        uint256 orderId;\n\n        if (side == ProtocolTypes.Side.LEND) {\n            orderId = borrowOrders.findOrderIdForAmount(rate, amount);\n            if (orderId != 0) return takeOrder(ProtocolTypes.Side.BORROW, orderId, amount);\n        } else {\n            orderId = lendOrders.findOrderIdForAmount(rate, amount);\n            if (orderId != 0) return takeOrder(ProtocolTypes.Side.LEND, orderId, amount);\n        }\n\n        makeOrder(side, amount, rate);\n        return true;\n    }\n\n    /**\n     * @dev Triggered to pause lending market.\n     */\n    function pauseMarket() public override onlyAcceptedContracts {\n        _pause();\n    }\n\n    /**\n     * @dev Triggered to pause lending market.\n     */\n    function unpauseMarket() public override onlyAcceptedContracts {\n        _unpause();\n    }\n\n    /**\n     * @dev Additional checks before making/taking orders.\n     */\n    function _beforeMarketOrder() internal view {\n        require(!paused(), \"Market paused\");\n    }\n}\n"
    },
    "contracts/interfaces/ILendingMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../types/ProtocolTypes.sol\";\n\ninterface ILendingMarket {\n    struct MarketOrder {\n        ProtocolTypes.Side side;\n        uint256 amount;\n        uint256 rate; // in basis points\n        address maker;\n    }\n\n    event CancelOrder(\n        uint256 orderId,\n        address indexed maker,\n        ProtocolTypes.Side side,\n        uint256 amount,\n        uint256 rate\n    );\n    event MakeOrder(\n        uint256 orderId,\n        address indexed maker,\n        ProtocolTypes.Side side,\n        bytes32 ccy,\n        uint256 term,\n        uint256 amount,\n        uint256 rate\n    );\n    event TakeOrder(\n        uint256 orderId,\n        address indexed taker,\n        ProtocolTypes.Side side,\n        uint256 amount,\n        uint256 rate\n    );\n\n    function cancelOrder(uint256 orderId) external returns (bool success);\n\n    function getBorrowRate() external view returns (uint256 rate);\n\n    function getLendRate() external view returns (uint256 rate);\n\n    function getMaker(uint256 orderId) external view returns (address maker);\n\n    function getMidRate() external view returns (uint256 rate);\n\n    function getOrder(uint256 orderId) external view returns (MarketOrder memory);\n\n    function getOrderFromTree(uint256 orderId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function matchOrders(\n        ProtocolTypes.Side side,\n        uint256 amount,\n        uint256 rate\n    ) external view returns (uint256);\n\n    function order(\n        ProtocolTypes.Side side,\n        uint256 amount,\n        uint256 rate\n    ) external returns (bool);\n\n    function pauseMarket() external;\n\n    function unpauseMarket() external;\n}\n"
    },
    "contracts/storages/LendingMarketControllerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary LendingMarketControllerStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.lendingMarketController\");\n\n    struct Storage {\n        mapping(bytes32 => mapping(uint256 => address)) lendingMarkets;\n        mapping(bytes32 => uint256[]) supportedTerms;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/ILoanV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nstruct LoanDeal {\n    address lender;\n    address borrower;\n    bytes32 ccy;\n    uint256 term;\n    uint256 notional;\n    uint256 rate;\n    uint256 start;\n    uint256 end;\n    uint256 pv;\n    bytes32 startTxHash;\n    uint8 state;\n}\n\ninterface ILoanV2 {\n    event EarlyTermination(bytes32 dealId, address indexed acceptedBy, uint256 payment);\n    event Liquidate(bytes32 dealId);\n    event MarkToMarket(bytes32 dealId, uint256 prevPV, uint256 currPV);\n    event Novation(bytes32 indexed dealId, address currLender);\n    event Register(\n        address indexed lender,\n        address indexed borrower,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate,\n        bytes32 indexed dealId\n    );\n    event RejectTermination(bytes32 dealId, address indexed rejectedBy);\n    event RequestTermination(bytes32 dealId, address indexed requestedBy);\n\n    function acceptTermination(bytes32 loanId) external;\n\n    function addLendingMarket(\n        bytes32 _ccy,\n        uint256 _term,\n        address addr\n    ) external;\n\n    function getDF(bytes32 loanId, uint256 date) external view returns (uint256);\n\n    function getDealPV(bytes32 loanId) external view returns (uint256 pv);\n\n    function getDealLastPV(\n        address party0,\n        address party1,\n        bytes32 loanId\n    ) external view returns (uint256, uint256);\n\n    function getDealSettlementStatus(bytes32 loanId) external view returns (bool);\n\n    function getLastSettledPayment(bytes32 loanId) external view returns (uint256);\n\n    function getLoanDeal(bytes32 loanId) external view returns (LoanDeal memory);\n\n    function getPaymentSchedule(bytes32 loanId)\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            bool[] memory\n        );\n\n    function getVersion() external view returns (uint16);\n\n    function isTransferable() external view returns (bool);\n\n    function last_loan_id() external view returns (uint256);\n\n    function lendingMarkets(bytes32, uint256) external view returns (address);\n\n    function liquidate(bytes32 loanId) external;\n\n    function markToMarket(bytes32 loanId) external returns (bool);\n\n    function novation(bytes32 loanId, address newOwner) external;\n\n    function owner() external view returns (address);\n\n    function register(\n        address maker,\n        address taker,\n        uint8 side,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate\n    ) external returns (bytes32 loanId);\n\n    function rejectTermination(bytes32 loanId) external;\n\n    function requestTermination(bytes32 loanId) external;\n\n    function setIsTransferable(bool isAccepted) external;\n}\n"
    },
    "contracts/libraries/HitchensOrderStatisticsTreeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary HitchensOrderStatisticsTreeLib {\n    uint256 private constant EMPTY = 0;\n\n    struct Node {\n        uint256 parent;\n        uint256 left;\n        uint256 right;\n        bool red;\n        uint256 head;\n        uint256 tail;\n        uint256 orderCounter;\n        mapping(uint256 => OrderItem) orders;\n    }\n\n    struct OrderItem {\n        uint256 orderId;\n        uint256 next;\n        uint256 prev;\n        uint256 timestamp;\n        uint256 amount;\n    }\n\n    struct Tree {\n        uint256 root;\n        mapping(uint256 => Node) nodes;\n    }\n\n    function first(Tree storage self) internal view returns (uint256 _value) {\n        _value = self.root;\n        if (_value == EMPTY) return 0;\n        while (self.nodes[_value].left != EMPTY) {\n            _value = self.nodes[_value].left;\n        }\n    }\n\n    function last(Tree storage self) internal view returns (uint256 _value) {\n        _value = self.root;\n        if (_value == EMPTY) return 0;\n        while (self.nodes[_value].right != EMPTY) {\n            _value = self.nodes[_value].right;\n        }\n    }\n\n    function next(Tree storage self, uint256 value) internal view returns (uint256 _cursor) {\n        require(value != EMPTY, \"OrderStatisticsTree(401) - Starting value cannot be zero\");\n        if (self.nodes[value].right != EMPTY) {\n            _cursor = treeMinimum(self, self.nodes[value].right);\n        } else {\n            _cursor = self.nodes[value].parent;\n            while (_cursor != EMPTY && value == self.nodes[_cursor].right) {\n                value = _cursor;\n                _cursor = self.nodes[_cursor].parent;\n            }\n        }\n    }\n\n    function prev(Tree storage self, uint256 value) internal view returns (uint256 _cursor) {\n        require(value != EMPTY, \"OrderStatisticsTree(402) - Starting value cannot be zero\");\n        if (self.nodes[value].left != EMPTY) {\n            _cursor = treeMaximum(self, self.nodes[value].left);\n        } else {\n            _cursor = self.nodes[value].parent;\n            while (_cursor != EMPTY && value == self.nodes[_cursor].left) {\n                value = _cursor;\n                _cursor = self.nodes[_cursor].parent;\n            }\n        }\n    }\n\n    function exists(Tree storage self, uint256 value) internal view returns (bool _exists) {\n        if (value == EMPTY) return false;\n        if (value == self.root) return true;\n        if (self.nodes[value].parent != EMPTY) return true;\n        return false;\n    }\n\n    function amountExistsInNode(\n        Tree storage self,\n        uint256 amount,\n        uint256 value\n    ) internal view returns (bool) {\n        if (!exists(self, value)) return false;\n        return isAmountExistsInList(self, value, amount);\n    }\n\n    function orderExistsInNode(\n        Tree storage self,\n        uint256 amount,\n        uint256 value,\n        uint256 orderId\n    ) internal view returns (bool) {\n        if (!exists(self, value)) return false;\n        return isOrderIdExists(self, value, amount, orderId);\n    }\n\n    function getNode(Tree storage self, uint256 value)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        require(exists(self, value), \"OrderStatisticsTree(403) - Value does not exist.\");\n        Node storage gn = self.nodes[value];\n        return (gn.parent, gn.left, gn.right, gn.red, gn.head, gn.tail, gn.orderCounter);\n    }\n\n    function getNodeCount(Tree storage self, uint256 value) internal view returns (uint256) {\n        Node storage gn = self.nodes[value];\n        return gn.orderCounter;\n    }\n\n    function count(Tree storage self) internal view returns (uint256 _count) {\n        return getNodeCount(self, self.root);\n    }\n\n    function insert(\n        Tree storage self,\n        uint256 amount,\n        uint256 value,\n        uint256 orderId\n    ) internal {\n        require(value != EMPTY, \"OrderStatisticsTree(405) - Value to insert cannot be zero\");\n        uint256 cursor;\n        uint256 probe = self.root;\n        while (probe != EMPTY) {\n            cursor = probe;\n            if (value < probe) {\n                probe = self.nodes[probe].left;\n            } else if (value > probe) {\n                probe = self.nodes[probe].right;\n            } else if (value == probe) {\n                insertOrder(self, probe, amount, orderId);\n                return;\n            }\n        }\n        Node storage nValue = self.nodes[value];\n        nValue.parent = cursor;\n        nValue.left = EMPTY;\n        nValue.right = EMPTY;\n        nValue.red = true;\n        insertOrder(self, value, amount, orderId);\n        if (cursor == EMPTY) {\n            self.root = value;\n        } else if (value < cursor) {\n            self.nodes[cursor].left = value;\n        } else {\n            self.nodes[cursor].right = value;\n        }\n        insertFixup(self, value);\n    }\n\n    function remove(\n        Tree storage self,\n        uint256 amount,\n        uint256 value,\n        uint256 orderId\n    ) internal {\n        require(value != EMPTY, \"OrderStatisticsTree(407) - Value to delete cannot be zero\");\n        require(\n            orderExistsInNode(self, amount, value, orderId),\n            \"OrderStatisticsTree(408) - Value to delete does not exist.\"\n        );\n        Node storage nValue = self.nodes[value];\n        removeOrder(self, value, orderId);\n        uint256 probe;\n        uint256 cursor;\n        if (nValue.orderCounter == 0) {\n            if (self.nodes[value].left == EMPTY || self.nodes[value].right == EMPTY) {\n                cursor = value;\n            } else {\n                cursor = self.nodes[value].right;\n                while (self.nodes[cursor].left != EMPTY) {\n                    cursor = self.nodes[cursor].left;\n                }\n            }\n            if (self.nodes[cursor].left != EMPTY) {\n                probe = self.nodes[cursor].left;\n            } else {\n                probe = self.nodes[cursor].right;\n            }\n            uint256 cursorParent = self.nodes[cursor].parent;\n            self.nodes[probe].parent = cursorParent;\n            if (cursorParent != EMPTY) {\n                if (cursor == self.nodes[cursorParent].left) {\n                    self.nodes[cursorParent].left = probe;\n                } else {\n                    self.nodes[cursorParent].right = probe;\n                }\n            } else {\n                self.root = probe;\n            }\n            bool doFixup = !self.nodes[cursor].red;\n            if (cursor != value) {\n                replaceParent(self, cursor, value);\n                self.nodes[cursor].left = self.nodes[value].left;\n                self.nodes[self.nodes[cursor].left].parent = cursor;\n                self.nodes[cursor].right = self.nodes[value].right;\n                self.nodes[self.nodes[cursor].right].parent = cursor;\n                self.nodes[cursor].red = self.nodes[value].red;\n                (cursor, value) = (value, cursor);\n            }\n            if (doFixup) {\n                removeFixup(self, probe);\n            }\n            delete self.nodes[cursor];\n        }\n    }\n\n    function treeMinimum(Tree storage self, uint256 value) private view returns (uint256) {\n        while (self.nodes[value].left != EMPTY) {\n            value = self.nodes[value].left;\n        }\n        return value;\n    }\n\n    function treeMaximum(Tree storage self, uint256 value) private view returns (uint256) {\n        while (self.nodes[value].right != EMPTY) {\n            value = self.nodes[value].right;\n        }\n        return value;\n    }\n\n    function rotateLeft(Tree storage self, uint256 value) private {\n        uint256 cursor = self.nodes[value].right;\n        uint256 parent = self.nodes[value].parent;\n        uint256 cursorLeft = self.nodes[cursor].left;\n        self.nodes[value].right = cursorLeft;\n        if (cursorLeft != EMPTY) {\n            self.nodes[cursorLeft].parent = value;\n        }\n        self.nodes[cursor].parent = parent;\n        if (parent == EMPTY) {\n            self.root = cursor;\n        } else if (value == self.nodes[parent].left) {\n            self.nodes[parent].left = cursor;\n        } else {\n            self.nodes[parent].right = cursor;\n        }\n        self.nodes[cursor].left = value;\n        self.nodes[value].parent = cursor;\n    }\n\n    function rotateRight(Tree storage self, uint256 value) private {\n        uint256 cursor = self.nodes[value].left;\n        uint256 parent = self.nodes[value].parent;\n        uint256 cursorRight = self.nodes[cursor].right;\n        self.nodes[value].left = cursorRight;\n        if (cursorRight != EMPTY) {\n            self.nodes[cursorRight].parent = value;\n        }\n        self.nodes[cursor].parent = parent;\n        if (parent == EMPTY) {\n            self.root = cursor;\n        } else if (value == self.nodes[parent].right) {\n            self.nodes[parent].right = cursor;\n        } else {\n            self.nodes[parent].left = cursor;\n        }\n        self.nodes[cursor].right = value;\n        self.nodes[value].parent = cursor;\n    }\n\n    function insertFixup(Tree storage self, uint256 value) private {\n        uint256 cursor;\n        while (value != self.root && self.nodes[self.nodes[value].parent].red) {\n            uint256 valueParent = self.nodes[value].parent;\n            if (valueParent == self.nodes[self.nodes[valueParent].parent].left) {\n                cursor = self.nodes[self.nodes[valueParent].parent].right;\n                if (self.nodes[cursor].red) {\n                    self.nodes[valueParent].red = false;\n                    self.nodes[cursor].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    value = self.nodes[valueParent].parent;\n                } else {\n                    if (value == self.nodes[valueParent].right) {\n                        value = valueParent;\n                        rotateLeft(self, value);\n                    }\n                    valueParent = self.nodes[value].parent;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    rotateRight(self, self.nodes[valueParent].parent);\n                }\n            } else {\n                cursor = self.nodes[self.nodes[valueParent].parent].left;\n                if (self.nodes[cursor].red) {\n                    self.nodes[valueParent].red = false;\n                    self.nodes[cursor].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    value = self.nodes[valueParent].parent;\n                } else {\n                    if (value == self.nodes[valueParent].left) {\n                        value = valueParent;\n                        rotateRight(self, value);\n                    }\n                    valueParent = self.nodes[value].parent;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    rotateLeft(self, self.nodes[valueParent].parent);\n                }\n            }\n        }\n        self.nodes[self.root].red = false;\n    }\n\n    function replaceParent(\n        Tree storage self,\n        uint256 a,\n        uint256 b\n    ) private {\n        uint256 bParent = self.nodes[b].parent;\n        self.nodes[a].parent = bParent;\n        if (bParent == EMPTY) {\n            self.root = a;\n        } else {\n            if (b == self.nodes[bParent].left) {\n                self.nodes[bParent].left = a;\n            } else {\n                self.nodes[bParent].right = a;\n            }\n        }\n    }\n\n    function removeFixup(Tree storage self, uint256 value) private {\n        uint256 cursor;\n        while (value != self.root && !self.nodes[value].red) {\n            uint256 valueParent = self.nodes[value].parent;\n            if (value == self.nodes[valueParent].left) {\n                cursor = self.nodes[valueParent].right;\n                if (self.nodes[cursor].red) {\n                    self.nodes[cursor].red = false;\n                    self.nodes[valueParent].red = true;\n                    rotateLeft(self, valueParent);\n                    cursor = self.nodes[valueParent].right;\n                }\n                if (\n                    !self.nodes[self.nodes[cursor].left].red &&\n                    !self.nodes[self.nodes[cursor].right].red\n                ) {\n                    self.nodes[cursor].red = true;\n                    value = valueParent;\n                } else {\n                    if (!self.nodes[self.nodes[cursor].right].red) {\n                        self.nodes[self.nodes[cursor].left].red = false;\n                        self.nodes[cursor].red = true;\n                        rotateRight(self, cursor);\n                        cursor = self.nodes[valueParent].right;\n                    }\n                    self.nodes[cursor].red = self.nodes[valueParent].red;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[cursor].right].red = false;\n                    rotateLeft(self, valueParent);\n                    value = self.root;\n                }\n            } else {\n                cursor = self.nodes[valueParent].left;\n                if (self.nodes[cursor].red) {\n                    self.nodes[cursor].red = false;\n                    self.nodes[valueParent].red = true;\n                    rotateRight(self, valueParent);\n                    cursor = self.nodes[valueParent].left;\n                }\n                if (\n                    !self.nodes[self.nodes[cursor].right].red &&\n                    !self.nodes[self.nodes[cursor].left].red\n                ) {\n                    self.nodes[cursor].red = true;\n                    value = valueParent;\n                } else {\n                    if (!self.nodes[self.nodes[cursor].left].red) {\n                        self.nodes[self.nodes[cursor].right].red = false;\n                        self.nodes[cursor].red = true;\n                        rotateLeft(self, cursor);\n                        cursor = self.nodes[valueParent].left;\n                    }\n                    self.nodes[cursor].red = self.nodes[valueParent].red;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[cursor].left].red = false;\n                    rotateRight(self, valueParent);\n                    value = self.root;\n                }\n            }\n        }\n        self.nodes[value].red = false;\n    }\n\n    // Double linked list functions\n    /**\n     * @dev Retrieves the Object denoted by `_id`.\n     */\n    function getOrderById(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        require(exists(self, value), \"OrderStatisticsTree(403) - Value does not exist.\");\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[orderId];\n        return (order.orderId, order.next, order.prev, order.timestamp, order.amount);\n    }\n\n    /**\n     * @dev Return boolean if value, amount and orderId exist in doubly linked list\n     */\n    function isOrderIdExists(\n        Tree storage self,\n        uint256 value,\n        uint256 amount,\n        uint256 orderId\n    ) internal view returns (bool) {\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[orderId];\n        if (order.amount != amount) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Return boolean if value and amount exist in doubly linked list.\n     */\n    function isAmountExistsInList(\n        Tree storage self,\n        uint256 value,\n        uint256 amount\n    ) internal view returns (bool) {\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[gn.head];\n        while (order.next != 0 && order.amount < amount) {\n            order = gn.orders[order.next];\n        }\n        if (order.amount == 0) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Return the id of the first OrderItem matching `_amount` in the amount field.\n     */\n    function findOrderIdForAmount(\n        Tree storage self,\n        uint256 value,\n        uint256 amount\n    ) internal view returns (uint256) {\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[gn.head];\n        while (order.orderId != gn.tail && order.amount < amount) {\n            order = gn.orders[order.next];\n        }\n        if (order.amount >= amount) {\n            return order.orderId;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @dev Reduces order amount once market order taken.\n     */\n    function fillOrder(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId,\n        uint256 _amount\n    ) internal returns (bool) {\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[orderId];\n        uint256 newAmount = order.amount - _amount;\n        gn.orders[orderId].amount = newAmount;\n\n        if (gn.orders[orderId].amount == 0) {\n            remove(self, newAmount, value, orderId);\n        } else {\n            if (gn.orders[gn.head].amount < newAmount) {\n                OrderItem memory rootOrder = gn.orders[gn.head];\n                while (rootOrder.orderId != gn.tail && rootOrder.amount < newAmount) {\n                    rootOrder = gn.orders[rootOrder.next];\n                }\n                if (order.amount > _amount) {\n                    OrderItem memory prevOrder = gn.orders[rootOrder.prev];\n                    _link(self, value, order.orderId, rootOrder.orderId);\n                    _link(self, value, prevOrder.orderId, order.orderId);\n                } else {\n                    OrderItem memory nextOrder = gn.orders[rootOrder.next];\n                    _link(self, value, order.orderId, nextOrder.orderId);\n                    _link(self, value, rootOrder.orderId, order.orderId);\n                }\n            } else {\n                _link(self, value, order.orderId, gn.head);\n                _setHead(self, value, order.orderId);\n                if (gn.tail == 0) _setTail(self, value, order.orderId);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Up size order by market maker.\n     */\n    function upSizeOrder(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId,\n        uint256 _amount\n    ) internal returns (bool) {\n        require(_amount > 0, \"Couldn't up size order with 0\");\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[orderId];\n        uint256 newAmount = order.amount + _amount;\n        gn.orders[orderId].amount = newAmount;\n\n        if (gn.orders[gn.head].amount < newAmount) {\n            OrderItem memory rootOrder = gn.orders[gn.head];\n            while (rootOrder.orderId != gn.tail && rootOrder.amount < newAmount) {\n                rootOrder = gn.orders[rootOrder.next];\n            }\n            if (order.amount > _amount) {\n                OrderItem memory prevOrder = gn.orders[rootOrder.prev];\n                _link(self, value, order.orderId, rootOrder.orderId);\n                _link(self, value, prevOrder.orderId, order.orderId);\n            } else {\n                OrderItem memory nextOrder = gn.orders[rootOrder.next];\n                _link(self, value, order.orderId, nextOrder.orderId);\n                _link(self, value, rootOrder.orderId, order.orderId);\n            }\n        } else {\n            _link(self, value, order.orderId, gn.head);\n            _setHead(self, value, order.orderId);\n            if (gn.tail == 0) _setTail(self, value, order.orderId);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Insert a new OrderItem as the new Head with `_amount` in the amount field, and orderId.\n     */\n    function addHead(\n        Tree storage self,\n        uint256 value,\n        uint256 _amount,\n        uint256 _orderId\n    ) internal {\n        Node storage gn = self.nodes[value];\n        uint256 orderId = _createOrder(self, value, _amount, _orderId);\n        _link(self, value, orderId, gn.head);\n        _setHead(self, value, orderId);\n        if (gn.tail == 0) _setTail(self, value, orderId);\n    }\n\n    /**\n     * @dev Insert a new OrderItem as the new Tail with `_amount` in the amount field, and orderId.\n     */\n    function addTail(\n        Tree storage self,\n        uint256 value,\n        uint256 _amount,\n        uint256 _orderId\n    ) internal {\n        Node storage gn = self.nodes[value];\n\n        if (gn.head == 0) {\n            addHead(self, value, _amount, _orderId);\n        } else {\n            uint256 orderId = _createOrder(self, value, _amount, _orderId);\n            _link(self, value, gn.tail, orderId);\n            _setTail(self, value, orderId);\n        }\n    }\n\n    /**\n     * @dev Remove the OrderItem denoted by `_id` from the List.\n     */\n    function removeOrder(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId\n    ) internal {\n        require(exists(self, value), \"OrderStatisticsTree(403) - Value does not exist.\");\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[orderId];\n        if (gn.head == orderId && gn.tail == orderId) {\n            _setHead(self, value, 0);\n            _setTail(self, value, 0);\n        } else if (gn.head == orderId) {\n            _setHead(self, value, order.next);\n            gn.orders[order.next].prev = 0;\n        } else if (gn.tail == orderId) {\n            _setTail(self, value, order.prev);\n            gn.orders[order.prev].next = 0;\n        } else {\n            _link(self, value, order.prev, order.next);\n        }\n        delete gn.orders[order.orderId];\n        gn.orderCounter -= 1;\n    }\n\n    /**\n     * @dev Insert a new OrderItem after the last OrderItem with the same `_amount`.\n     */\n    function insertOrder(\n        Tree storage self,\n        uint256 value,\n        uint256 _amount,\n        uint256 _orderId\n    ) internal {\n        require(_amount > 0, \"Insuficient amount\");\n\n        Node storage gn = self.nodes[value];\n        if (gn.head == 0) {\n            addHead(self, value, _amount, _orderId);\n        } else {\n            if (gn.orders[gn.head].amount < _amount) {\n                OrderItem memory order = gn.orders[gn.head];\n                while (order.next != 0 && order.amount <= _amount) {\n                    order = gn.orders[order.next];\n                }\n                if (order.amount > _amount) {\n                    insertOrderBefore(self, value, order.orderId, _amount, _orderId);\n                } else {\n                    insertOrderAfter(self, value, order.orderId, _amount, _orderId);\n                }\n            } else {\n                addHead(self, value, _amount, _orderId);\n            }\n        }\n    }\n\n    /**\n     * @dev Insert a new OrderImer after the Order denoted by `_id` with `_amount` and `_orderId` in the amount field.\n     */\n    function insertOrderAfter(\n        Tree storage self,\n        uint256 value,\n        uint256 _prevId,\n        uint256 _amount,\n        uint256 _orderId\n    ) internal {\n        require(_amount > 0, \"Insuficient amount\");\n\n        Node storage gn = self.nodes[value];\n\n        if (_prevId == gn.tail) {\n            addTail(self, value, _amount, _orderId);\n        } else {\n            OrderItem memory prevOrder = gn.orders[_prevId];\n            OrderItem memory nextOrder = gn.orders[prevOrder.next];\n            uint256 newOrderId = _createOrder(self, value, _amount, _orderId);\n            _link(self, value, newOrderId, nextOrder.orderId);\n            _link(self, value, prevOrder.orderId, newOrderId);\n        }\n    }\n\n    /**\n     * @dev Insert a new Object before the Object denoted by `_id` with `_amount` and `_orderId` in the data field.\n     */\n    function insertOrderBefore(\n        Tree storage self,\n        uint256 value,\n        uint256 _nextId,\n        uint256 _amount,\n        uint256 _orderId\n    ) internal {\n        Node storage gn = self.nodes[value];\n\n        if (_nextId == gn.head) {\n            addHead(self, value, _amount, _orderId);\n        } else {\n            insertOrderAfter(self, value, gn.orders[_nextId].prev, _amount, _orderId);\n        }\n    }\n\n    /**\n     * @dev Internal function to update the Head pointer.\n     */\n    function _setHead(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId\n    ) internal {\n        Node storage gn = self.nodes[value];\n\n        gn.head = orderId;\n    }\n\n    /**\n     * @dev Internal function to update the Tail pointer.\n     */\n    function _setTail(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId\n    ) internal {\n        Node storage gn = self.nodes[value];\n\n        gn.tail = orderId;\n    }\n\n    /**\n     * @dev Internal function to create an unlinked Order.\n     */\n    function _createOrder(\n        Tree storage self,\n        uint256 value,\n        uint256 amount,\n        uint256 orderId\n    ) internal returns (uint256) {\n        Node storage gn = self.nodes[value];\n        uint256 newId;\n        if (gn.orderCounter == 0) {\n            newId = 1;\n        }\n        gn.orderCounter += 1;\n        OrderItem memory order = OrderItem(orderId, 0, 0, block.timestamp, amount);\n        gn.orders[order.orderId] = order;\n        return order.orderId;\n    }\n\n    /**\n     * @dev Internal function to link an Object to another.\n     */\n    function _link(\n        Tree storage self,\n        uint256 value,\n        uint256 _prevId,\n        uint256 _nextId\n    ) internal {\n        Node storage gn = self.nodes[value];\n\n        gn.orders[_prevId].next = _nextId;\n        gn.orders[_nextId].prev = _prevId;\n    }\n}\n"
    },
    "contracts/libraries/HitchensOrderStatisticsTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./HitchensOrderStatisticsTreeLib.sol\";\n\ncontract HitchensOrderStatisticsTree {\n    using HitchensOrderStatisticsTreeLib for HitchensOrderStatisticsTreeLib.Tree;\n\n    HitchensOrderStatisticsTreeLib.Tree tree;\n\n    event InsertOrder(string action, uint256 amount, uint256 value, uint256 orderId);\n    event RemoveOrder(string action, uint256 amount, uint256 value, uint256 _id);\n\n    constructor() {}\n\n    function treeRootNode() public view returns (uint256 _value) {\n        _value = tree.root;\n    }\n\n    function firstValue() public view returns (uint256 _value) {\n        _value = tree.first();\n    }\n\n    function lastValue() public view returns (uint256 _value) {\n        _value = tree.last();\n    }\n\n    function nextValue(uint256 value) public view returns (uint256 _value) {\n        _value = tree.next(value);\n    }\n\n    function prevValue(uint256 value) public view returns (uint256 _value) {\n        _value = tree.prev(value);\n    }\n\n    function valueExists(uint256 value) public view returns (bool _exists) {\n        _exists = tree.exists(value);\n    }\n\n    function amountValueExists(uint256 amount, uint256 value) public view returns (bool _exists) {\n        _exists = tree.amountExistsInNode(amount, value);\n    }\n\n    function getNode(uint256 value)\n        public\n        view\n        returns (\n            uint256 _parent,\n            uint256 _left,\n            uint256 _right,\n            bool _red,\n            uint256 _head,\n            uint256 _tail,\n            uint256 _orderCounter\n        )\n    {\n        (_parent, _left, _right, _red, _head, _tail, _orderCounter) = tree.getNode(value);\n    }\n\n    function getOrderByID(uint256 value, uint256 id)\n        public\n        view\n        returns (\n            uint256 _orderId,\n            uint256 _next,\n            uint256 _prev,\n            uint256 _timestamp,\n            uint256 _amount\n        )\n    {\n        (_orderId, _next, _prev, _timestamp, _amount) = tree.getOrderById(value, id);\n    }\n\n    function getRootCount() public view returns (uint256 _orderCounter) {\n        _orderCounter = tree.count();\n    }\n\n    function getValueCount(uint256 value) public view returns (uint256 _orderCounter) {\n        _orderCounter = tree.getNodeCount(value);\n    }\n\n    function insertAmountValue(\n        uint256 amount,\n        uint256 value,\n        uint256 orderId\n    ) public {\n        emit InsertOrder(\"insert\", amount, value, orderId);\n        tree.insert(amount, value, orderId);\n    }\n\n    function removeAmountValue(\n        uint256 amount,\n        uint256 value,\n        uint256 orderId\n    ) public {\n        emit RemoveOrder(\"delete\", amount, value, orderId);\n        tree.remove(amount, value, orderId);\n    }\n}\n"
    },
    "contracts/mocks/LoanCallerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../interfaces/ILoanV2.sol\";\n\ncontract LoanCallerMock {\n    ILoanV2 public loan;\n\n    constructor(address _loan) {\n        loan = ILoanV2(_loan);\n    }\n\n    function register(\n        address maker,\n        address taker,\n        uint8 side,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate\n    ) public returns (bytes32 loanId) {\n        return loan.register(maker, taker, side, ccy, term, notional, rate);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/mocks/WETH9Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../interfaces/IWETH9.sol\";\n\ncontract WETH9Mock is IWETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable override {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public override {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public override returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public override returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public override returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max - 1) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/CollateralVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./interfaces/ICollateralVault.sol\";\nimport \"./libraries/SafeTransfer.sol\";\nimport \"./libraries/CollateralPosition.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\nimport \"./utils/Ownable.sol\";\nimport \"./utils/Proxyable.sol\";\nimport {CollateralVaultStorage as Storage} from \"./storages/CollateralVaultStorage.sol\";\n\n/**\n * @title CollateralVault is the main implementation contract for storing and keeping user's collateral\n *\n * This contract allows users to deposit and withdraw their funds to fulfill\n * their collateral obligations against different trades.\n *\n * CollateralVault is working with ETH or ERC20 token with specified on deployment `tokenAddress`.\n *\n * CollateralAggregator uses independent Collateral vaults for rebalancing collateral\n * between global books and bilateral positions, and liquidating collateral while performing\n * single or multi-deal liquidation.\n *\n */\ncontract CollateralVault is\n    ICollateralVault,\n    MixinAddressResolver,\n    Ownable,\n    SafeTransfer,\n    Proxyable\n{\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /**\n     * @dev Modifier to check if user registered on collateral aggregator\n     */\n    modifier onlyRegisteredUser() {\n        require(collateralAggregator().checkRegisteredUser(msg.sender), \"User not registered\");\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(\n        address owner,\n        address resolver,\n        address WETH9\n    ) public initializer onlyProxy {\n        _transferOwnership(owner);\n        _registerToken(WETH9);\n        registerAddressResolver(resolver);\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](2);\n        contracts[0] = Contracts.COLLATERAL_AGGREGATOR;\n        contracts[1] = Contracts.CURRENCY_CONTROLLER;\n    }\n\n    function acceptedContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](1);\n        contracts[0] = Contracts.COLLATERAL_AGGREGATOR;\n    }\n\n    function registerCurrency(bytes32 _ccy, address _tokenAddress) external onlyOwner {\n        require(currencyController().isCollateral(_ccy), \"Invalid currency\");\n        Storage.slot().tokenAddresses[_ccy] = _tokenAddress;\n    }\n\n    /**\n     * @dev Deposit funds by the msg.sender into collateral book\n     * @param _amount Number of funds to deposit\n     * @param _ccy Specified currency\n     */\n    function deposit(bytes32 _ccy, uint256 _amount) public payable override onlyRegisteredUser {\n        require(Storage.slot().tokenAddresses[_ccy] != address(0), \"Invalid currency\");\n        require(_amount > 0, \"Invalid amount\");\n        _depositAssets(Storage.slot().tokenAddresses[_ccy], msg.sender, address(this), _amount);\n\n        Storage.Book storage book = Storage.slot().books[msg.sender][_ccy];\n        book.independentAmount = book.independentAmount + _amount;\n\n        _updateUsedCurrencies(_ccy);\n\n        emit Deposit(msg.sender, _ccy, _amount);\n    }\n\n    /**\n     * @dev Deposit collateral funds into bilateral position against counterparty\n     * @param _counterparty Counterparty address in bilateral position\n     * @param _ccy Specified currency\n     * @param _amount Number of funds to deposit\n     *\n     * @notice payable function increases locked collateral by msg.value\n     */\n    function deposit(\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _amount\n    ) public override onlyRegisteredUser {\n        require(Storage.slot().tokenAddresses[_ccy] != address(0), \"Invalid currency\");\n        require(_amount > 0, \"Invalid amount\");\n        _depositAssets(Storage.slot().tokenAddresses[_ccy], msg.sender, address(this), _amount);\n\n        CollateralPosition.deposit(\n            Storage.slot().positions[_ccy],\n            msg.sender,\n            _counterparty,\n            _amount\n        );\n\n        Storage.Book storage book = Storage.slot().books[msg.sender][_ccy];\n        book.lockedCollateral = book.lockedCollateral + _amount;\n\n        _updateUsedCurrenciesInPosition(msg.sender, _counterparty, _ccy);\n\n        emit PositionDeposit(msg.sender, _counterparty, _ccy, _amount);\n    }\n\n    /**\n     * @dev Rebalances collateral between user's book and bilateral position\n     *\n     * @param _party0 First counterparty address\n     * @param _party1 Second counterparty address.\n     * @param _rebalanceTarget Amount of funds in ETH required to rebalance\n     * @param isRebalanceFrom Boolean for whether collateral is rebalanced from a bilateral position or to a bilateral position\n     *\n     * @return Amount of funds in ETH left to rebalance for other vault\n     */\n    function rebalanceCollateral(\n        address _party0,\n        address _party1,\n        uint256 _rebalanceTarget,\n        bool isRebalanceFrom\n    ) external onlyAcceptedContracts returns (bool) {\n        EnumerableSet.Bytes32Set storage currencies = Storage.slot().usedCurrencies[_party0];\n        uint256 len = currencies.length();\n        uint256 i = 0;\n\n        while (_rebalanceTarget != 0 && i < len) {\n            bytes32 ccy = currencies.at(i);\n\n            if (isRebalanceFrom) {\n                _rebalanceTarget = _rebalanceFrom(_party0, _party1, ccy, _rebalanceTarget);\n            } else {\n                _rebalanceTarget = _rebalanceTo(_party0, _party1, ccy, _rebalanceTarget);\n            }\n\n            i += 1;\n        }\n\n        if (_rebalanceTarget > 0) return false;\n\n        return true;\n    }\n\n    struct RebalanceLocalVars {\n        int256 exchangeRate;\n        uint256 target;\n        uint256 rebalanceAmount;\n        uint256 left;\n    }\n\n    /**\n     * @dev Rebalances collateral between 2 different bilateral positions,\n     * as it's executed by collateral aggregator function returns the\n     * amount of ETH left to rebalance for other collateral vaults\n     *\n     * @param _user Main user address to rebalance collateral from\n     * @param _fromParty Counterparty address to rebalance from\n     * @param _toParty Counterparty address to rebalance to\n     * @param _ccy Specified currency\n     * @param _amountETH Amount of funds in ETH required to rebalance\n     *\n     * @return Amount of funds in ETH left to rebalance for other vault\n     */\n    function rebalanceBetween(\n        address _user,\n        address _fromParty,\n        address _toParty,\n        bytes32 _ccy,\n        uint256 _amountETH\n    ) external override onlyAcceptedContracts returns (uint256) {\n        RebalanceLocalVars memory vars;\n\n        vars.exchangeRate = currencyController().getLastETHPrice(_ccy);\n        vars.target = (_amountETH * 1e18) / uint256(vars.exchangeRate);\n        vars.rebalanceAmount = CollateralPosition.rebalance(\n            Storage.slot().positions[_ccy],\n            _user,\n            _fromParty,\n            _toParty,\n            vars.target\n        );\n        vars.left = vars.target - vars.rebalanceAmount;\n\n        _updateUsedCurrenciesInPosition(_user, _fromParty, _ccy);\n        _updateUsedCurrenciesInPosition(_user, _toParty, _ccy);\n\n        emit RebalanceBetween(_user, _fromParty, _toParty, _ccy, vars.rebalanceAmount);\n\n        return (vars.left * uint256(vars.exchangeRate)) / 1e18;\n    }\n\n    /**\n     * @dev Liquidates collateral from bilateral position between parties\n     * returns the amount of ETH to be liquidated in other vault\n     * if all available funds have been liquidated here\n     *\n     * @param _from Address for liquidating collateral from\n     * @param _to Address for sending collateral to\n     * @param _liquidationTarget Liquidation amount in ETH\n     *\n     * @notice Triggers only be Loan contract\n     */\n    function liquidate(\n        address _from,\n        address _to,\n        uint256 _liquidationTarget\n    ) external onlyAcceptedContracts returns (bool) {\n        EnumerableSet.Bytes32Set storage currencies = Storage.slot().usedCurrencies[_from];\n        uint256 len = currencies.length();\n        uint256 i = 0;\n\n        while (_liquidationTarget != 0 && i < len) {\n            bytes32 ccy = currencies.at(i);\n            _liquidationTarget = _liquidate(_from, _to, ccy, _liquidationTarget);\n\n            i += 1;\n        }\n\n        if (_liquidationTarget > 0) return false;\n\n        return true;\n    }\n\n    /**\n     * @notice Triggers to withdraw funds by the msg.sender from non-locked funds\n     * @param _ccy Specified currency\n     * @param _amount Number of funds to withdraw.\n     */\n    function withdraw(bytes32 _ccy, uint256 _amount) public override onlyRegisteredUser {\n        // fix according to collateral aggregator\n        require(_amount > 0, \"INVALID_AMOUNT\");\n\n        address user = msg.sender;\n        uint256 maxWidthdrawETH = collateralAggregator().getMaxCollateralBookWidthdraw(user);\n        uint256 maxWidthdraw = currencyController().convertFromETH(_ccy, maxWidthdrawETH);\n        uint256 withdrawAmt = _amount > maxWidthdraw ? maxWidthdraw : _amount;\n\n        Storage.Book storage book = Storage.slot().books[user][_ccy];\n        book.independentAmount = book.independentAmount - withdrawAmt;\n\n        _withdrawAssets(Storage.slot().tokenAddresses[_ccy], msg.sender, withdrawAmt);\n        _updateUsedCurrencies(_ccy);\n\n        emit Withdraw(msg.sender, _ccy, withdrawAmt);\n    }\n\n    /**\n     * @notice Triggers to withdraw funds from bilateral position between\n     * msg.sender and _counterparty\n     *\n     * @param _counterparty Counterparty address.\n     * @param _ccy Specified currency\n     * @param _amount Number of funds to withdraw.\n     */\n    function withdrawFrom(\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _amount\n    ) public override onlyRegisteredUser {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        address user = msg.sender;\n\n        (uint256 maxWidthdrawETH, ) = collateralAggregator().getMaxCollateralWidthdraw(\n            user,\n            _counterparty\n        );\n        uint256 maxWidthdraw = currencyController().convertFromETH(_ccy, maxWidthdrawETH);\n\n        uint256 targetWithdraw = _amount > maxWidthdraw ? maxWidthdraw : _amount;\n        uint256 withdrawn = CollateralPosition.withdraw(\n            Storage.slot().positions[_ccy],\n            user,\n            _counterparty,\n            targetWithdraw\n        );\n\n        Storage.Book storage book = Storage.slot().books[user][_ccy];\n        book.lockedCollateral = book.lockedCollateral - withdrawn;\n\n        _withdrawAssets(Storage.slot().tokenAddresses[_ccy], msg.sender, withdrawn);\n        _updateUsedCurrenciesInPosition(msg.sender, _counterparty, _ccy);\n\n        emit PositionWithdraw(user, _counterparty, _ccy, withdrawn);\n    }\n\n    /**\n     * @notice Returns independent collateral from `_user` collateral book\n     *\n     * @param _user Address of collateral user\n     * @param _ccy Specified currency\n     */\n    function getIndependentCollateral(address _user, bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return Storage.slot().books[_user][_ccy].independentAmount;\n    }\n\n    /**\n     * @notice Returns independent collateral from `_user` collateral book converted to ETH\n     *\n     * @param _user Address of collateral user\n     * @param _ccy Specified currency\n     */\n    function getIndependentCollateralInETH(address _user, bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 amount = getIndependentCollateral(_user, _ccy);\n        return currencyController().convertToETH(_ccy, amount);\n    }\n\n    /**\n     * @notice Returns independent collateral from `_user` collateral book converted to ETH\n     *\n     * @param _user Address of collateral user\n     */\n    function getTotalIndependentCollateralInETH(address _user)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        EnumerableSet.Bytes32Set storage currencies = Storage.slot().usedCurrencies[_user];\n        uint256 lockedCollateral;\n        uint256 totalCollateral;\n\n        uint256 len = currencies.length();\n\n        for (uint256 i = 0; i < len; i++) {\n            bytes32 ccy = currencies.at(i);\n            lockedCollateral = getIndependentCollateralInETH(_user, ccy);\n            totalCollateral = totalCollateral + lockedCollateral;\n        }\n\n        return totalCollateral;\n    }\n\n    /**\n     * @notice Returns locked collateral by `_user` in collateral book\n     *\n     * @param _user Address of collateral user\n     * @param _ccy Specified currency\n     */\n    function getLockedCollateral(address _user, bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return Storage.slot().books[_user][_ccy].lockedCollateral;\n    }\n\n    /**\n     * @notice Returns locked collateral by `_user` in collateral book converted to ETH\n     *\n     * @param _user Address of collateral user\n     * @param _ccy Specified currency\n     */\n    function getLockedCollateralInETH(address _user, bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 amount = getLockedCollateral(_user, _ccy);\n        return currencyController().convertToETH(_ccy, amount);\n    }\n\n    /**\n     * @notice Returns locked collateral for a particular currency by counterparties\n     * in a bilateral position in native `ccy`\n     *\n     * @param _party0 First counterparty address\n     * @param _party1 Second counterparty address.\n     * @param _ccy Specified currency\n     */\n    function getLockedCollateral(\n        address _party0,\n        address _party1,\n        bytes32 _ccy\n    ) public view override returns (uint256, uint256) {\n        return CollateralPosition.get(Storage.slot().positions[_ccy], _party0, _party1);\n    }\n\n    /**\n     * @notice Returns locked collateral for a particular currency by counterparties\n     * in a bilateral position converted to ETH\n     *\n     * @param _party0 First counterparty address\n     * @param _party1 Second counterparty address.\n     * @param _ccy Specified currency\n     */\n    function getLockedCollateralInETH(\n        address _party0,\n        address _party1,\n        bytes32 _ccy\n    ) public view override returns (uint256, uint256) {\n        (uint256 lockedA, uint256 lockedB) = getLockedCollateral(_party0, _party1, _ccy);\n\n        uint256[] memory ethAmounts = new uint256[](2);\n        ethAmounts[0] = lockedA;\n        ethAmounts[1] = lockedB;\n\n        ethAmounts = currencyController().convertBulkToETH(_ccy, ethAmounts);\n\n        return (ethAmounts[0], ethAmounts[1]);\n    }\n\n    struct TotalLockedCollateralLocalVars {\n        uint256 len;\n        uint256 lockedCollateral0;\n        uint256 lockedCollateral1;\n        uint256 totalCollateral0;\n        uint256 totalCollateral1;\n    }\n\n    /**\n     * @notice Returns locked collateral by counterparties in a bilateral position converted to ETH\n     *\n     * @param _party0 First counterparty address\n     * @param _party1 Second counterparty address.\n     */\n    function getTotalLockedCollateralInETH(address _party0, address _party1)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(_party0, _party1);\n        EnumerableSet.Bytes32Set storage currencies = Storage.slot().usedCurrenciesInPosition[\n            packedAddrs\n        ];\n\n        TotalLockedCollateralLocalVars memory vars;\n        vars.len = currencies.length();\n\n        for (uint256 i = 0; i < vars.len; i++) {\n            bytes32 ccy = currencies.at(i);\n\n            (vars.lockedCollateral0, vars.lockedCollateral1) = getLockedCollateralInETH(\n                _party0,\n                _party1,\n                ccy\n            );\n\n            vars.totalCollateral0 = vars.totalCollateral0 + vars.lockedCollateral0;\n            vars.totalCollateral1 = vars.totalCollateral1 + vars.lockedCollateral1;\n        }\n\n        return (vars.totalCollateral0, vars.totalCollateral1);\n    }\n\n    function getUsedCurrencies(address _party0, address _party1)\n        public\n        view\n        override\n        returns (bytes32[] memory)\n    {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(_party0, _party1);\n        EnumerableSet.Bytes32Set storage currencySet = Storage.slot().usedCurrenciesInPosition[\n            packedAddrs\n        ];\n\n        uint256 numCurrencies = currencySet.length();\n        bytes32[] memory currencies = new bytes32[](numCurrencies);\n\n        for (uint256 i = 0; i < numCurrencies; i++) {\n            bytes32 currency = currencySet.at(i);\n            currencies[i] = currency;\n        }\n\n        return currencies;\n    }\n\n    function getUsedCurrencies(address user) public view override returns (bytes32[] memory) {\n        EnumerableSet.Bytes32Set storage currencySet = Storage.slot().usedCurrencies[user];\n\n        uint256 numCurrencies = currencySet.length();\n        bytes32[] memory currencies = new bytes32[](numCurrencies);\n\n        for (uint256 i = 0; i < numCurrencies; i++) {\n            bytes32 currency = currencySet.at(i);\n            currencies[i] = currency;\n        }\n\n        return currencies;\n    }\n\n    /**\n     * @dev Rebalances collateral from user's book to bilateral position,\n     * as it's executed by collateral aggregator function returns the\n     * amount of ETH left to rebalance for other collateral vaults\n     *\n     * @param _user Main user address to rebalance collateral from\n     * @param _counterparty Counterparty address in bilateral position\n     * @param _ccy Specified currency\n     * @param _amountETH Amount of funds in ETH required to rebalance\n     *\n     * @return Amount of funds in ETH left to rebalance for other vault\n     */\n    function _rebalanceTo(\n        address _user,\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _amountETH\n    ) internal returns (uint256) {\n        RebalanceLocalVars memory vars;\n        vars.exchangeRate = currencyController().getLastETHPrice(_ccy);\n        vars.target = (_amountETH * 1e18) / uint256(vars.exchangeRate);\n\n        Storage.Book storage book = Storage.slot().books[_user][_ccy];\n        vars.rebalanceAmount = book.independentAmount >= vars.target\n            ? vars.target\n            : book.independentAmount;\n\n        if (vars.rebalanceAmount > 0) {\n            book.independentAmount = book.independentAmount - vars.rebalanceAmount;\n            book.lockedCollateral = book.lockedCollateral + vars.rebalanceAmount;\n\n            CollateralPosition.deposit(\n                Storage.slot().positions[_ccy],\n                _user,\n                _counterparty,\n                vars.rebalanceAmount\n            );\n            _updateUsedCurrenciesInPosition(_user, _counterparty, _ccy);\n\n            emit RebalanceTo(_user, _counterparty, _ccy, vars.rebalanceAmount);\n        }\n\n        vars.left = vars.target - vars.rebalanceAmount;\n\n        return (vars.left * uint256(vars.exchangeRate)) / 1e18;\n    }\n\n    /**\n     * @dev Rebalances collateral from bilateral position to user's book,\n     * as it's executed by collateral aggregator function returns the\n     * amount of ETH left to rebalance for other collateral vaults\n     *\n     * @param _user Main user address to rebalance collateral from\n     * @param _counterparty Counterparty address in bilateral position\n     * @param _ccy Specified currency\n     * @param _amountETH Amount of funds in ETH required to rebalance\n     *\n     * @return Amount of funds in ETH left to rebalance for other vault\n     */\n    function _rebalanceFrom(\n        address _user,\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _amountETH\n    ) internal returns (uint256) {\n        RebalanceLocalVars memory vars;\n        vars.exchangeRate = currencyController().getLastETHPrice(_ccy);\n        vars.target = (_amountETH * 1e18) / uint256(vars.exchangeRate);\n\n        vars.rebalanceAmount = CollateralPosition.withdraw(\n            Storage.slot().positions[_ccy],\n            _user,\n            _counterparty,\n            vars.target\n        );\n\n        if (vars.rebalanceAmount > 0) {\n            Storage.Book storage book = Storage.slot().books[_user][_ccy];\n            book.lockedCollateral = book.lockedCollateral - vars.rebalanceAmount;\n            book.independentAmount = book.independentAmount + vars.rebalanceAmount;\n\n            _updateUsedCurrenciesInPosition(_user, _counterparty, _ccy);\n\n            emit RebalanceFrom(_user, _counterparty, _ccy, vars.rebalanceAmount);\n        }\n\n        vars.left = vars.target - vars.rebalanceAmount;\n\n        return (vars.left * uint256(vars.exchangeRate)) / 1e18;\n    }\n\n    function _liquidate(\n        address _from,\n        address _to,\n        bytes32 _ccy,\n        uint256 _amountETH\n    ) internal returns (uint256 liquidationLeftETH) {\n        int256 exchangeRate = currencyController().getLastETHPrice(_ccy);\n        uint256 liquidationTarget = (_amountETH * 1e18) / uint256(exchangeRate);\n        uint256 liquidated = CollateralPosition.liquidate(\n            Storage.slot().positions[_ccy],\n            _from,\n            _to,\n            liquidationTarget\n        );\n\n        Storage.Book storage book = Storage.slot().books[_from][_ccy];\n        book.lockedCollateral = book.lockedCollateral - liquidated;\n\n        book = Storage.slot().books[_to][_ccy];\n        book.lockedCollateral = book.lockedCollateral + liquidated;\n\n        if (liquidated > 0) {\n            _updateUsedCurrenciesInPosition(_from, _to, _ccy);\n            emit Liquidate(_from, _to, _ccy, liquidated);\n        }\n\n        uint256 liquidationLeft = liquidationTarget - liquidated;\n\n        if (liquidationLeft > 0) {\n            uint256 independentLiquidation = _tryLiquidateIndependentCollateral(\n                _from,\n                _to,\n                _ccy,\n                liquidationLeft\n            );\n            liquidationLeft = liquidationLeft - independentLiquidation;\n        }\n\n        liquidationLeftETH = (liquidationLeft * uint256(exchangeRate)) / 1e18;\n    }\n\n    function _tryLiquidateIndependentCollateral(\n        address _from,\n        address _to,\n        bytes32 _ccy,\n        uint256 _amount\n    ) internal returns (uint256 liquidated) {\n        uint256 maxWidthdrawETH = collateralAggregator().getMaxCollateralBookWidthdraw(_from);\n        uint256 maxLiquidation = currencyController().convertFromETH(_ccy, maxWidthdrawETH);\n\n        liquidated = _amount > maxLiquidation ? maxLiquidation : _amount;\n\n        Storage.Book storage book = Storage.slot().books[_from][_ccy];\n        book.independentAmount = book.independentAmount - liquidated;\n\n        book = Storage.slot().books[_to][_ccy];\n        book.lockedCollateral = book.lockedCollateral + liquidated;\n\n        CollateralPosition.deposit(Storage.slot().positions[_ccy], _to, _from, liquidated);\n\n        emit LiquidateIndependent(_from, _to, _ccy, liquidated);\n    }\n\n    function _updateUsedCurrencies(bytes32 _ccy) internal {\n        if (\n            Storage.slot().books[msg.sender][_ccy].independentAmount > 0 ||\n            Storage.slot().books[msg.sender][_ccy].lockedCollateral > 0\n        ) {\n            Storage.slot().usedCurrencies[msg.sender].add(_ccy);\n        } else {\n            Storage.slot().usedCurrencies[msg.sender].remove(_ccy);\n        }\n    }\n\n    function _updateUsedCurrenciesInPosition(\n        address _user,\n        address _counterparty,\n        bytes32 _ccy\n    ) internal {\n        (uint256 locked0, uint256 locked1) = CollateralPosition.get(\n            Storage.slot().positions[_ccy],\n            _user,\n            _counterparty\n        );\n\n        if (locked0 > 0) {\n            Storage.slot().usedCurrencies[_user].add(_ccy);\n        }\n\n        if (locked1 > 0) {\n            Storage.slot().usedCurrencies[_counterparty].add(_ccy);\n        }\n\n        (bytes32 packedAddrs, ) = AddressPacking.pack(_user, _counterparty);\n        if (locked0 > 0 || locked1 > 0) {\n            Storage.slot().usedCurrenciesInPosition[packedAddrs].add(_ccy);\n        } else {\n            Storage.slot().usedCurrenciesInPosition[packedAddrs].remove(_ccy);\n        }\n    }\n}\n"
    },
    "contracts/libraries/CollateralPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./AddressPacking.sol\";\n\nlibrary CollateralPosition {\n    /**\n     * @dev Position structure used for keeping track of collateral\n     * amounts locked by counterparties in bilateral relations\n     */\n    struct Position {\n        uint256 lockedCollateralA;\n        uint256 lockedCollateralB;\n    }\n\n    function _handleFlippedCase(CollateralPosition.Position memory position, bool flipped)\n        internal\n        pure\n        returns (CollateralPosition.Position memory)\n    {\n        if (flipped) {\n            uint256 locked = position.lockedCollateralA;\n\n            position.lockedCollateralA = position.lockedCollateralB;\n            position.lockedCollateralB = locked;\n        }\n\n        return position;\n    }\n\n    /**\n     * @dev Returns the bilateral collateral position between 2 counterparties\n     * @param self The mapping with all bilateral collateral positions\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     */\n    function get(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address party0,\n        address party1\n    ) internal view returns (uint256, uint256) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n        CollateralPosition.Position memory position = self[packedAddrs];\n        position = _handleFlippedCase(position, flipped);\n\n        return (position.lockedCollateralA, position.lockedCollateralB);\n    }\n\n    /**\n     * @dev Adds deposited amount into bilateral position from one party\n     * @param self The mapping with all bilateral collateral positions\n     * @param depositor Address of user depositing funds\n     * @param counterparty Counterparty address\n     * @param amount Number of funds deposited by user\n     */\n    function deposit(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address depositor,\n        address counterparty,\n        uint256 amount\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(depositor, counterparty);\n        CollateralPosition.Position storage position = self[packedAddrs];\n\n        if (!flipped) {\n            position.lockedCollateralA = position.lockedCollateralA + amount;\n        } else {\n            position.lockedCollateralB = position.lockedCollateralB + amount;\n        }\n    }\n\n    // /**\n    // * @dev Adds deposited amounts into bilateral position,\n    // * helpful during rebalancing from books of both parties\n    // * @param self The mapping with all bilateral collateral positions\n    // * @param party0 First counterparty address\n    // * @param party1 Second counterparty address\n    // * @param amount0 Number of funds deposited by first counterparty\n    // * @param amount1 Number of funds deposited by second counterparty\n    // */\n    // function deposit(\n    //     mapping(bytes32 => CollateralPosition.Position) storage self,\n    //     address party0,\n    //     address party1,\n    //     uint256 amount0,\n    //     uint256 amount1\n    // ) internal {\n    //     (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n    //     CollateralPosition.Position storage position = self[packedAddrs];\n\n    //     position.lockedCollateralA = flipped ? position.lockedCollateralA + amount1 : position.lockedCollateralA + amount0;\n    //     position.lockedCollateralB = flipped ? position.lockedCollateralB + amount0 : position.lockedCollateralB + amount1;\n    // }\n\n    /**\n     * @dev Removes withdrawn amounts from bilateral position for one party\n     * @param self The mapping with all bilateral collateral positions\n     * @param user Address of user withdrawing funds\n     * @param counterparty Counterparty address\n     * @param amount Number of funds withdrawn by user\n     * @notice Returns the number of funds withdrawn by user\n     */\n    function withdraw(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address user,\n        address counterparty,\n        uint256 amount\n    ) internal returns (uint256 maxWithdraw) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(user, counterparty);\n        CollateralPosition.Position storage position = self[packedAddrs];\n\n        if (!flipped) {\n            maxWithdraw = position.lockedCollateralA >= amount\n                ? amount\n                : position.lockedCollateralA;\n            position.lockedCollateralA = position.lockedCollateralA - maxWithdraw;\n        } else {\n            maxWithdraw = position.lockedCollateralB >= amount\n                ? amount\n                : position.lockedCollateralB;\n            position.lockedCollateralB = position.lockedCollateralB - maxWithdraw;\n        }\n    }\n\n    // /**\n    // * @dev Removes withdrawn amounts from bilateral position for both parties\n    // * @param self The mapping with all bilateral collateral positions\n    // * @param party0 First counterparty address\n    // * @param party1 Second counterparty address\n    // * @param amount0 Number of funds withdrawn by first counterparty\n    // * @param amount1 Number of funds withdrawn by second counterparty\n    // */\n    // function withdraw(\n    //     mapping(bytes32 => CollateralPosition.Position) storage self,\n    //     address party0,\n    //     address party1,\n    //     uint256 amount0,\n    //     uint256 amount1\n    // ) internal {\n    //     (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n    //     CollateralPosition.Position storage position = self[packedAddrs];\n\n    //     position.lockedCollateralA = flipped ? position.lockedCollateralA - amount1 : position.lockedCollateralA - amount0;\n    //     position.lockedCollateralB = flipped ? position.lockedCollateralB - amount0 : position.lockedCollateralB - amount1;\n    // }\n\n    /**\n     * @dev Liquidates required amount from one party to another inside position\n     * @param self The mapping with all bilateral collateral positions\n     * @param from Address for liquidating collateral from\n     * @param to Address for sending collateral to\n     * @param amount Number of funds to liquidate\n     */\n    function liquidate(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256 liquidated) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(from, to);\n        CollateralPosition.Position storage position = self[packedAddrs];\n\n        if (!flipped) {\n            liquidated = position.lockedCollateralA >= amount ? amount : position.lockedCollateralA;\n            position.lockedCollateralA = position.lockedCollateralA - liquidated;\n            position.lockedCollateralB = position.lockedCollateralB + liquidated;\n        } else {\n            liquidated = position.lockedCollateralB >= amount ? amount : position.lockedCollateralB;\n            position.lockedCollateralB = position.lockedCollateralB - liquidated;\n            position.lockedCollateralA = position.lockedCollateralA + liquidated;\n        }\n    }\n\n    /**\n     * @dev Rebalances required amount between 2 bilateral positions\n     * @param self The mapping with all bilateral collateral positions\n     * @param user Address of main party to rebalance funds between counterparties for\n     * @param fromParty Counterparty address for rebalancing collateral from\n     * @param toParty Counterparty address for rebalancing collateral to\n     * @param amount Number of funds to rebalance\n     */\n    function rebalance(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address user,\n        address fromParty,\n        address toParty,\n        uint256 amount\n    ) internal returns (uint256 rebalanced) {\n        // max checks\n        (bytes32 packedAddr, bool flipped) = AddressPacking.pack(user, fromParty);\n        CollateralPosition.Position storage position = self[packedAddr];\n\n        if (!flipped) {\n            rebalanced = position.lockedCollateralA >= amount ? amount : position.lockedCollateralA;\n            position.lockedCollateralA = position.lockedCollateralA - rebalanced;\n        } else {\n            rebalanced = position.lockedCollateralB >= amount ? amount : position.lockedCollateralB;\n            position.lockedCollateralB = position.lockedCollateralB - rebalanced;\n        }\n\n        (packedAddr, flipped) = AddressPacking.pack(user, toParty);\n        position = self[packedAddr];\n\n        if (!flipped) {\n            position.lockedCollateralA = position.lockedCollateralA + rebalanced;\n        } else {\n            position.lockedCollateralB = position.lockedCollateralB + rebalanced;\n        }\n    }\n\n    /**\n     * @dev Clears the state of bilateral position\n     * @param self The mapping with all bilateral collateral positions\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     */\n    function clear(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address party0,\n        address party1\n    ) internal {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        delete self[packedAddrs];\n    }\n}\n"
    },
    "contracts/storages/CollateralVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../libraries/CollateralPosition.sol\";\n\nlibrary CollateralVaultStorage {\n    using CollateralPosition for CollateralPosition.Position;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.collateralVault\");\n\n    struct Book {\n        uint256 independentAmount;\n        uint256 lockedCollateral;\n    }\n\n    struct Storage {\n        mapping(bytes32 => address) tokenAddresses;\n        // Mapping for used currency vaults in bilateral position.\n        mapping(bytes32 => EnumerableSet.Bytes32Set) usedCurrenciesInPosition;\n        // Mapping for used currency vaults per user.\n        mapping(address => EnumerableSet.Bytes32Set) usedCurrencies;\n        // Mapping for all deposits of currency per users collateral\n        mapping(address => mapping(bytes32 => Book)) books;\n        // Mapping for bilateral collateral positions between 2 counterparties per currency\n        mapping(bytes32 => mapping(bytes32 => CollateralPosition.Position)) positions;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "contracts/test/CollateralPositionTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/CollateralPosition.sol\";\n\ncontract CollateralPositionTest {\n    mapping(bytes32 => CollateralPosition.Position) private _positions;\n\n    function get(address party0, address party1) public view returns (uint256, uint256) {\n        return CollateralPosition.get(_positions, party0, party1);\n    }\n\n    function getGasCostOfGet(address party0, address party1) public view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        CollateralPosition.get(_positions, party0, party1);\n\n        return gasBefore - gasleft();\n    }\n\n    function deposit(\n        address depositor,\n        address counterparty,\n        uint256 amount\n    ) public {\n        (uint256 lockedCollateralBeforeDepositor, ) = get(depositor, counterparty);\n\n        CollateralPosition.deposit(_positions, depositor, counterparty, amount);\n\n        (uint256 lockedCollateralAfterDepositor, ) = get(depositor, counterparty);\n\n        require(\n            lockedCollateralAfterDepositor == lockedCollateralBeforeDepositor + amount,\n            \"INCORRECT_DEPOSIT_ADDITION\"\n        );\n    }\n\n    function withdraw(\n        address user,\n        address counterparty,\n        uint256 amount\n    ) public {\n        (uint256 lockedCollateralBeforeUser, ) = get(user, counterparty);\n\n        CollateralPosition.withdraw(_positions, user, counterparty, amount);\n\n        (uint256 lockedCollateralAfterUser, ) = get(user, counterparty);\n\n        uint256 withdrawn = lockedCollateralBeforeUser >= amount\n            ? amount\n            : lockedCollateralBeforeUser;\n        require(\n            lockedCollateralAfterUser == lockedCollateralBeforeUser - withdrawn,\n            \"INCORRECT_WITHDRAW_SUBSTRACTION\"\n        );\n    }\n\n    function liquidate(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        (uint256 lockedCollateralBeforeFrom, uint256 lockedCollateralBeforeTo) = get(from, to);\n\n        CollateralPosition.liquidate(_positions, from, to, amount);\n\n        (uint256 lockedCollateralAfterFrom, uint256 lockedCollateralAfterTo) = get(from, to);\n\n        uint256 liquidated = lockedCollateralBeforeFrom >= amount\n            ? amount\n            : lockedCollateralBeforeFrom;\n\n        require(\n            lockedCollateralAfterFrom == lockedCollateralBeforeFrom - liquidated,\n            \"INCORRECT_LIQUIDATION_SUBSTRACTION\"\n        );\n        require(\n            lockedCollateralAfterTo == lockedCollateralBeforeTo + liquidated,\n            \"INCORRECT_LIQUIDATION_ADDITION\"\n        );\n    }\n\n    function rebalance(\n        address user,\n        address fromParty,\n        address toParty,\n        uint256 amount\n    ) public {\n        (uint256 lockedCollateralBeforeUser0, ) = get(user, fromParty);\n        (uint256 lockedCollateralBeforeUser1, ) = get(user, toParty);\n\n        CollateralPosition.rebalance(_positions, user, fromParty, toParty, amount);\n\n        (uint256 lockedCollateralAfterUser0, ) = get(user, fromParty);\n        (uint256 lockedCollateralAfterUser1, ) = get(user, toParty);\n\n        uint256 rebalanced = lockedCollateralBeforeUser0 >= amount\n            ? amount\n            : lockedCollateralBeforeUser0;\n\n        require(\n            lockedCollateralAfterUser0 == lockedCollateralBeforeUser0 - rebalanced,\n            \"INCORRECT_REBALANCE_SUBSTRACTION\"\n        );\n\n        require(\n            lockedCollateralAfterUser1 == lockedCollateralBeforeUser1 + rebalanced,\n            \"INCORRECT_REBALANCE_ADDITION\"\n        );\n    }\n\n    function clear(address party0, address party1) public {\n        CollateralPosition.clear(_positions, party0, party1);\n\n        (uint256 lockedCollateralA, uint256 lockedCollateralB) = get(party0, party1);\n\n        require(lockedCollateralA == 0 && lockedCollateralB == 0, \"INCORRECT_POSITION_CLEAR\");\n    }\n}\n"
    },
    "contracts/mocks/CollateralAggregatorMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/AddressPacking.sol\";\nimport \"../interfaces/ICollateralVault.sol\";\nimport \"../CollateralAggregatorV2.sol\";\n\ncontract CollateralAggregatorMock is CollateralAggregatorV2 {\n    mapping(address => uint256) _maxWithdrawals;\n    mapping(bytes32 => PositionWithdrawal) _maxPositionWithdrawals;\n\n    struct PositionWithdrawal {\n        uint256 withdraw0;\n        uint256 withdraw1;\n    }\n\n    function getMaxCollateralBookWidthdraw(address user) public view override returns (uint256) {\n        return _maxWithdrawals[user];\n    }\n\n    function getMaxCollateralWidthdraw(address party0, address party1)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        (bytes32 addrPack, bool flipped) = AddressPacking.pack(party0, party1);\n        PositionWithdrawal memory withdrawal = _maxPositionWithdrawals[addrPack];\n        withdrawal = _handleFlippedCase(withdrawal, flipped);\n\n        return (withdrawal.withdraw0, withdrawal.withdraw1);\n    }\n\n    function setMaxCollateralBookWidthdraw(address user, uint256 amount) public {\n        _maxWithdrawals[user] = amount;\n    }\n\n    function setMaxCollateralWidthdraw(\n        address party0,\n        address party1,\n        uint256 amount0,\n        uint256 amount1\n    ) public {\n        (bytes32 addrPack, bool flipped) = AddressPacking.pack(party0, party1);\n        PositionWithdrawal memory withdrawal;\n\n        withdrawal.withdraw0 = amount0;\n        withdrawal.withdraw1 = amount1;\n\n        withdrawal = _handleFlippedCase(withdrawal, flipped);\n        _maxPositionWithdrawals[addrPack] = withdrawal;\n    }\n\n    function _handleFlippedCase(PositionWithdrawal memory withdrawal, bool flipped)\n        internal\n        pure\n        returns (PositionWithdrawal memory)\n    {\n        if (flipped) {\n            uint256 withdraw = withdrawal.withdraw0;\n\n            withdrawal.withdraw0 = withdrawal.withdraw1;\n            withdrawal.withdraw1 = withdraw;\n        }\n\n        return withdrawal;\n    }\n\n    function rebalanceCollateral(\n        address _user,\n        address _counterparty,\n        uint256 _amountETH,\n        bool isRebalanceFrom\n    ) external returns (bool) {\n        return\n            collateralVault().rebalanceCollateral(\n                _user,\n                _counterparty,\n                _amountETH,\n                isRebalanceFrom\n            );\n    }\n\n    function rebalanceBetween(\n        address _user,\n        address _fromParty,\n        address _toParty,\n        bytes32 _ccy,\n        uint256 _amountETH\n    ) external returns (uint256) {\n        return collateralVault().rebalanceBetween(_user, _fromParty, _toParty, _ccy, _amountETH);\n    }\n\n    function liquidateAll(\n        address _from,\n        address _to,\n        uint256 _amountETH\n    ) external returns (bool) {\n        return collateralVault().liquidate(_from, _to, _amountETH);\n    }\n}\n"
    },
    "contracts/CollateralAggregatorV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"./libraries/AddressPacking.sol\";\nimport \"./libraries/NetPV.sol\";\nimport \"./interfaces/ICollateralAggregatorV2.sol\";\nimport \"./mixins/MixinCollateralManagement.sol\";\nimport \"./types/ProtocolTypes.sol\";\n\n/**\n * @title Collateral Aggregator contract is used to manage Secured Finance\n * protocol collateral obligations and movements of collateral across collateral vaults.\n *\n * This contract handle the calculations of aggregated collateral obligations between users\n * in a bilateral relations, calculations of required rebalancing to stabilize\n * the bilateral position, liquidations using FX rates for all protocol currency pairs to ETH\n *\n * Liquidations and rebalancing operations are handled across all collateral vaults where\n * users have deposited their funds in FIFO order.\n *\n * Contract linked to Product based contracts (like Loan, Swap, etc),\n * LendingMarkets, CurrencyController contracts and Liquidation Engine.\n */\ncontract CollateralAggregatorV2 is ICollateralAggregator, MixinCollateralManagement {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using NetPV for NetPV.CcyNetting;\n\n    /**\n     * @dev Modifier to check if user registered already\n     */\n    modifier registeredUser(address _user) {\n        require(Storage.slot().isRegistered[_user], \"NOT_REGISTERED\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if user hasn't been registered yet\n     */\n    modifier nonRegisteredUser(address _user) {\n        require(!Storage.slot().isRegistered[_user], \"REGISTERED_ALREADY\");\n        _;\n    }\n\n    // =========== COLLATERAL BOOK SECTION ===========\n\n    /**\n     * @dev Register user and store collateral book\n     */\n    function register() public override nonRegisteredUser(msg.sender) {\n        string[] memory _addresses = new string[](0);\n        uint256[] memory _chainIds = new uint256[](0);\n\n        _register(_addresses, _chainIds);\n    }\n\n    /**\n     * @dev Register user and store collateral book\n     * @param _addresses Array of other blockchain addresses\n     * @param _chainIds Array of chain ids for other blockchains\n     */\n    function register(string[] memory _addresses, uint256[] memory _chainIds)\n        public\n        override\n        nonRegisteredUser(msg.sender)\n    {\n        _register(_addresses, _chainIds);\n    }\n\n    // TODO: Rebalance from position to book once position coverage more than 150%\n\n    /**\n     * @dev Triggers to lock unsettled collateral on a global book for selected currency.\n     * @param user User's address\n     * @param ccy Specified currency of the deal\n     * @param amount Amount of funds to be locked in Ccy for user\n     */\n    function useUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external override onlyAcceptedContracts {\n        Storage.slot().exposedUnsettledCurrencies[user].add(ccy);\n        require(isCoveredUnsettled(user, ccy, amount), \"Not enough collateral\");\n\n        Storage.slot().unsettledCollateral[user][ccy] += amount;\n\n        emit UseUnsettledCollateral(user, ccy, amount);\n    }\n\n    /**\n     * @dev Triggers to lock collateral using ETH rate for selected currency.\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be locked in Ccy for counterparty A\n     * @param amount1 Amount of funds to be locked in Ccy for counterparty B\n     */\n    function useCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external override onlyAcceptedContracts {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(partyA, partyB);\n        Storage.slot().exposedCurrencies[packedAddrs].add(ccy);\n\n        NetPV.use(Storage.slot().ccyNettings, partyA, partyB, ccy, amount0, amount1, isSettled);\n        _rebalanceIfRequired(partyA, partyB, true);\n\n        emit UseCollateral(partyA, partyB, ccy, amount0, amount1, isSettled);\n    }\n\n    /**\n     * @dev Triggers to lock collateral using ETH rate for selected currency.\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be locked in Ccy for counterparty A\n     * @param amount1 Amount of funds to be locked in Ccy for counterparty B\n     */\n    function settleCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    ) external override onlyAcceptedContracts {\n        NetPV.settle(Storage.slot().ccyNettings, partyA, partyB, ccy, amount0, amount1);\n        _rebalanceIfRequired(partyA, partyB, true);\n\n        emit SettleCollateral(partyA, partyB, ccy, amount0, amount1);\n    }\n\n    /**\n     * @dev Triggers to calculate total unsettled exposure across all currencies\n     * @param _user User's address\n     */\n    function getTotalUnsettledExp(address _user) public view override returns (uint256) {\n        return _netTotalUnsettledAndHypotheticalPV(_user, \"\", 0);\n    }\n\n    /**\n     * @dev Triggers to calculate netted exposures across all currencies with applied haircuts\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     */\n    function getNetAndTotalPV(address _party0, address _party1)\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _netTotalAndHypotheticalPV(_party0, _party1, \"\", 0, 0, false);\n    }\n\n    /**\n     * @dev Triggers to check if unsettled collateral exposure covered more that 150% from a global collateral book of `_user`.\n     * @param _user User's ethereum address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _unsettledExp Additional exposure to lock into unsettled exposure\n     */\n    function isCoveredUnsettled(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) public view override returns (bool) {\n        (uint256 coverage, ) = _calculateUnsettledCoverageAndTotalExposure(\n            _user,\n            _ccy,\n            _unsettledExp\n        );\n        return coverage >= Storage.slot().marginCallThresholdRate;\n    }\n\n    /**\n     * @dev Triggers to check if collateral covered more that 150%.\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _party0PV Counterparty A additional present value\n     * @param _party1PV Counterparty B additional present value\n     */\n    function isCovered(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) public view override returns (bool, bool) {\n        (uint256 cover0, uint256 cover1) = _calculateCoverage(\n            _party0,\n            _party1,\n            _ccy,\n            _party0PV,\n            _party1PV,\n            _isSettled\n        );\n\n        return (cover0 >= getMarginCallThresholdRate(), cover1 >= getMarginCallThresholdRate());\n    }\n\n    /**\n     * @dev Triggers to get maximum amount of ETH available to widthdraw from `_user` collateral book.\n     * @param _user User's address\n     */\n    function getMaxCollateralBookWidthdraw(address _user)\n        public\n        view\n        virtual\n        override\n        returns (uint256 maxWithdraw)\n    {\n        (maxWithdraw, ) = _calcMaxCollateralWidthdrawFromBook(_user);\n    }\n\n    /**\n     * @dev Triggers to get maximum amount of ETH available to\n     * widthdraw from bilateral position between `party0` and `_party1`.\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     */\n    function getMaxCollateralWidthdraw(address _party0, address _party1)\n        public\n        view\n        virtual\n        override\n        returns (uint256, uint256)\n    {\n        uint256 colAdjustment0;\n        bool isWithdraw0;\n        uint256 colAdjustment1;\n        bool isWithdraw1;\n\n        (colAdjustment0, isWithdraw0, colAdjustment1, isWithdraw1) = _calcCollateralAdjustment(\n            _party0,\n            _party1,\n            \"\",\n            0,\n            0,\n            false,\n            true\n        );\n\n        return (isWithdraw0 ? colAdjustment0 : 0, isWithdraw1 ? colAdjustment1 : 0);\n    }\n\n    /**\n     * @dev Triggers to get coverage of the global collateral book against all unsettled exposure.\n     * @param _user User's address\n     */\n    function getUnsettledCoverage(address _user) public view override returns (uint256 coverage) {\n        (coverage, ) = _calculateUnsettledCoverageAndTotalExposure(_user, \"\", 0);\n    }\n\n    /**\n     * @dev Triggers to get coverage of the global collateral book against all unsettled exposure.\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     */\n    function getRebalanceCollateralAmounts(address _party0, address _party1)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 colAdjustment0;\n        bool isWithdraw0;\n        uint256 colAdjustment1;\n        bool isWithdraw1;\n\n        (colAdjustment0, isWithdraw0, colAdjustment1, isWithdraw1) = _calcCollateralAdjustment(\n            _party0,\n            _party1,\n            \"\",\n            0,\n            0,\n            false,\n            true\n        );\n\n        return (isWithdraw0 ? 0 : colAdjustment0, isWithdraw1 ? 0 : colAdjustment1);\n    }\n\n    /**\n     * @dev Triggers to get bilateral position collateral coverage.\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     */\n    function getCoverage(address _party0, address _party1)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        return _calculateCoverage(_party0, _party1, \"\", 0, 0, false);\n    }\n\n    /**\n     * @dev Triggers to reduce the amount of unsettled exposure in specific `ccy` from a global collateral book of `user`\n     * @param user User's ETH address\n     * @param ccy Specified currency of the deal\n     * @param amount Amount of funds to be unlocked from unsettled exposure in specified ccy\n     */\n    function releaseUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external override onlyAcceptedContracts {\n        Storage.slot().unsettledCollateral[user][ccy] -= amount;\n\n        if (Storage.slot().unsettledCollateral[user][ccy] == 0) {\n            Storage.slot().exposedUnsettledCurrencies[user].remove(ccy);\n        }\n\n        emit ReleaseUnsettled(user, ccy, amount);\n    }\n\n    /**\n     * @dev Triggers to reduce PV for specific `ccy` in bilateral position between `partyA` and `partyB`\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be removed in CcyNetting for counterparty A\n     * @param amount1 Amount of funds to be removed in CcyNetting for counterparty B\n     */\n    function releaseCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external override onlyAcceptedContracts {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(partyA, partyB);\n        require(Storage.slot().exposedCurrencies[packedAddrs].contains(ccy), \"non-used ccy\");\n\n        NetPV.release(Storage.slot().ccyNettings, partyA, partyB, ccy, amount0, amount1, isSettled);\n        _rebalanceIfRequired(partyA, partyB, true);\n\n        emit Release(partyA, partyB, ccy, amount0, amount1, isSettled);\n    }\n\n    /**\n     * @dev Triggers to update PV value in currency for bilateral position\n     * changes present value in native currency, without exchange rate conversion\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param prevPV0 Previous present value to be substracted from total exposure for counterparty A\n     * @param prevPV1 Previous present value to be substracted from total exposure for counterparty B\n     * @param currentPV0 Current present value to be added to total exposure for counterparty A\n     * @param currentPV1 Current present value to be added to total exposure for counterparty B\n     */\n    function updatePV(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) external override onlyAcceptedContracts {\n        NetPV.update(\n            Storage.slot().ccyNettings,\n            party0,\n            party1,\n            ccy,\n            prevPV0,\n            prevPV1,\n            currentPV0,\n            currentPV1\n        );\n\n        _rebalanceIfRequired(party0, party1, true);\n\n        emit UpdatePV(party0, party1, ccy, prevPV0, prevPV1, currentPV0, currentPV1);\n    }\n\n    /**\n     * @dev Triggers to liquidate collateral between `from` and `to` parties\n     * works with aggregated liquidation amount in ETH\n     *\n     * @param from Address for liquidating collateral from\n     * @param to Address for sending collateral to\n     * @param liquidationInETH Liquidation amount in Ccy\n     */\n    function liquidate(\n        address from,\n        address to,\n        uint256 liquidationInETH\n    ) external override onlyLiquidations {\n        require(\n            collateralVault().liquidate(from, to, liquidationInETH),\n            \"INCORRECT_LIQUIDATION_ACROSS_VAULTS\"\n        );\n    }\n\n    /**\n     * @dev Triggers to liquidate collateral between `from` and `to` parties\n     * works liquidation amount in native `ccy`\n     *\n     * @param from Address for liquidating collateral from\n     * @param to Address for sending collateral to\n     * @param ccy Short identifier of currency used to liquidate\n     * @param liquidationAmount Liquidation amount in Ccy\n     * @param isSettled Identifier wether collateral obligations for release is settled\n     */\n    function liquidate(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 liquidationAmount,\n        uint256 pv,\n        bool isSettled\n    ) external override onlyAcceptedContracts {\n        uint256 liquidationTarget = (liquidationAmount * getAutoLiquidationThresholdRate()) /\n            ProtocolTypes.BP;\n        uint256 liqudationInETH = currencyController().convertToETH(ccy, liquidationTarget);\n\n        require(\n            collateralVault().liquidate(from, to, liqudationInETH),\n            \"INCORRECT_LIQUIDATION_ACROSS_VAULTS\"\n        );\n\n        emit Liquidate(from, to, ccy, liquidationAmount);\n\n        NetPV.release(Storage.slot().ccyNettings, from, to, ccy, pv, 0, isSettled);\n\n        emit Release(from, to, ccy, pv, 0, isSettled);\n\n        _rebalanceIfRequired(from, to, true);\n    }\n\n    function checkRegisteredUser(address addr) public view override returns (bool) {\n        return Storage.slot().isRegistered[addr];\n    }\n\n    function getCcyExposures(\n        address partyA,\n        address partyB,\n        bytes32 ccy\n    )\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(partyA, partyB);\n        require(Storage.slot().exposedCurrencies[packedAddrs].contains(ccy), \"non-used ccy\");\n        NetPV.CcyNetting memory netting = NetPV.get(\n            Storage.slot().ccyNettings,\n            partyA,\n            partyB,\n            ccy\n        );\n\n        return (netting.unsettled0PV, netting.unsettled1PV, netting.party0PV, netting.party1PV);\n    }\n\n    function getExposedCurrencies(address partyA, address partyB)\n        public\n        view\n        override\n        returns (bytes32[] memory)\n    {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(partyA, partyB);\n        EnumerableSet.Bytes32Set storage expCcy = Storage.slot().exposedCurrencies[packedAddrs];\n\n        uint256 numCcy = expCcy.length();\n        bytes32[] memory currencies = new bytes32[](numCcy);\n\n        for (uint256 i = 0; i < numCcy; i++) {\n            bytes32 ccy = expCcy.at(i);\n            currencies[i] = ccy;\n        }\n\n        return currencies;\n    }\n\n    function getUnsettledCollateral(address user, bytes32 ccy) external view returns (uint256) {\n        return Storage.slot().unsettledCollateral[user][ccy];\n    }\n\n    // =========== INTERNAL FUNCTIONS ===========\n\n    /**\n     * @dev Triggers internaly to store new collateral book\n     */\n    function _register(string[] memory _addresses, uint256[] memory _chainIds) internal {\n        Storage.slot().isRegistered[msg.sender] = true;\n        // perform onboarding steps here\n\n        crosschainAddressResolver().updateAddresses(msg.sender, _chainIds, _addresses);\n\n        emit Register(msg.sender);\n    }\n\n    struct NetAndTotalPVLocalVars {\n        bytes32 packedAddrs;\n        bytes32 ccy;\n        NetPV.CcyNetting netting;\n        uint256 exchangeRate;\n        uint256 totalUnsettledPV0inETH;\n        uint256 totalUnsettledPV1inETH;\n        uint256 totalPV0inETH;\n        uint256 totalPV1inETH;\n        uint256 totalCombinedPV0inETH;\n        uint256 totalCombinedPV1inETH;\n        uint256 totalHaircutPV0;\n        uint256 totalHaircutPV1;\n        uint256 haircutRatio;\n        uint256 pvDiff0;\n        uint256 pvDiff1;\n        uint256 netPV0;\n        uint256 netPV1;\n        uint256 maxCcy;\n    }\n\n    /**\n     * @dev Triggers to calculate netted exposures across all currencies with applied haircuts.\n     * Also used to calculate hypothetical Net PV with additional exposure in specific `_ccy`\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _party0PV Counterparty A additional present value\n     * @param _party1PV Counterparty B additional present value\n     */\n    function _netTotalAndHypotheticalPV(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool isSettled\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        NetAndTotalPVLocalVars memory vars;\n        (vars.packedAddrs, ) = AddressPacking.pack(_party0, _party1);\n        EnumerableSet.Bytes32Set storage expCcy = Storage.slot().exposedCurrencies[\n            vars.packedAddrs\n        ];\n\n        vars.maxCcy = expCcy.length();\n\n        for (uint256 i = 0; i < vars.maxCcy; i++) {\n            vars.ccy = expCcy.at(i);\n\n            if (_ccy == vars.ccy) {\n                vars.netting = NetPV.get(\n                    Storage.slot().ccyNettings,\n                    _party0,\n                    _party1,\n                    vars.ccy,\n                    _party0PV,\n                    _party1PV,\n                    isSettled\n                );\n            } else {\n                vars.netting = NetPV.get(Storage.slot().ccyNettings, _party0, _party1, vars.ccy);\n            }\n\n            vars.exchangeRate = uint256(currencyController().getLastETHPrice(vars.ccy));\n            vars.netting = _convertPositionToETH(vars.netting, vars.exchangeRate);\n\n            vars.totalUnsettledPV0inETH = vars.totalUnsettledPV0inETH + vars.netting.unsettled0PV;\n            vars.totalUnsettledPV1inETH = vars.totalUnsettledPV1inETH + vars.netting.unsettled1PV;\n\n            vars.haircutRatio = currencyController().getHaircut(vars.ccy);\n\n            vars.totalPV0inETH = vars.totalPV0inETH + vars.netting.party0PV;\n            vars.totalPV1inETH = vars.totalPV1inETH + vars.netting.party1PV;\n            vars.totalHaircutPV0 =\n                vars.totalHaircutPV0 +\n                (vars.netting.party0PV * vars.haircutRatio) /\n                ProtocolTypes.BP;\n            vars.totalHaircutPV1 =\n                vars.totalHaircutPV1 +\n                (vars.netting.party1PV * vars.haircutRatio) /\n                ProtocolTypes.BP;\n        }\n\n        vars.pvDiff0 = vars.totalPV0inETH >= vars.totalHaircutPV1\n            ? vars.totalPV0inETH - vars.totalHaircutPV1\n            : 0;\n        vars.pvDiff1 = vars.totalPV1inETH >= vars.totalHaircutPV0\n            ? vars.totalPV1inETH - vars.totalHaircutPV0\n            : 0;\n\n        (vars.netPV0, vars.netPV1) = vars.pvDiff0 > vars.pvDiff1\n            ? (\n                vars.pvDiff0 - vars.pvDiff1 + vars.totalUnsettledPV0inETH,\n                vars.totalUnsettledPV1inETH\n            )\n            : (\n                vars.totalUnsettledPV0inETH,\n                vars.pvDiff1 - vars.pvDiff0 + vars.totalUnsettledPV1inETH\n            );\n\n        vars.totalCombinedPV0inETH = vars.totalUnsettledPV0inETH + vars.totalPV0inETH;\n        vars.totalCombinedPV1inETH = vars.totalUnsettledPV1inETH + vars.totalPV1inETH;\n\n        return (vars.netPV0, vars.netPV1, vars.totalCombinedPV0inETH, vars.totalCombinedPV1inETH);\n    }\n\n    function _convertPositionToETH(NetPV.CcyNetting memory netting, uint256 exchangeRate)\n        internal\n        pure\n        returns (NetPV.CcyNetting memory)\n    {\n        if (netting.unsettled0PV > 0) {\n            netting.unsettled0PV = (netting.unsettled0PV * exchangeRate) / 1e18;\n        }\n\n        if (netting.unsettled1PV > 0) {\n            netting.unsettled1PV = (netting.unsettled1PV * exchangeRate) / 1e18;\n        }\n\n        if (netting.party0PV > 0) {\n            netting.party0PV = (netting.party0PV * exchangeRate) / 1e18;\n        }\n\n        if (netting.party1PV > 0) {\n            netting.party1PV = (netting.party1PV * exchangeRate) / 1e18;\n        }\n\n        return netting;\n    }\n\n    struct CollateralReqLocalVars {\n        uint256 net0;\n        uint256 net1;\n        uint256 total0;\n        uint256 total1;\n        uint256 minMarginReq0;\n        uint256 minMarginReq1;\n        uint256 req0;\n        uint256 req1;\n    }\n\n    /**\n     * @dev Triggers to calculate collateral coverage for bilateral position with/without additional PV\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `cover0`, `cover1` uint256 coverage percentages in basis point per counterparty\n     */\n    // TODO: NOW\n    function _calculateCollateralRequirements(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) internal view returns (uint256, uint256) {\n        CollateralReqLocalVars memory vars;\n\n        (vars.net0, vars.net1, vars.total0, vars.total1) = _netTotalAndHypotheticalPV(\n            _party0,\n            _party1,\n            _ccy,\n            _party0PV,\n            _party1PV,\n            _isSettled\n        );\n\n        vars.minMarginReq0 = (vars.total0 * getMinCollateralRate()) / ProtocolTypes.BP;\n        vars.minMarginReq1 = (vars.total1 * getMinCollateralRate()) / ProtocolTypes.BP;\n\n        if (vars.net0 > 0) {\n            vars.req0 = vars.minMarginReq0 >\n                (vars.net0 * getMarginCallThresholdRate()) / ProtocolTypes.BP\n                ? vars.minMarginReq0\n                : vars.net0;\n        } else {\n            vars.req0 = vars.minMarginReq0;\n        }\n\n        if (vars.net1 > 0) {\n            vars.req1 = vars.minMarginReq1 >\n                (vars.net1 * getMarginCallThresholdRate()) / ProtocolTypes.BP\n                ? vars.minMarginReq1\n                : vars.net1;\n        } else {\n            vars.req1 = vars.minMarginReq1;\n        }\n\n        return (vars.req0, vars.req1);\n    }\n\n    struct CoverageCalcLocalVars {\n        uint256 req0;\n        uint256 req1;\n        uint256 cover0;\n        uint256 cover1;\n        uint256 lockedCollateral0;\n        uint256 lockedCollateral1;\n    }\n\n    /**\n     * @dev Triggers to calculate collateral coverage for bilateral position with/without additional PV\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `cover0`, `cover1` uint256 coverage percentages in basis point per counterparty\n     */\n    // TODO: NOW\n    function _calculateCoverage(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) internal view returns (uint256, uint256) {\n        CoverageCalcLocalVars memory vars;\n\n        (vars.req0, vars.req1) = _calculateCollateralRequirements(\n            _party0,\n            _party1,\n            _ccy,\n            _party0PV,\n            _party1PV,\n            _isSettled\n        );\n\n        (vars.lockedCollateral0, vars.lockedCollateral1) = collateralVault()\n            .getTotalLockedCollateralInETH(_party0, _party1);\n\n        if (vars.req0 > 0) {\n            vars.cover0 = (ProtocolTypes.PCT * vars.lockedCollateral0) / vars.req0;\n        }\n\n        if (vars.req1 > 0) {\n            vars.cover1 = (ProtocolTypes.PCT * vars.lockedCollateral1) / vars.req1;\n        }\n\n        return (vars.cover0, vars.cover1);\n    }\n\n    struct RequiredCollateralAdjustmentLocalVars {\n        uint256 targetReq0;\n        uint256 targetReq1;\n        uint256 colAdjustment0;\n        bool isWithdraw0;\n        uint256 colAdjustment1;\n        bool isWithdraw1;\n        uint256 lockedCollateral0;\n        uint256 lockedCollateral1;\n    }\n\n    function _calcCollateralAdjustment(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _amount0,\n        uint256 _amount1,\n        bool _isSettled,\n        bool _safeRebalance\n    )\n        internal\n        view\n        returns (\n            uint256,\n            bool,\n            uint256,\n            bool\n        )\n    {\n        RequiredCollateralAdjustmentLocalVars memory vars;\n\n        (vars.targetReq0, vars.targetReq1) = _calculateCollateralRequirements(\n            _party0,\n            _party1,\n            _ccy,\n            _amount0,\n            _amount1,\n            _isSettled\n        );\n\n        if (_safeRebalance) {\n            vars.targetReq0 = (vars.targetReq0 * getMarginCallThresholdRate()) / ProtocolTypes.BP;\n            vars.targetReq1 = (vars.targetReq1 * getMarginCallThresholdRate()) / ProtocolTypes.BP;\n        }\n\n        (vars.lockedCollateral0, vars.lockedCollateral1) = collateralVault()\n            .getTotalLockedCollateralInETH(_party0, _party1);\n\n        (vars.colAdjustment0, vars.isWithdraw0) = _determineCollateralAdjustment(\n            vars.lockedCollateral0,\n            vars.targetReq0\n        );\n        (vars.colAdjustment1, vars.isWithdraw1) = _determineCollateralAdjustment(\n            vars.lockedCollateral1,\n            vars.targetReq1\n        );\n\n        return (vars.colAdjustment0, vars.isWithdraw0, vars.colAdjustment1, vars.isWithdraw1);\n    }\n\n    function _determineCollateralAdjustment(uint256 _lockedCollateral, uint256 _targetReq)\n        internal\n        pure\n        returns (uint256 amount, bool isWithdraw)\n    {\n        if (_lockedCollateral > 0 && _targetReq > 0) {\n            if (_lockedCollateral > _targetReq) {\n                amount = _lockedCollateral - _targetReq;\n                isWithdraw = true;\n            } else {\n                amount = _targetReq - _lockedCollateral;\n                isWithdraw = false;\n            }\n        } else if (_lockedCollateral > 0 && _targetReq == 0) {\n            amount = _lockedCollateral;\n            isWithdraw = true;\n        } else if (_lockedCollateral == 0 && _targetReq > 0) {\n            amount = _targetReq;\n            isWithdraw = false;\n        }\n\n        return (amount, isWithdraw);\n    }\n\n    struct NetUnsettledExpLocalVars {\n        uint256 totalExp;\n        uint256 ccyExp;\n        uint256 ccyExpInETH;\n        uint256 maxCcy;\n    }\n\n    /**\n     * @dev Triggers to calculate total unsettled exposure across all currencies against all global collateral books.\n     * Also used to calculate hypothetical Net PV with additional exposure in specific `_ccy`\n     * @param _user User's ethereum address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _unsettledExp Additional exposure to lock into unsettled exposure\n     */\n    function _netTotalUnsettledAndHypotheticalPV(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) internal view returns (uint256) {\n        EnumerableSet.Bytes32Set storage expCcy = Storage.slot().exposedUnsettledCurrencies[_user];\n\n        NetUnsettledExpLocalVars memory vars;\n\n        vars.maxCcy = expCcy.length();\n\n        for (uint256 i = 0; i < vars.maxCcy; i++) {\n            bytes32 ccy = expCcy.at(i);\n            vars.ccyExp = Storage.slot().unsettledCollateral[_user][ccy];\n\n            if (_ccy == ccy) {\n                vars.ccyExp = vars.ccyExp + _unsettledExp;\n            }\n\n            vars.ccyExpInETH = currencyController().convertToETH(ccy, vars.ccyExp);\n            vars.totalExp = vars.totalExp + vars.ccyExpInETH;\n        }\n\n        return vars.totalExp;\n    }\n\n    struct UnsettledCoverageLocalVars {\n        uint256 totalExpInETH;\n        uint256 coverage;\n        uint256 independentAmount;\n    }\n\n    function _calculateUnsettledCoverageAndTotalExposure(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) internal view returns (uint256, uint256) {\n        UnsettledCoverageLocalVars memory vars;\n\n        vars.totalExpInETH = _netTotalUnsettledAndHypotheticalPV(_user, _ccy, _unsettledExp);\n        vars.independentAmount = collateralVault().getTotalIndependentCollateralInETH(_user);\n\n        if (vars.totalExpInETH > 0) {\n            vars.coverage = (ProtocolTypes.PCT * vars.independentAmount) / vars.totalExpInETH;\n        } else {\n            return (0, vars.totalExpInETH);\n        }\n\n        return (vars.coverage, vars.totalExpInETH);\n    }\n\n    struct MaxCollateralBookWidthdrawLocalVars {\n        uint256 totalExpInETH;\n        uint256 coverage;\n        uint256 delta;\n        uint256 maxWidthdraw;\n        uint256 independentAmount;\n    }\n\n    /**\n     * @dev Triggers to calculate maximum amount of ETH available to widthdraw from `_user` collateral book\n     * @param _user User's ethereum address\n     *\n     * @return `maxWidthdraw` max widthdrawable amount of ETH\n     */\n    function _calcMaxCollateralWidthdrawFromBook(address _user)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        MaxCollateralBookWidthdrawLocalVars memory vars;\n\n        (vars.coverage, vars.totalExpInETH) = _calculateUnsettledCoverageAndTotalExposure(\n            _user,\n            \"\",\n            0\n        );\n        vars.independentAmount = collateralVault().getTotalIndependentCollateralInETH(_user);\n\n        if (vars.coverage > getMarginCallThresholdRate()) {\n            // TODO: discuss if it makes sense to decrease to 100%\n            vars.delta = vars.coverage - getMarginCallThresholdRate();\n\n            vars.maxWidthdraw = (vars.independentAmount * vars.delta) / vars.coverage;\n        } else if (vars.totalExpInETH == 0) {\n            return (vars.independentAmount, vars.totalExpInETH);\n        } else {\n            return (0, vars.totalExpInETH);\n        }\n\n        return (vars.maxWidthdraw, vars.totalExpInETH);\n    }\n\n    function _rebalanceIfRequired(\n        address _party0,\n        address _party1,\n        bool _safeRebalance\n    ) internal {\n        (\n            uint256 rebalance0,\n            bool isRebalanceFrom0,\n            uint256 rebalance1,\n            bool isRebalanceFrom1\n        ) = _calcCollateralAdjustment(_party0, _party1, \"\", 0, 0, false, _safeRebalance);\n\n        if (rebalance0 > 0) {\n            require(\n                collateralVault().rebalanceCollateral(\n                    _party0,\n                    _party1,\n                    rebalance0,\n                    isRebalanceFrom0\n                ),\n                \"NON_ENOUGH_FUNDS_FOR_REBALANCE\"\n            );\n        }\n\n        if (rebalance1 > 0) {\n            require(\n                collateralVault().rebalanceCollateral(\n                    _party1,\n                    _party0,\n                    rebalance1,\n                    isRebalanceFrom1\n                ),\n                \"NON_ENOUGH_FUNDS_FOR_REBALANCE\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/libraries/NetPV.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./AddressPacking.sol\";\n\nlibrary NetPV {\n    /**\n     * @dev CcyNetting keeps track of total amount of obligations owed\n     * by two counterparties per currency, used to calculate the\n     * total amount of collateral coverage in bilateral position\n     */\n    struct CcyNetting {\n        uint256 unsettled0PV;\n        uint256 unsettled1PV;\n        uint256 party0PV;\n        uint256 party1PV;\n    }\n\n    /**\n     * @dev Helper to return CcyNetting structure in correct order acccording\n     * to in which order counterparty addresses are passed\n     */\n    function _handleFlippedCase(NetPV.CcyNetting memory netting, bool flipped)\n        internal\n        pure\n        returns (NetPV.CcyNetting memory)\n    {\n        if (flipped) {\n            uint256 unsettledPV = netting.unsettled0PV;\n            uint256 partyPV = netting.party0PV;\n\n            netting.unsettled0PV = netting.unsettled1PV;\n            netting.unsettled1PV = unsettledPV;\n            netting.party0PV = netting.party1PV;\n            netting.party1PV = partyPV;\n        }\n\n        return netting;\n    }\n\n    /**\n     * @dev Returns the present value netting between 2 counterparties\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     */\n    function get(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) internal view returns (NetPV.CcyNetting memory netting) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n        netting = self[packedAddrs][ccy];\n        netting = _handleFlippedCase(netting, flipped);\n    }\n\n    /**\n     * @dev Returns the present value netting between 2 counterparties\n     * including hypothetical present value\n     *\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     * @param additionalPV0 Hypothetical PV for first party\n     * @param additionalPV1 Hypothetical PV for second party\n     * @param isSettled Boolean wether hypothetical PV settled or not\n     */\n    function get(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 additionalPV0,\n        uint256 additionalPV1,\n        bool isSettled\n    ) internal view returns (NetPV.CcyNetting memory netting) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n        netting = self[packedAddrs][ccy];\n        netting = _handleFlippedCase(netting, flipped);\n\n        if (isSettled) {\n            netting.party0PV = netting.party0PV + additionalPV0;\n            netting.party1PV = netting.party1PV + additionalPV1;\n        } else {\n            netting.unsettled0PV = netting.unsettled0PV + additionalPV0;\n            netting.unsettled1PV = netting.unsettled1PV + additionalPV1;\n        }\n    }\n\n    /**\n     * @dev Triggers to increase the amount of obligations in PV netting\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     * @param amount0 Amount of funds to be added for first counterparty\n     * @param amount1 Amount of funds to be added for second counterparty\n     * @param isSettled Boolean statement if obligations are settled already\n     */\n    function use(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n        NetPV.CcyNetting storage netting = self[packedAddrs][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                if (isSettled) {\n                    netting.party0PV = netting.party0PV + amount0;\n                } else {\n                    netting.unsettled0PV = netting.unsettled0PV + amount0;\n                }\n            }\n            if (amount1 > 0) {\n                if (isSettled) {\n                    netting.party1PV = netting.party1PV + amount1;\n                } else {\n                    netting.unsettled1PV = netting.unsettled1PV + amount1;\n                }\n            }\n        } else {\n            if (amount0 > 0) {\n                if (isSettled) {\n                    netting.party1PV = netting.party1PV + amount0;\n                } else {\n                    netting.unsettled1PV = netting.unsettled1PV + amount0;\n                }\n            }\n            if (amount1 > 0) {\n                if (isSettled) {\n                    netting.party0PV = netting.party0PV + amount1;\n                } else {\n                    netting.unsettled0PV = netting.unsettled0PV + amount1;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Triggers to settle previously added obligations in PV netting\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     * @param amount0 Amount of funds to be settled for first counterparty\n     * @param amount1 Amount of funds to be settled for second counterparty\n     */\n    function settle(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n        NetPV.CcyNetting storage netting = self[packedAddrs][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                netting.unsettled0PV = netting.unsettled0PV - amount0;\n                netting.party0PV = netting.party0PV + amount0;\n            }\n            if (amount1 > 0) {\n                netting.unsettled1PV = netting.unsettled1PV - amount1;\n                netting.party1PV = netting.party1PV + amount1;\n            }\n        } else {\n            if (amount0 > 0) {\n                netting.unsettled1PV = netting.unsettled1PV - amount0;\n                netting.party1PV = netting.party1PV + amount0;\n            }\n            if (amount1 > 0) {\n                netting.unsettled0PV = netting.unsettled0PV - amount1;\n                netting.party0PV = netting.party0PV + amount1;\n            }\n        }\n    }\n\n    /**\n     * @dev Triggers to release PV obligations from netting\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     * @param amount0 Amount of funds to be removed for first counterparty\n     * @param amount1 Amount of funds to be removed for second counterparty\n     */\n    function release(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n        NetPV.CcyNetting storage netting = self[packedAddrs][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                if (isSettled) {\n                    netting.party0PV = netting.party0PV - amount0;\n                } else {\n                    netting.unsettled0PV = netting.unsettled0PV - amount0;\n                }\n            }\n            if (amount1 > 0) {\n                if (isSettled) {\n                    netting.party1PV = netting.party1PV - amount1;\n                } else {\n                    netting.unsettled1PV = netting.unsettled1PV - amount1;\n                }\n            }\n        } else {\n            if (amount0 > 0) {\n                if (isSettled) {\n                    netting.party1PV = netting.party1PV - amount0;\n                } else {\n                    netting.unsettled1PV = netting.unsettled1PV - amount0;\n                }\n            }\n            if (amount1 > 0) {\n                if (isSettled) {\n                    netting.party0PV = netting.party0PV - amount1;\n                } else {\n                    netting.unsettled0PV = netting.unsettled0PV - amount1;\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Triggers to update PV in bilateral netting during mark-to-market\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     * @param prevPV0 Previous present value to be substracted from total exposure for counterparty A\n     * @param prevPV1 Previous present value to be substracted from total exposure for counterparty B\n     * @param currentPV0 Current present value to be added to total exposure for counterparty A\n     * @param currentPV1 Current present value to be added to total exposure for counterparty B\n     */\n    function update(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n        NetPV.CcyNetting storage netting = self[packedAddrs][ccy];\n\n        if (!flipped) {\n            if (currentPV0 > 0) {\n                netting.party0PV = netting.party0PV - prevPV0 + currentPV0;\n            }\n            if (currentPV1 > 0) {\n                netting.party1PV = netting.party1PV - prevPV1 + currentPV1;\n            }\n        } else {\n            if (currentPV0 > 0) {\n                netting.party1PV = netting.party1PV - prevPV0 + currentPV0;\n            }\n            if (currentPV1 > 0) {\n                netting.party0PV = netting.party0PV - prevPV1 + currentPV1;\n            }\n        }\n    }\n\n    /**\n     * @dev Clears the state of PV netting\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     */\n    function clear(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) internal {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        delete self[packedAddrs][ccy];\n    }\n}\n"
    },
    "contracts/mixins/MixinCollateralManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../interfaces/IMixinCollateralManagement.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../utils/Proxyable.sol\";\nimport {CollateralAggregatorStorage as Storage} from \"../storages/CollateralAggregatorStorage.sol\";\nimport \"./MixinAddressResolver.sol\";\n\n/**\n * @title MixinCollateralManagement is an internal component of CollateralAggregator contract\n *\n * This contract allows Secured Finance manage the collateral system such as:\n *\n * 1. Update CurrencyController and LiquidationEngine addresses\n * 2. Add different products implementation contracts as collateral users\n * 3. Link deployed collateral vaults\n * 4. Update main collateral parameters like Margin Call ratio,\n *    Auto-Liquidation level, Liquidation price, and Minimal collateral ratio\n *\n */\ncontract MixinCollateralManagement is\n    IMixinCollateralManagement,\n    MixinAddressResolver,\n    Ownable,\n    Proxyable\n{\n    using Address for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /**\n     * @dev Modifier to check if msg.sender is the Liquidations\n     */\n    modifier onlyLiquidations() {\n        require(msg.sender == address(liquidations()), \"Caller is not the liquidations\");\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(\n        address owner,\n        address resolver,\n        uint256 marginCallThresholdRate,\n        uint256 autoLiquidationThresholdRate,\n        uint256 liquidationPriceRate,\n        uint256 minCollateralRate\n    ) public initializer onlyProxy {\n        _transferOwnership(owner);\n        registerAddressResolver(resolver);\n        _updateMarginCallThresholdRate(marginCallThresholdRate);\n        _updateAutoLiquidationThresholdRate(autoLiquidationThresholdRate);\n        _updateLiquidationPriceRate(liquidationPriceRate);\n        _updateMinCollateralRate(minCollateralRate);\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](5);\n        contracts[0] = Contracts.COLLATERAL_VAULT;\n        contracts[1] = Contracts.CROSSCHAIN_ADDRESS_RESOLVER;\n        contracts[2] = Contracts.CURRENCY_CONTROLLER;\n        contracts[3] = Contracts.LIQUIDATIONS;\n        contracts[4] = Contracts.PRODUCT_ADDRESS_RESOLVER;\n    }\n\n    function isAcceptedContract(address account) internal view override returns (bool) {\n        return\n            isCollateralUser(account) ||\n            productAddressResolver().isRegisteredProductContract(account) ||\n            super.isAcceptedContract(account);\n    }\n\n    /**\n     * @dev Triggers to add contract address to collateral users address set\n     * @param _user Collateral user smart contract address\n     *\n     * @notice Trifgers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function addCollateralUser(address _user) public override onlyOwner returns (bool) {\n        require(_user != address(0), \"Zero address\");\n        require(_user.isContract(), \"Can't add non-contract address\");\n        require(!Storage.slot().collateralUsers.contains(_user), \"Can't add existing address\");\n\n        emit CollateralUserAdded(_user);\n\n        return Storage.slot().collateralUsers.add(_user);\n    }\n\n    /**\n     * @dev Triggers to remove collateral user from address set\n     * @param _user Collateral user smart contract address\n     *\n     * @notice Triggers only be contract owner\n     * @notice Reverts on removing non-existing collateral user\n     */\n    function removeCollateralUser(address _user) public override onlyOwner returns (bool) {\n        require(Storage.slot().collateralUsers.contains(_user), \"Can't remove non-existing user\");\n\n        emit CollateralUserRemoved(_user);\n        return Storage.slot().collateralUsers.remove(_user);\n    }\n\n    /**\n     * @dev Triggers to check if provided `addr` is a CollateralUser from address set\n     * @param _user Contract address to check if it's a CollateralUser\n     */\n    function isCollateralUser(address _user) public view override returns (bool) {\n        return Storage.slot().collateralUsers.contains(_user);\n    }\n\n    /**\n     * @dev Triggers to safely update main collateral parameters this function\n     * solves the issue of frontrunning during parameters tuning\n     *\n     * @param _marginCallThresholdRate Margin call threshold ratio\n     * @param _autoLiquidationThresholdRate Auto liquidation threshold rate\n     * @param _liquidationPriceRate Liquidation price rate\n     * @notice Triggers only be contract owner\n     */\n    function updateMainParameters(\n        uint256 _marginCallThresholdRate,\n        uint256 _autoLiquidationThresholdRate,\n        uint256 _liquidationPriceRate\n    ) public override onlyOwner {\n        if (_marginCallThresholdRate != Storage.slot().marginCallThresholdRate) {\n            _updateMarginCallThresholdRate(_marginCallThresholdRate);\n        }\n\n        if (_autoLiquidationThresholdRate != Storage.slot().autoLiquidationThresholdRate) {\n            _updateAutoLiquidationThresholdRate(_autoLiquidationThresholdRate);\n        }\n\n        if (_liquidationPriceRate != Storage.slot().liquidationPriceRate) {\n            _updateLiquidationPriceRate(_liquidationPriceRate);\n        }\n    }\n\n    /**\n     * @dev Triggers to update liquidation level rate\n     * @param _rate Auto Liquidation level rate\n     * @notice Triggers only be contract owner\n     */\n    function updateAutoLiquidationThresholdRate(uint256 _rate) public override onlyOwner {\n        _updateAutoLiquidationThresholdRate(_rate);\n    }\n\n    /**\n     * @dev Triggers to update margin call level\n     * @param _rate Margin call rate\n     * @notice Triggers only be contract owner\n     */\n    function updateMarginCallThresholdRate(uint256 _rate) public override onlyOwner {\n        _updateMarginCallThresholdRate(_rate);\n    }\n\n    /**\n     * @dev Triggers to update liquidation price rate\n     * @param _rate Liquidation price rate in basis point\n     * @notice Triggers only be contract owner\n     */\n    function updateLiquidationPriceRate(uint256 _rate) public override onlyOwner {\n        _updateLiquidationPriceRate(_rate);\n    }\n\n    /**\n     * @dev Triggers to update minimal collateral rate\n     * @param _rate Minimal collateral rate in basis points\n     * @notice Triggers only be contract owner\n     */\n    function updateMinCollateralRate(uint256 _rate) public override onlyOwner {\n        _updateMinCollateralRate(_rate);\n    }\n\n    /**\n     * @dev Triggers to get auto liquidation threshold rate\n     */\n    function getAutoLiquidationThresholdRate() public view override returns (uint256) {\n        return Storage.slot().autoLiquidationThresholdRate;\n    }\n\n    /**\n     * @dev Triggers to get liquidation price rate\n     */\n    function getLiquidationPriceRate() public view override returns (uint256) {\n        return Storage.slot().liquidationPriceRate;\n    }\n\n    /**\n     * @dev Triggers to get margin call threshold rate\n     */\n    function getMarginCallThresholdRate() public view override returns (uint256) {\n        return Storage.slot().marginCallThresholdRate;\n    }\n\n    /**\n     * @dev Triggers to get min collateral rate\n     */\n    function getMinCollateralRate() public view override returns (uint256) {\n        return Storage.slot().minCollateralRate;\n    }\n\n    function _updateAutoLiquidationThresholdRate(uint256 _rate) private {\n        require(_rate > 0, \"INCORRECT_RATIO\");\n        require(_rate < Storage.slot().marginCallThresholdRate, \"AUTO_LIQUIDATION_RATIO_OVERFLOW\");\n\n        emit AutoLiquidationThresholdRateUpdated(\n            Storage.slot().autoLiquidationThresholdRate,\n            _rate\n        );\n        Storage.slot().autoLiquidationThresholdRate = _rate;\n    }\n\n    function _updateMarginCallThresholdRate(uint256 _rate) private {\n        require(_rate > 0, \"INCORRECT_RATIO\");\n\n        emit MarginCallThresholdRateUpdated(Storage.slot().marginCallThresholdRate, _rate);\n        Storage.slot().marginCallThresholdRate = _rate;\n    }\n\n    function _updateLiquidationPriceRate(uint256 _rate) private {\n        require(_rate > 0, \"INCORRECT_RATIO\");\n        require(_rate < Storage.slot().autoLiquidationThresholdRate, \"LIQUIDATION_PRICE_OVERFLOW\");\n\n        emit LiquidationPriceRateUpdated(Storage.slot().liquidationPriceRate, _rate);\n        Storage.slot().liquidationPriceRate = _rate;\n    }\n\n    function _updateMinCollateralRate(uint256 _rate) private {\n        require(_rate > 0, \"INCORRECT_RATIO\");\n        require(\n            _rate < Storage.slot().autoLiquidationThresholdRate,\n            \"MIN_COLLATERAL_RATIO_OVERFLOW\"\n        );\n\n        emit MinCollateralRateUpdated(Storage.slot().minCollateralRate, _rate);\n        Storage.slot().minCollateralRate = _rate;\n    }\n}\n"
    },
    "contracts/interfaces/IMixinCollateralManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IMixinCollateralManagement {\n    event CollateralUserAdded(address indexed user);\n    event CollateralUserRemoved(address indexed user);\n\n    event CurrencyControllerUpdated(address indexed controller);\n    event LiquidationEngineUpdated(address indexed liquidations);\n    event CrosschainAddressResolverUpdated(address indexed crosschainAddressResolver);\n\n    event LiquidationPriceRateUpdated(uint256 previousPrice, uint256 price);\n    event AutoLiquidationThresholdRateUpdated(uint256 previousRatio, uint256 ratio);\n    event MarginCallThresholdRateUpdated(uint256 previousRatio, uint256 ratio);\n    event MinCollateralRateUpdated(uint256 previousRatio, uint256 price);\n\n    function getAutoLiquidationThresholdRate() external view returns (uint256);\n\n    function getLiquidationPriceRate() external view returns (uint256);\n\n    function getMarginCallThresholdRate() external view returns (uint256);\n\n    function getMinCollateralRate() external view returns (uint256);\n\n    function addCollateralUser(address _user) external returns (bool);\n\n    function removeCollateralUser(address _user) external returns (bool);\n\n    function isCollateralUser(address _user) external view returns (bool);\n\n    function updateMainParameters(\n        uint256 _marginCallThresholdRate,\n        uint256 _autoLiquidationThresholdRate,\n        uint256 _liquidationPriceRate\n    ) external;\n\n    function updateLiquidationPriceRate(uint256 _price) external;\n\n    function updateAutoLiquidationThresholdRate(uint256 _ratio) external;\n\n    function updateMarginCallThresholdRate(uint256 _ratio) external;\n\n    function updateMinCollateralRate(uint256 _ratio) external;\n}\n"
    },
    "contracts/storages/CollateralAggregatorStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../libraries/NetPV.sol\";\n\nlibrary CollateralAggregatorStorage {\n    using Address for address;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using NetPV for NetPV.CcyNetting;\n\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.collateralAggregator\");\n\n    struct Storage {\n        // Mapping for total amount of collateral locked against independent collateral from all books.\n        mapping(address => mapping(bytes32 => uint256)) unsettledCollateral;\n        // Mapping for used currencies in unsettled exposures.\n        mapping(address => EnumerableSet.Bytes32Set) exposedUnsettledCurrencies;\n        // Mapping for all registered users.\n        mapping(address => bool) isRegistered;\n        // Mapping for used currencies set in bilateral position.\n        mapping(bytes32 => EnumerableSet.Bytes32Set) exposedCurrencies;\n        // Mapping for exposures per currency in bilateral position.\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) ccyNettings;\n        // storages for MixinCollateralManagement\n        EnumerableSet.AddressSet collateralUsers;\n        // liquidation price rate in basis point\n        uint256 liquidationPriceRate;\n        // margin call threshold rate in basis point\n        uint256 marginCallThresholdRate;\n        // auto liquidation threshold rate in basis point\n        uint256 autoLiquidationThresholdRate;\n        //  minimal collateral rate in basis point\n        uint256 minCollateralRate;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "contracts/test/NetPVTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/NetPV.sol\";\n\ncontract NetPVTest {\n    mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) private _ccyNettings;\n    bytes32 public ccy = \"0xSampleCCY\";\n\n    function get(address party0, address party1)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        NetPV.CcyNetting memory netting = _get(party0, party1);\n\n        return (netting.unsettled0PV, netting.unsettled1PV, netting.party0PV, netting.party1PV);\n    }\n\n    function getGasCostOfGet(address party0, address party1) public view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        _get(party0, party1);\n\n        return gasBefore - gasleft();\n    }\n\n    function _get(address party0, address party1) internal view returns (NetPV.CcyNetting memory) {\n        return NetPV.get(_ccyNettings, party0, party1, ccy);\n    }\n\n    function use(\n        address party0,\n        address party1,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) public {\n        NetPV.CcyNetting memory nettingBefore = _get(party0, party1);\n\n        NetPV.use(_ccyNettings, party0, party1, ccy, amount0, amount1, isSettled);\n\n        NetPV.CcyNetting memory nettingAfter = _get(party0, party1);\n\n        if (isSettled) {\n            require(\n                nettingAfter.party0PV == nettingBefore.party0PV + amount0 &&\n                    nettingAfter.party1PV == nettingBefore.party1PV + amount1,\n                \"INCORRECT_CCY_NETTING_USE\"\n            );\n        } else {\n            require(\n                nettingAfter.unsettled0PV == nettingBefore.unsettled0PV + amount0 &&\n                    nettingAfter.unsettled1PV == nettingBefore.unsettled1PV + amount1,\n                \"INCORRECT_CCY_NETTING_USE\"\n            );\n        }\n    }\n\n    function settle(\n        address party0,\n        address party1,\n        uint256 amount0,\n        uint256 amount1\n    ) public {\n        NetPV.CcyNetting memory nettingBefore = _get(party0, party1);\n\n        NetPV.settle(_ccyNettings, party0, party1, ccy, amount0, amount1);\n\n        NetPV.CcyNetting memory nettingAfter = _get(party0, party1);\n\n        require(\n            nettingAfter.unsettled0PV == nettingBefore.unsettled0PV - amount0 &&\n                nettingAfter.party0PV == nettingBefore.party0PV + amount0,\n            \"INCORRECT_CCY_NETTING_SETTLE\"\n        );\n\n        require(\n            nettingAfter.unsettled1PV == nettingBefore.unsettled1PV - amount1 &&\n                nettingAfter.party1PV == nettingBefore.party1PV + amount1,\n            \"INCORRECT_CCY_NETTING_SETTLE\"\n        );\n    }\n\n    function release(\n        address party0,\n        address party1,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) public {\n        NetPV.CcyNetting memory nettingBefore = _get(party0, party1);\n\n        NetPV.release(_ccyNettings, party0, party1, ccy, amount0, amount1, isSettled);\n\n        NetPV.CcyNetting memory nettingAfter = _get(party0, party1);\n\n        if (isSettled) {\n            require(\n                nettingAfter.party0PV == nettingBefore.party0PV - amount0 &&\n                    nettingAfter.party1PV == nettingBefore.party1PV - amount1,\n                \"INCORRECT_CCY_NETTING_RELEASE\"\n            );\n        } else {\n            require(\n                nettingAfter.unsettled0PV == nettingBefore.unsettled0PV - amount0 &&\n                    nettingAfter.unsettled1PV == nettingBefore.unsettled1PV - amount1,\n                \"INCORRECT_CCY_NETTING_RELEASE\"\n            );\n        }\n    }\n\n    function update(\n        address party0,\n        address party1,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) public {\n        NetPV.CcyNetting memory nettingBefore = _get(party0, party1);\n\n        NetPV.update(_ccyNettings, party0, party1, ccy, prevPV0, prevPV1, currentPV0, currentPV1);\n\n        NetPV.CcyNetting memory nettingAfter = _get(party0, party1);\n\n        require(\n            nettingAfter.party0PV == nettingBefore.party0PV - prevPV0 + currentPV0,\n            \"INCORRECT_CCY_NETTING_UPDATE\"\n        );\n\n        require(\n            nettingAfter.party1PV == nettingBefore.party1PV - prevPV1 + currentPV1,\n            \"INCORRECT_CCY_NETTING_SETTLE\"\n        );\n    }\n\n    function clear(address party0, address party1) public {\n        NetPV.clear(_ccyNettings, party0, party1, ccy);\n        NetPV.CcyNetting memory netting = _get(party0, party1);\n\n        require(\n            netting.unsettled0PV == 0 &&\n                netting.unsettled1PV == 0 &&\n                netting.party0PV == 0 &&\n                netting.party1PV == 0,\n            \"INCORRECT_POSITION_CLEAR\"\n        );\n    }\n}\n"
    },
    "contracts/mocks/CollateralAggregatorCallerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../interfaces/ICollateralAggregatorV2.sol\";\n\ncontract CollateralAggregatorCallerMock {\n    ICollateralAggregator public collateralAggregator;\n\n    constructor(address _collateralAggregator) {\n        collateralAggregator = ICollateralAggregator(_collateralAggregator);\n    }\n\n    function useUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) public {\n        collateralAggregator.useUnsettledCollateral(user, ccy, amount);\n    }\n\n    function useCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) public {\n        collateralAggregator.useCollateral(partyA, partyB, ccy, amount0, amount1, isSettled);\n    }\n\n    function settleCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    ) public {\n        collateralAggregator.settleCollateral(partyA, partyB, ccy, amount0, amount1);\n    }\n\n    function releaseUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) public {\n        collateralAggregator.releaseUnsettledCollateral(user, ccy, amount);\n    }\n\n    function releaseCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) public {\n        collateralAggregator.releaseCollateral(partyA, partyB, ccy, amount0, amount1, isSettled);\n    }\n\n    function updatePV(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) external {\n        collateralAggregator.updatePV(\n            partyA,\n            partyB,\n            ccy,\n            prevPV0,\n            prevPV1,\n            currentPV0,\n            currentPV1\n        );\n    }\n\n    function liquidate(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 liquidationAmount,\n        uint256 pvForRelease,\n        bool isSettled\n    ) external {\n        collateralAggregator.liquidate(from, to, ccy, liquidationAmount, pvForRelease, isSettled);\n    }\n\n    function liquidate(\n        address from,\n        address to,\n        uint256 liquidationInETH\n    ) external {\n        collateralAggregator.liquidate(from, to, liquidationInETH);\n    }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialAccount,\n        uint256 initialBalance\n    ) payable ERC20(name, symbol) {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n\n    function transferInternal(\n        address from,\n        address to,\n        uint256 value\n    ) public {\n        _transfer(from, to, value);\n    }\n\n    function approveInternal(\n        address owner,\n        address spender,\n        uint256 value\n    ) public {\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/mocks/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title MockV3Aggregator\n * @notice Based on the FluxAggregator contract\n * @notice Use this contract when you need to test\n * other contract's ability to read data from an\n * aggregator contract, but how the aggregator got\n * its answer is unimportant\n */\ncontract MockV3Aggregator is AggregatorV2V3Interface, Ownable {\n    uint256 public constant override version = 0;\n\n    bytes32 public priceFeedCcy;\n    uint8 public override decimals;\n    int256 public override latestAnswer;\n    uint256 public override latestTimestamp;\n    uint256 public override latestRound;\n\n    mapping(uint256 => int256) public override getAnswer;\n    mapping(uint256 => uint256) public override getTimestamp;\n    mapping(uint256 => uint256) private getStartedAt;\n\n    constructor(\n        uint8 _decimals,\n        bytes32 _ccy,\n        int256 _initialAnswer\n    ) Ownable() {\n        priceFeedCcy = _ccy;\n        decimals = _decimals;\n        updateAnswer(_initialAnswer);\n    }\n\n    function updateAnswer(int256 _answer) public onlyOwner {\n        latestAnswer = _answer;\n        latestTimestamp = block.timestamp;\n        latestRound++;\n        getAnswer[latestRound] = _answer;\n        getTimestamp[latestRound] = block.timestamp;\n        getStartedAt[latestRound] = block.timestamp;\n    }\n\n    function updateRoundData(\n        uint80 _roundId,\n        int256 _answer,\n        uint256 _timestamp,\n        uint256 _startedAt\n    ) public onlyOwner {\n        latestRound = _roundId;\n        latestAnswer = _answer;\n        latestTimestamp = _timestamp;\n        getAnswer[latestRound] = _answer;\n        getTimestamp[latestRound] = _timestamp;\n        getStartedAt[latestRound] = _startedAt;\n    }\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (\n            _roundId,\n            getAnswer[_roundId],\n            getStartedAt[_roundId],\n            getTimestamp[_roundId],\n            _roundId\n        );\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (\n            uint80(latestRound),\n            getAnswer[latestRound],\n            getStartedAt[latestRound],\n            getTimestamp[latestRound],\n            uint80(latestRound)\n        );\n    }\n\n    function description() external pure override returns (string memory) {\n        return \"v0.7/tests/MockV3Aggregator.sol\";\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/storages/CurrencyControllerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../types/ProtocolTypes.sol\";\n\nlibrary CurrencyControllerStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.currencyController\");\n\n    struct Storage {\n        // Protocol currencies\n        mapping(bytes32 => ProtocolTypes.Currency) currencies;\n        mapping(bytes32 => uint256) haircuts;\n        mapping(bytes32 => uint256) minMargins;\n        mapping(bytes32 => bool) isCollateral;\n        mapping(bytes32 => address) tokenAddresses;\n        // PriceFeed\n        mapping(bytes32 => AggregatorV3Interface) usdPriceFeeds;\n        mapping(bytes32 => AggregatorV3Interface) ethPriceFeeds;\n        mapping(bytes32 => uint8) usdDecimals;\n        mapping(bytes32 => uint8) ethDecimals;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "contracts/CurrencyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/ICurrencyController.sol\";\nimport \"./utils/Ownable.sol\";\nimport \"./utils/Proxyable.sol\";\nimport {CurrencyControllerStorage as Storage} from \"./storages/CurrencyControllerStorage.sol\";\n\n/**\n * @dev Currency Controller contract is responsible for managing supported\n * currencies in Secured Finance Protocol\n *\n * Contract links new currencies to ETH Chainlink price feeds, without existing price feed\n * contract owner is not able to add a new currency into the protocol\n */\ncontract CurrencyController is ICurrencyController, Ownable, Proxyable {\n    modifier supportedCcyOnly(bytes32 _ccy) {\n        require(isSupportedCcy(_ccy), \"Unsupported asset\");\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(address owner) public initializer onlyProxy {\n        _transferOwnership(owner);\n    }\n\n    // =========== CURRENCY CONTROL SECTION ===========\n\n    /**\n     * @dev Triggers to add new currency into the protocol. Links with existing ETH chainlink pricefeed\n     * @param _ccy Currency short ticket\n     * @param _name Currency full name\n     * @param _chainId Chain ID for conversion from bytes32 to bytes\n     * @param _ethPriceFeed Address for ETH price feed\n     */\n    function supportCurrency(\n        bytes32 _ccy,\n        string memory _name,\n        uint16 _chainId,\n        address _ethPriceFeed,\n        uint256 _haircut,\n        address _tokenAddress\n    ) public override onlyOwner {\n        ProtocolTypes.Currency memory currency;\n        currency.name = _name;\n        if (_chainId != 0) {\n            currency.chainId = _chainId;\n        }\n\n        if (_tokenAddress != address(0)) {\n            Storage.slot().tokenAddresses[_ccy] = _tokenAddress;\n        }\n\n        currency.isSupported = true;\n\n        Storage.slot().currencies[_ccy] = currency;\n        Storage.slot().haircuts[_ccy] = _haircut;\n\n        if (_ccy != \"ETH\") {\n            require(linkPriceFeed(_ccy, _ethPriceFeed, true), \"Invalid PriceFeed\");\n        } else {\n            require(linkPriceFeed(_ccy, _ethPriceFeed, false), \"Invalid PriceFeed\");\n        }\n        emit CcyAdded(_ccy, _name, _chainId, _haircut);\n    }\n\n    /**\n     * @dev Triggers to update currency support\n     * @param _ccy Currency short ticket\n     * @param _isSupported Boolean whether currency supported as collateral or not\n     */\n    function updateCurrencySupport(bytes32 _ccy, bool _isSupported) public override onlyOwner {\n        ProtocolTypes.Currency storage currency = Storage.slot().currencies[_ccy];\n        currency.isSupported = _isSupported;\n\n        emit CcySupportUpdate(_ccy, _isSupported);\n    }\n\n    /**\n     * @dev Triggers to update if currency is accepted as collateral\n     * @param _ccy Currency short ticket\n     * @param _isSupported Boolean whether currency supported as collateral or not\n     */\n    function updateCollateralSupport(bytes32 _ccy, bool _isSupported)\n        public\n        override\n        onlyOwner\n        supportedCcyOnly(_ccy)\n    {\n        Storage.slot().isCollateral[_ccy] = _isSupported;\n\n        emit CcyCollateralUpdate(_ccy, _isSupported);\n    }\n\n    /**\n     * @dev Triggers to update the haircut ratio for supported currency\n     * @param _ccy Currency short ticket\n     * @param _haircut Currency haircut ratio used to calculate in collateral calculations\n     */\n    function updateCcyHaircut(bytes32 _ccy, uint256 _haircut)\n        public\n        override\n        onlyOwner\n        supportedCcyOnly(_ccy)\n    {\n        require(_haircut > 0, \"Incorrect haircut ratio\");\n        require(_haircut <= 10000, \"Haircut ratio overflow\");\n\n        Storage.slot().haircuts[_ccy] = _haircut;\n\n        emit HaircutUpdated(_ccy, _haircut);\n    }\n\n    /**\n     * @dev Triggers to update the minimal margin requirements for currency supported as collateral\n     * @param _ccy Currency short ticket\n     * @param _minMargin Currency minimal margin ratio used to calculate collateral coverage\n     */\n    function updateMinMargin(bytes32 _ccy, uint256 _minMargin)\n        public\n        override\n        onlyOwner\n        supportedCcyOnly(_ccy)\n    {\n        require(_minMargin > 0, \"Incorrect MinMargin\");\n        require(_minMargin <= 10000, \"MinMargin overflow\");\n        require(isCollateral(_ccy), \"Unable to set MinMargin\");\n\n        Storage.slot().minMargins[_ccy] = _minMargin;\n\n        emit MinMarginUpdated(_ccy, _minMargin);\n    }\n\n    // =========== EXTERNAL GET FUNCTIONS ===========\n\n    /**\n     * @dev Triggers to get specified currency.\n     * @param _ccy Currency short ticket\n     */\n    function getCurrencies(bytes32 _ccy)\n        external\n        view\n        returns (ProtocolTypes.Currency memory currency)\n    {\n        currency = Storage.slot().currencies[_ccy];\n    }\n\n    /**\n     * @dev Triggers to get ETH decimal for specific currency.\n     * @param _ccy Currency short ticket\n     */\n    function getEthDecimals(bytes32 _ccy) external view returns (uint8) {\n        return Storage.slot().ethDecimals[_ccy];\n    }\n\n    /**\n     * @dev Triggers to get USD decimal for specific currency.\n     * @param _ccy Currency short ticket\n     */\n    function getUsdDecimals(bytes32 _ccy) external view returns (uint8) {\n        return Storage.slot().usdDecimals[_ccy];\n    }\n\n    /**\n     * @dev Triggers to get haircut ratio for specific currency.\n     * Haircut is used in bilateral netting cross-calculation.\n     * @param _ccy Currency short ticket\n     */\n    function getHaircut(bytes32 _ccy) external view override returns (uint256) {\n        return Storage.slot().haircuts[_ccy];\n    }\n\n    /**\n     * @dev Triggers to get minimal margin percentage for specific currency.\n     * @param _ccy Currency short ticket\n     */\n    function getMinMargin(bytes32 _ccy) external view override returns (uint256) {\n        require(isCollateral(_ccy), \"Unable to get MinMargin\");\n        return Storage.slot().minMargins[_ccy];\n    }\n\n    /**\n     * @dev Triggers to get token address for specific currency.\n     * @param _ccy Currency short ticket\n     */\n    function getTokenAddresses(bytes32 _ccy) external view returns (address) {\n        return Storage.slot().tokenAddresses[_ccy];\n    }\n\n    /**\n     * @dev Triggers to get if specified currency is supported.\n     * @param _ccy Currency short ticket\n     */\n    function isSupportedCcy(bytes32 _ccy) public view override returns (bool) {\n        return Storage.slot().currencies[_ccy].isSupported;\n    }\n\n    /**\n     * @dev Triggers to get if specified currency is collateral.\n     * @param _ccy Currency short ticket\n     */\n    function isCollateral(bytes32 _ccy) public view returns (bool) {\n        return Storage.slot().isCollateral[_ccy];\n    }\n\n    /**\n     * @dev Triggers to get chainId for a specific currency.\n     * Chain ID is a unique identifier of another chain like Bitcoin, Filecoin, etc.\n     * @param _ccy Currency short ticket\n     */\n    function getChainId(bytes32 _ccy) external view override returns (uint16) {\n        return Storage.slot().currencies[_ccy].chainId;\n    }\n\n    // =========== CHAINLINK PRICE FEED FUNCTIONS ===========\n    // TODO: add additional price feeds in case if chainlink is not reliable\n\n    /**\n     * @dev Links the contract to existing chainlink price feed.\n     * @param _ccy Specified currency short code\n     * @param _priceFeedAddr Chainlink price feed contract address\n     * @param _isEthPriceFeed Boolean for price feed with ETH price\n     */\n    function linkPriceFeed(\n        bytes32 _ccy,\n        address _priceFeedAddr,\n        bool _isEthPriceFeed\n    ) public override onlyOwner returns (bool) {\n        require(_priceFeedAddr != address(0), \"Couldn't link 0x0 address\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(_priceFeedAddr);\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        require(price >= 0, \"Invalid PriceFeed\");\n\n        uint8 decimals = priceFeed.decimals();\n        require(decimals <= 18, \"Invalid decimals\");\n\n        if (_isEthPriceFeed) {\n            require(!_isETH(_ccy), \"Can't link to ETH\");\n            Storage.slot().ethPriceFeeds[_ccy] = priceFeed;\n            Storage.slot().ethDecimals[_ccy] = decimals;\n            emit PriceFeedAdded(_ccy, \"ETH\", _priceFeedAddr);\n        } else {\n            Storage.slot().usdPriceFeeds[_ccy] = priceFeed;\n            Storage.slot().usdDecimals[_ccy] = decimals;\n            emit PriceFeedAdded(_ccy, \"USD\", _priceFeedAddr);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Triggers to remove existing chainlink price feed.\n     * @param _ccy Specified currency\n     * @param _isEthPriceFeed Boolean for price feed with ETH price\n     */\n    function removePriceFeed(bytes32 _ccy, bool _isEthPriceFeed)\n        external\n        override\n        onlyOwner\n        supportedCcyOnly(_ccy)\n    {\n        if (_isEthPriceFeed == true) {\n            address priceFeed = address(Storage.slot().ethPriceFeeds[_ccy]);\n\n            require(priceFeed != address(0), \"Invalid PriceFeed\");\n            delete Storage.slot().ethPriceFeeds[_ccy];\n            delete Storage.slot().ethDecimals[_ccy];\n\n            emit PriceFeedRemoved(_ccy, \"ETH\", priceFeed);\n        } else {\n            address priceFeed = address(Storage.slot().usdPriceFeeds[_ccy]);\n\n            require(priceFeed != address(0), \"Invalid PriceFeed\");\n            delete Storage.slot().usdPriceFeeds[_ccy];\n            delete Storage.slot().usdDecimals[_ccy];\n\n            emit PriceFeedRemoved(_ccy, \"USD\", priceFeed);\n        }\n    }\n\n    // =========== GET PRICE FUNCTIONS ===========\n\n    /**\n     * @dev Triggers to get last price in USD for selected currency.\n     * @param _ccy Currency\n     */\n    function getLastUSDPrice(bytes32 _ccy) public view override returns (int256) {\n        AggregatorV3Interface priceFeed = Storage.slot().usdPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get historical price in USD for selected currency.\n     * @param _ccy Currency\n     * @param _roundId RoundId\n     */\n    function getHistoricalUSDPrice(bytes32 _ccy, uint80 _roundId)\n        public\n        view\n        override\n        returns (int256)\n    {\n        AggregatorV3Interface priceFeed = Storage.slot().usdPriceFeeds[_ccy];\n        (, int256 price, , uint256 timeStamp, ) = priceFeed.getRoundData(_roundId);\n\n        require(timeStamp > 0, \"Round not completed yet\");\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get last price in ETH for selected currency.\n     * @param _ccy Currency\n     */\n    function getLastETHPrice(bytes32 _ccy) public view override returns (int256) {\n        if (_isETH(_ccy)) return 1e18;\n\n        AggregatorV3Interface priceFeed = Storage.slot().ethPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get historical price in ETH for selected currency.\n     * @param _ccy Currency\n     * @param _roundId RoundId\n     */\n    function getHistoricalETHPrice(bytes32 _ccy, uint80 _roundId)\n        public\n        view\n        override\n        returns (int256)\n    {\n        if (_isETH(_ccy)) return 1e18;\n\n        AggregatorV3Interface priceFeed = Storage.slot().ethPriceFeeds[_ccy];\n        (, int256 price, , uint256 timeStamp, ) = priceFeed.getRoundData(_roundId);\n\n        require(timeStamp > 0, \"Round not completed yet\");\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get converted amount of currency in ETH.\n     * @param _ccy Currency that has to be convered to ETH\n     * @param _amount Amount of funds to be converted\n     */\n    function convertToETH(bytes32 _ccy, uint256 _amount) public view override returns (uint256) {\n        if (_isETH(_ccy)) return _amount;\n\n        AggregatorV3Interface priceFeed = Storage.slot().ethPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return (_amount * uint256(price)) / 1e18;\n    }\n\n    /**\n     * @dev Triggers to get converted amounts of currency to ETH.\n     * @param _ccy Currency that has to be convered to ETH\n     * @param _amounts Array with amounts of funds to be converted\n     */\n    function convertBulkToETH(bytes32 _ccy, uint256[] memory _amounts)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        if (_isETH(_ccy)) return _amounts;\n\n        AggregatorV3Interface priceFeed = Storage.slot().ethPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        uint256[] memory amounts = new uint256[](_amounts.length);\n\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            uint256 amount = _amounts[i];\n\n            if (amount > 0) {\n                amounts[i] = (amount * uint256(price)) / 1e18;\n            } else {\n                amounts[i] = 0;\n            }\n        }\n\n        return amounts;\n    }\n\n    /**\n     * @dev Triggers to convert ETH amount of funds to specified currency.\n     * @param _ccy Currency that has to be convered from ETH\n     * @param _amountETH Amount of funds in ETH to be converted\n     */\n    function convertFromETH(bytes32 _ccy, uint256 _amountETH)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (_isETH(_ccy)) return _amountETH;\n\n        AggregatorV3Interface priceFeed = Storage.slot().ethPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return (_amountETH * 1e18) / uint256(price); // add decimals checks\n    }\n\n    function _isETH(bytes32 _ccy) internal pure returns (bool) {\n        return _ccy == \"ETH\";\n    }\n}\n"
    },
    "contracts/CollateralAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./interfaces/ICurrencyController.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./types/ProtocolTypes.sol\";\n\n/**\n * @title Collateral Aggregator contract is used to collect Secured Finance\n * protocol user's collateral in ETH. This contract also handle the\n * coverage calculation against all present values and liquidations\n * using FX rates for all protocol currency pairs to ETH\n *\n * Contract linked to Product based contracts (like Loan, Swap, etc), LendingMarkets, CurrencyController contracts.\n */\ncontract CollateralAggregator {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using Address for address;\n\n    event Register(address indexed addr, uint256 id, uint256 amount);\n\n    event Deposit(address indexed addr, uint256 amount);\n    event PositionDeposit(\n        address indexed partyA,\n        address indexed partyB,\n        uint256 amountA,\n        uint256 amountB\n    );\n\n    event Rebalance(\n        address indexed partyA,\n        address indexed partyB,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event RebalancePositions(\n        address[] fromParties,\n        address[] toParties,\n        uint256[] fromAmounts,\n        uint256[] toAmounts\n    );\n\n    event Withdraw(address indexed addr, uint256 amount);\n    event PositionWithdraw(\n        address indexed partyA,\n        address indexed partyB,\n        uint256 amountA,\n        uint256 amountB\n    );\n\n    event UseCollateral(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    );\n    event UseUnsettledCollateral(address indexed party, bytes32 ccy, uint256 amount);\n\n    event SettleCollateral(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event Release(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    );\n    event ReleaseUnsettled(address indexed party, bytes32 ccy, uint256 amount);\n\n    event Liquidate(address indexed from, address indexed to, uint256 amount);\n    event LiquidateUnsettled(\n        address indexed from,\n        address indexed to,\n        bytes32 ccy,\n        uint256 amount,\n        uint256 ethAmount\n    );\n\n    event UpdateState(\n        address indexed addr,\n        ProtocolTypes.CollateralState prevState,\n        ProtocolTypes.CollateralState currState\n    );\n    event UpdatePV(address indexed addr, uint256 prevPV, uint256 newPV, ProtocolTypes.Ccy ccy);\n\n    /**\n     * @dev Global collateral book used to track user's total amount\n     * of ETH collateral used across all deals and bilateral positions.\n     */\n    struct Book {\n        uint256 gatewayTokenId; // Civic gateway token ID\n        uint256 independentAmount; // available ETH for rebalancing\n        uint256 lockedCollateral; // total utilized ETH collateral\n    }\n\n    /**\n     * @dev Bilateral collateral position keeps track of collateral\n     * amounts by each counterparty and bilateral position state\n     */\n    struct Position {\n        uint256 lockedCollateralA;\n        uint256 lockedCollateralB;\n        // CollateralState stateA;\n        // CollateralState stateB;\n    }\n\n    /**\n     * @dev CcyNetting keeps track of total amount of obligations owed\n     * by two counterparties per currency, used to calculate the\n     * total amount of collateral coverage in bilateral position\n     */\n    struct CcyNetting {\n        uint256 unsettled0PV;\n        uint256 unsettled1PV;\n        uint256 party0PV;\n        uint256 party1PV;\n    }\n\n    // Mapping for all collateral books.\n    mapping(address => Book) private books;\n\n    // Mapping for total amount of collateral locked in global collateral book by currency code.\n    mapping(address => mapping(bytes32 => uint256)) private unsettledCollateral;\n\n    // Mapping for total amount of collateral locked in global collateral book by currency code.\n    mapping(address => EnumerableSet.Bytes32Set) private exposedUnsettledCurrencies;\n\n    // Mapping for all registered books.\n    mapping(address => bool) private isRegistered;\n\n    // Mapping for bilateral collateral positions between 2 counterparties.\n    mapping(address => mapping(address => Position)) private positions;\n\n    // Mapping for used currencies set in bilateral position.\n    mapping(address => mapping(address => EnumerableSet.Bytes32Set)) private exposedCurrencies;\n\n    // Mapping for exposures per currency in bilateral position.\n    mapping(address => mapping(address => mapping(bytes32 => CcyNetting))) private ccyNettings;\n\n    uint256 public LQLEVEL; // 120% for liquidation price\n    uint256 public MARGINLEVEL; // 150% margin call threshold\n    uint256 public AUTOLQLEVEL; // 125% auto liquidation\n\n    address public owner;\n\n    // Linked contract addresses\n    ICurrencyController public currencyController;\n    EnumerableSet.AddressSet private collateralUsers;\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if msg.sender is collateral user\n     */\n    modifier acceptedContract() {\n        require(collateralUsers.contains(msg.sender), \"not allowed to use collateral\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if collateral book registered for `_user`\n     */\n    modifier registeredBook(address _user) {\n        require(isRegistered[_user], \"book not found\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if collateral book registered for `_user`\n     */\n    modifier nonRegisteredBook(address _user) {\n        require(!isRegistered[_user], \"book registered already\");\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     *\n     * @notice sets contract deployer as owner of this contract\n     */\n    constructor() {\n        owner = msg.sender;\n\n        LQLEVEL = 12000; // 120% for liquidation price\n        MARGINLEVEL = 15000; // 150% margin call threshold\n        AUTOLQLEVEL = 12500; // 125% auto liquidatio\n    }\n\n    // =========== LINKED CONTRACT MANAGEMENT SECTION ===========\n\n    /**\n     * @dev Trigers to add contract address to collateral users address set\n     * @param _user Collateral user smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function addCollateralUser(address _user) public onlyOwner returns (bool) {\n        require(_user != address(0), \"Zero address\");\n        require(_user.isContract(), \"Can't add non-contract address\");\n        require(!collateralUsers.contains(_user), \"Can't add existing address\");\n        return collateralUsers.add(_user);\n    }\n\n    /**\n     * @dev Trigers to remove collateral user from address set\n     * @param _user Collateral user smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on removing non-existing collateral user\n     */\n    function removeCollateralUser(address _user) public onlyOwner returns (bool) {\n        require(collateralUsers.contains(_user), \"Can't remove non-existing user\");\n        return collateralUsers.remove(_user);\n    }\n\n    /**\n     * @dev Trigers to check if provided `addr` is a collateral user from address set\n     * @param _user Contract address to check if it's a collateral user\n     *\n     */\n    function isCollateralUser(address _user) public view returns (bool) {\n        return collateralUsers.contains(_user);\n    }\n\n    /**\n     * @dev Trigers to add currency controller contract address\n     * @param _addr Currency Controller smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function setCurrencyController(address _addr) public onlyOwner {\n        require(_addr != address(0), \"Zero address\");\n        require(_addr.isContract(), \"Can't add non-contract address\");\n\n        currencyController = ICurrencyController(_addr);\n    }\n\n    /**\n     * @dev Trigers to update liquidation level ratio\n     * @param _ratio Liquidation level ratio\n     * @notice Trigers only be contract owner\n     */\n    function updateLiquidationThreshold(uint256 _ratio) public onlyOwner {\n        require(_ratio > 0, \"Incorrect Ratio\");\n        require(_ratio < MARGINLEVEL, \"Liquidation Price Overflow\");\n\n        AUTOLQLEVEL = _ratio;\n    }\n\n    /**\n     * @dev Trigers to update margin call level\n     * @param _ratio Margin call ratio\n     * @notice Trigers only be contract owner\n     */\n    function updateMarginCallThreshold(uint256 _ratio) public onlyOwner {\n        require(_ratio > 0, \"Incorrect Ratio\");\n\n        MARGINLEVEL = _ratio;\n    }\n\n    /**\n     * @dev Trigers to update liquidation price\n     * @param _price Liquidation price in basis point\n     * @notice Trigers only be contract owner\n     */\n    function updateLiquidationPrice(uint256 _price) public onlyOwner {\n        require(_price > 0, \"Incorrect Ratio\");\n        require(_price < AUTOLQLEVEL, \"Liquidation Price Overflow\");\n\n        LQLEVEL = _price;\n    }\n\n    // =========== COLLATERAL BOOK SECTION ===========\n\n    /**\n     * @dev Register user and store collateral book\n     * @param id Gateway token ID for KYC'd addresses\n     *\n     * @notice Payable function, if user sends ETH msg.value adds to independentAmount\n     */\n    function register(uint256 id) public payable nonRegisteredBook(msg.sender) {\n        _register(id);\n    }\n\n    /**\n     * @dev Register user without KYC gateway token\n     *\n     * @notice Payable function, if user sends ETH msg.value adds to independentAmount\n     */\n    function register() public payable nonRegisteredBook(msg.sender) {\n        _register(0);\n    }\n\n    /**\n     * @dev Deposit ETH collateral for msg.sender in collateral book\n     * @notice payable function increases the collateral amount by msg.value\n     */\n    function deposit() public payable registeredBook(msg.sender) {\n        books[msg.sender].independentAmount += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Deposit ETH collateral into bilateral position against counterparty\n     * @param _counterparty Counterparty address in bilateral position\n     * @notice payable function increases locked collateral by msg.value\n     */\n    function deposit(address _counterparty) public payable registeredBook(msg.sender) {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            msg.sender,\n            _counterparty\n        );\n        books[msg.sender].lockedCollateral += msg.value; // save deposited collateral in global book\n\n        Position storage position = positions[_partyA][_partyB];\n\n        if (!flipped) {\n            position.lockedCollateralA += msg.value;\n            emit PositionDeposit(_partyA, _partyB, msg.value, 0);\n        } else {\n            position.lockedCollateralB += msg.value;\n            emit PositionDeposit(_partyA, _partyB, 0, msg.value);\n        }\n    }\n\n    /**\n     * @dev Rebalance collateral from msg.sender collateral book to specific bilateral position\n     *\n     * @notice Triggers by collateral owner\n     */\n    function rebalanceTo(address _counterparty, uint256 _amount) public registeredBook(msg.sender) {\n        _rebalanceFromBook(msg.sender, _counterparty, _amount);\n    }\n\n    /**\n     * @dev Rebalance collateral from `_mainParty` collateral book to specific bilateral position\n     *\n     * @notice Triggers only by contracts accepted to use collateral\n     */\n    function rebalanceTo(\n        address _mainParty,\n        address _counterparty,\n        uint256 _amount\n    ) public acceptedContract {\n        _rebalanceFromBook(_mainParty, _counterparty, _amount);\n    }\n\n    /**\n     * @dev Rebalance collateral from one bilateral position with `_fromParty` counterparty\n     * to another bilateral position with `_toParty` counterparty\n     */\n    function rebalanceFrom(\n        address _fromParty,\n        address _toParty,\n        uint256 _amount\n    ) public registeredBook(msg.sender) {\n        (address _fromPartyA, address _fromPartyB, bool fromFlipped) = _checkAddresses(\n            msg.sender,\n            _fromParty\n        );\n        (address _toPartyA, address _toPartyB, bool toFlipped) = _checkAddresses(\n            msg.sender,\n            _toParty\n        );\n\n        (uint256 maxWidthdraw0, uint256 maxWidthdraw1) = _calcMaxCollateralWidthdraw(\n            _fromPartyA,\n            _fromPartyB\n        );\n\n        if (!fromFlipped) {\n            require(maxWidthdraw0 >= _amount, \"positionFrom uncovered\");\n            positions[_fromPartyA][_fromPartyB].lockedCollateralA -= _amount;\n        } else {\n            require(maxWidthdraw1 >= _amount, \"positionFrom uncovered\");\n            positions[_fromPartyA][_fromPartyB].lockedCollateralB -= _amount;\n        }\n\n        if (!toFlipped) {\n            positions[_toPartyA][_toPartyB].lockedCollateralA += _amount;\n        } else {\n            positions[_toPartyA][_toPartyB].lockedCollateralB += _amount;\n        }\n\n        // updatePositionState(_fromPartyA, _fromPartyB);\n        // updatePositionState(_toPartyA, _toPartyB);\n        // emit RebalancePositions\n    }\n\n    function rebalanceFromPositionToBook(\n        address _mainParty,\n        address _counterparty,\n        uint256 _amount\n    ) public acceptedContract registeredBook(_mainParty) {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            _mainParty,\n            _counterparty\n        );\n        (uint256 maxWidthdraw0, uint256 maxWidthdraw1) = _calcMaxCollateralWidthdraw(\n            _partyA,\n            _partyB\n        );\n        Book storage book = books[_mainParty];\n\n        if (!flipped) {\n            require(maxWidthdraw0 >= _amount, \"positionFrom uncovered\");\n            positions[_partyA][_partyB].lockedCollateralA -= _amount;\n        } else {\n            require(maxWidthdraw1 >= _amount, \"positionFrom uncovered\");\n            positions[_partyA][_partyB].lockedCollateralB -= _amount;\n        }\n\n        book.lockedCollateral = book.lockedCollateral - _amount;\n        book.independentAmount = book.independentAmount + _amount;\n    }\n\n    // TODO: Rebalance from position to book once position coverage more than 150%\n\n    /**\n     * @dev Triggers to lock unsettled collateral on a global book for selected currency.\n     * @param user User's address\n     * @param ccy Specified currency of the deal\n     * @param amount Amount of funds to be locked in Ccy for user\n     *\n     * @notice Callable only by Loan and linked LendingMarket\n     */\n    function useUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external acceptedContract {\n        exposedUnsettledCurrencies[user].add(ccy);\n        require(isCoveredUnsettled(user, ccy, amount), \"Not enough collateral\");\n\n        unsettledCollateral[user][ccy] = unsettledCollateral[user][ccy] + amount;\n\n        emit UseUnsettledCollateral(user, ccy, amount);\n    }\n\n    /**\n     * @dev Triggers to lock collateral using ETH rate for selected currency.\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be locked in Ccy for counterparty A\n     * @param amount1 Amount of funds to be locked in Ccy for counterparty B\n     *\n     * @notice Callable only by Loan and linked LendingMarket\n     */\n    function useCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external acceptedContract {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(partyA, partyB);\n        exposedCurrencies[_partyA][_partyB].add(ccy);\n\n        if (!flipped) {\n            (uint256 amt0, uint256 amt1) = _calcCollateralForRebalance(\n                partyA,\n                partyB,\n                ccy,\n                amount0,\n                amount1,\n                isSettled\n            );\n\n            if (amt0 > 0) {\n                rebalanceTo(partyA, partyB, amt0);\n            }\n\n            if (amt1 > 0) {\n                rebalanceTo(partyB, partyA, amt1);\n            }\n        } else {\n            (uint256 amt0, uint256 amt1) = _calcCollateralForRebalance(\n                partyB,\n                partyA,\n                ccy,\n                amount1,\n                amount0,\n                isSettled\n            );\n\n            if (amt0 > 0) {\n                rebalanceTo(partyB, partyA, amt0);\n            }\n\n            if (amt1 > 0) {\n                rebalanceTo(partyA, partyB, amt1);\n            }\n        }\n\n        CcyNetting storage netting = ccyNettings[_partyA][_partyB][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                if (isSettled) {\n                    netting.party0PV = netting.party0PV + amount0;\n                } else {\n                    netting.unsettled0PV = netting.unsettled0PV + amount0;\n                }\n            }\n            if (amount1 > 0) {\n                if (isSettled) {\n                    netting.party1PV = netting.party1PV + amount1;\n                } else {\n                    netting.unsettled1PV = netting.unsettled1PV + amount1;\n                }\n            }\n        } else {\n            if (amount0 > 0) {\n                if (isSettled) {\n                    netting.party1PV = netting.party1PV + amount0;\n                } else {\n                    netting.unsettled1PV = netting.unsettled1PV + amount0;\n                }\n            }\n            if (amount1 > 0) {\n                if (isSettled) {\n                    netting.party0PV = netting.party0PV + amount1;\n                } else {\n                    netting.unsettled0PV = netting.unsettled0PV + amount1;\n                }\n            }\n        }\n\n        // updatePositionState(_partyA, _partyB);\n        emit UseCollateral(_partyA, _partyB, ccy, amount0, amount1, isSettled);\n    }\n\n    /**\n     * @dev Triggers to lock collateral using ETH rate for selected currency.\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be locked in Ccy for counterparty A\n     * @param amount1 Amount of funds to be locked in Ccy for counterparty B\n     *\n     * @notice Callable only by Loan and linked LendingMarket\n     */\n    function settleCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    ) external acceptedContract {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(partyA, partyB);\n\n        CcyNetting storage netting = ccyNettings[_partyA][_partyB][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                netting.unsettled0PV = netting.unsettled0PV - amount0;\n                netting.party0PV = netting.party0PV + amount0;\n            }\n            if (amount1 > 0) {\n                netting.unsettled1PV = netting.unsettled1PV - amount1;\n                netting.party1PV = netting.party1PV + amount1;\n            }\n        } else {\n            if (amount0 > 0) {\n                netting.unsettled1PV = netting.unsettled1PV - amount0;\n                netting.party1PV = netting.party1PV + amount0;\n            }\n            if (amount1 > 0) {\n                netting.unsettled0PV = netting.unsettled0PV - amount1;\n                netting.party0PV = netting.party0PV + amount1;\n            }\n        }\n\n        // updatePositionState(_partyA, _partyB);\n        emit SettleCollateral(_partyA, _partyB, ccy, amount0, amount1);\n    }\n\n    /**\n     * @dev Triggers to calculate total unsettled exposure across all currencies\n     * @param _user User's address\n     */\n    function getTotalUnsettledExp(address _user) public view returns (uint256) {\n        uint256 totalExpInETH = _netTotalUnsettledAndHypotheticalPV(_user, \"\", 0);\n\n        return totalExpInETH;\n    }\n\n    /**\n     * @dev Triggers to calculate netted exposures across all currencies with applied haircuts\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     */\n    function getNetAndTotalPV(address party0, address party1)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (address _party0, address _party1, ) = _checkAddresses(party0, party1);\n        (uint256 net0, uint256 net1, uint256 total0, uint256 total1) = _netTotalAndHypotheticalPV(\n            _party0,\n            _party1,\n            \"\",\n            0,\n            0,\n            false\n        );\n\n        return (net0, net1, total0, total1);\n    }\n\n    /**\n     * @dev Triggers to check if unsettled collateral exposure covered more that 150% from a global collateral book of `_user`.\n     * @param _user User's ethereum address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _unsettledExp Additional exposure to lock into unsettled exposure\n     */\n    function isCoveredUnsettled(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) public view returns (bool) {\n        (uint256 coverage, ) = _calculateUnsettledCoverageAndTotalExposure(\n            _user,\n            _ccy,\n            _unsettledExp\n        );\n        return coverage >= MARGINLEVEL;\n    }\n\n    /**\n     * @dev Triggers to check if collateral covered more that 150%.\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _party0PV Counterparty A additional present value\n     * @param _party1PV Counterparty B additional present value\n     */\n    function isCovered(\n        address party0,\n        address party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) public view returns (bool, bool) {\n        (address _party0, address _party1, bool flipped) = _checkAddresses(party0, party1);\n\n        if (!flipped) {\n            (uint256 cover0, uint256 cover1) = _calculateCoverage(\n                _party0,\n                _party1,\n                _ccy,\n                _party0PV,\n                _party1PV,\n                _isSettled\n            );\n            return (cover0 >= MARGINLEVEL, cover1 >= MARGINLEVEL);\n        } else {\n            (uint256 cover0, uint256 cover1) = _calculateCoverage(\n                _party1,\n                party0,\n                _ccy,\n                _party1PV,\n                _party0PV,\n                _isSettled\n            );\n            return (cover1 >= MARGINLEVEL, cover0 >= MARGINLEVEL);\n        }\n    }\n\n    /**\n     * @dev Triggers to get maximum amount of ETH available to widthdraw from `_user` collateral book.\n     * @param _user User's address\n     */\n    function getMaxCollateralBookWidthdraw(address _user) public view returns (uint256) {\n        (uint256 maxWidthdraw, ) = _calcMaxCollateralWidthdrawFromBook(_user);\n\n        return maxWidthdraw;\n    }\n\n    /**\n     * @dev Triggers to get maximum amount of ETH available to\n     * widthdraw from bilateral position between `party0` and `_party1`.\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     */\n    function getMaxCollateralWidthdraw(address _party0, address _party1)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        (address _partyA, address _partyB, ) = _checkAddresses(_party0, _party1);\n        (uint256 maxWidthdraw0, uint256 maxWidthdraw1) = _calcMaxCollateralWidthdraw(\n            _partyA,\n            _partyB\n        );\n\n        return (maxWidthdraw0, maxWidthdraw1);\n    }\n\n    /**\n     * @dev Triggers to get coverage of the global collateral book against all unsettled exposure.\n     * @param _user User's address\n     */\n    function getUnsettledCoverage(address _user) public view returns (uint256) {\n        (uint256 coverage, ) = _calculateUnsettledCoverageAndTotalExposure(_user, \"\", 0);\n        return coverage;\n    }\n\n    /**\n     * @dev Triggers to get coverage of the global collateral book against all unsettled exposure.\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     */\n    function getRebalanceCollateralAmounts(address party0, address party1)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        (, , bool flipped) = _checkAddresses(party0, party1);\n\n        if (!flipped) {\n            (uint256 amt0, uint256 amt1) = _calcCollateralForRebalance(\n                party0,\n                party1,\n                \"\",\n                0,\n                0,\n                false\n            );\n            return (amt0, amt1);\n        } else {\n            (uint256 amt0, uint256 amt1) = _calcCollateralForRebalance(\n                party1,\n                party0,\n                \"\",\n                0,\n                0,\n                false\n            );\n            return (amt1, amt0);\n        }\n    }\n\n    /**\n     * @dev Triggers to get bilateral position collateral coverage.\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     */\n    function getCoverage(address party0, address party1) public view returns (uint256, uint256) {\n        (address _party0, address _party1, bool flipped) = _checkAddresses(party0, party1);\n\n        if (!flipped) {\n            (uint256 cover0, uint256 cover1) = _calculateCoverage(\n                _party0,\n                _party1,\n                \"\",\n                0,\n                0,\n                false\n            );\n            return (cover0, cover1);\n        } else {\n            (uint256 cover0, uint256 cover1) = _calculateCoverage(\n                _party0,\n                _party1,\n                \"\",\n                0,\n                0,\n                false\n            );\n            return (cover1, cover0);\n        }\n    }\n\n    /**\n     * @dev Triggers to reduce the amount of unsettled exposure in specific `ccy` from a global collateral book of `user`\n     * @param user User's ETH address\n     * @param ccy Specified currency of the deal\n     * @param amount Amount of funds to be unlocked from unsettled exposure in specified ccy\n     *\n     * @notice Callable only by smart contracts allowed to use collateral\n     */\n    function releaseUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external acceptedContract {\n        unsettledCollateral[user][ccy] = unsettledCollateral[user][ccy] - amount;\n\n        if (unsettledCollateral[user][ccy] == 0) {\n            exposedUnsettledCurrencies[user].remove(ccy);\n        }\n\n        emit ReleaseUnsettled(user, ccy, amount);\n    }\n\n    /**\n     * @dev Triggers to reduce PV for specific `ccy` in bilateral position between `partyA` and `partyB`\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be removed in CcyNetting for counterparty A\n     * @param amount1 Amount of funds to be removed in CcyNetting for counterparty B\n     *\n     * @notice Callable only by smart contracts allowed to use collateral\n     */\n    function releaseCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external acceptedContract {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(partyA, partyB);\n        require(exposedCurrencies[_partyA][_partyB].contains(ccy), \"non-used ccy\");\n        CcyNetting storage netting = ccyNettings[_partyA][_partyB][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                if (isSettled) {\n                    netting.party0PV = netting.party0PV - amount0;\n                } else {\n                    netting.unsettled0PV = netting.unsettled0PV - amount0;\n                }\n            }\n            if (amount1 > 0) {\n                if (isSettled) {\n                    netting.party1PV = netting.party1PV - amount1;\n                } else {\n                    netting.unsettled1PV = netting.unsettled1PV - amount1;\n                }\n            }\n        } else {\n            if (amount0 > 0) {\n                if (isSettled) {\n                    netting.party1PV = netting.party1PV - amount0;\n                } else {\n                    netting.unsettled1PV = netting.unsettled1PV - amount0;\n                }\n            }\n            if (amount1 > 0) {\n                if (isSettled) {\n                    netting.party0PV = netting.party0PV - amount1;\n                } else {\n                    netting.unsettled0PV = netting.unsettled0PV - amount1;\n                }\n            }\n        }\n\n        // updatePositionState(_partyA, _partyB);\n        emit Release(_partyA, _partyB, ccy, amount0, amount1);\n    }\n\n    /**\n     * @dev Triggers to withdraw collateral from independent collateral amount in user's book\n     * @param _amt Amount of collateral to withdraw\n     *\n     * @notice If requested more that independent amount withdraw all available collateral not used\n     */\n    function withdraw(uint256 _amt) public registeredBook(msg.sender) {\n        Book storage book = books[msg.sender];\n        (uint256 maxWidthdraw, ) = _calcMaxCollateralWidthdrawFromBook(msg.sender);\n\n        // if (totalUnsettledExp == 0) {\n        //     maxWidthdraw = book.independentAmount;\n        // }\n\n        if (_amt > maxWidthdraw) {\n            book.independentAmount = book.independentAmount - maxWidthdraw;\n            payable(msg.sender).transfer(maxWidthdraw);\n            emit Withdraw(msg.sender, maxWidthdraw);\n        } else {\n            book.independentAmount = book.independentAmount - _amt;\n            payable(msg.sender).transfer(_amt);\n            emit Withdraw(msg.sender, _amt);\n        }\n    }\n\n    /**\n     * @dev Triggers to withdraw collateral from bilateral position between `msg.sender` and `_counterparty`\n     * @param _counterparty Counterparty address in bilateral position\n     * @param _amt Amount of collateral to withdraw\n     *\n     * @notice If requested more that independent amount withdraw all available collateral not used\n     */\n    function withdrawFrom(address _counterparty, uint256 _amt) public registeredBook(msg.sender) {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            msg.sender,\n            _counterparty\n        );\n        (uint256 maxWidthdraw0, uint256 maxWidthdraw1) = _calcMaxCollateralWidthdraw(\n            _partyA,\n            _partyB\n        );\n\n        Position storage position = positions[_partyA][_partyB];\n        uint256 withdrawAmt;\n\n        if (!flipped) {\n            withdrawAmt = maxWidthdraw0 > _amt ? _amt : maxWidthdraw0;\n            position.lockedCollateralA -= withdrawAmt;\n            emit PositionWithdraw(_partyA, _partyB, withdrawAmt, 0);\n        } else {\n            withdrawAmt = maxWidthdraw1 > _amt ? _amt : maxWidthdraw1;\n            position.lockedCollateralB -= withdrawAmt;\n            emit PositionWithdraw(_partyA, _partyB, 0, withdrawAmt);\n        }\n\n        books[msg.sender].lockedCollateral -= withdrawAmt; // save deposited collateral in global book\n        payable(msg.sender).transfer(withdrawAmt);\n    }\n\n    /**\n     * @dev Triggers to update PV value in currency for bilateral position\n     * changes present value in native currency, without exchange rate conversion\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param prevPV0 Previous present value to be substracted from total exposure for counterparty A\n     * @param prevPV1 Previous present value to be substracted from total exposure for counterparty B\n     * @param currentPV0 Current present value to be added to total exposure for counterparty A\n     * @param currentPV1 Current present value to be added to total exposure for counterparty B\n     *\n     * @notice Trigers only be Loan contract\n     */\n    function updatePV(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) external acceptedContract {\n        (address _party0, address _party1, bool flipped) = _checkAddresses(party0, party1);\n\n        CcyNetting storage netting = ccyNettings[_party0][_party1][ccy];\n\n        if (!flipped) {\n            if (currentPV0 > 0) {\n                netting.party0PV = netting.party0PV - prevPV0 + currentPV0;\n            }\n            if (currentPV1 > 0) {\n                netting.party1PV = netting.party1PV - prevPV1 + currentPV1;\n            }\n        } else {\n            if (currentPV0 > 0) {\n                netting.party1PV = netting.party1PV - prevPV0 + currentPV0;\n            }\n            if (currentPV1 > 0) {\n                netting.party0PV = netting.party0PV - prevPV1 + currentPV1;\n            }\n        }\n        // updatePositionState(_party0, _party1);\n\n        // emit UpdatePV(_party0, _party1, ccy, prevPV0, prevPV1, currentPV0, currentPV1);\n    }\n\n    /**\n     * @dev Triggers to liquidate unsettled collateral from borrower's global collateral book to lender's collateral book\n     * @param from Address for liquidating collateral from\n     * @param to Address for sending collateral to\n     * @param ccy Currency to use rate to ETH for\n     * @param amount Liquidation amount in Ccy\n     *\n     * @notice Trigers only be Loan contract\n     */\n    function liquidateUnsettled(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 amount\n    ) external {\n        require(collateralUsers.contains(msg.sender), \"incorrect liquidator\");\n        uint256 amt = currencyController.convertToETH(ccy, amount);\n\n        unsettledCollateral[from][ccy] - amount;\n\n        books[from].independentAmount -= amt; // save deposited collateral in global book\n        books[to].independentAmount += amt; // save deposited collateral in global book\n\n        emit LiquidateUnsettled(from, to, ccy, amount, amt);\n    }\n\n    /**\n     * @dev Triggers to liquidate collateral from borrower to lender\n     * @param from Address for liquidating collateral from\n     * @param to Address for sending collateral to\n     * @param ccy Currency to use rate to ETH for\n     * @param amount Liquidation amount in Ccy\n     *\n     * @notice Trigers only be Loan contract\n     */\n    function liquidate(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 amount\n    ) external {\n        require(collateralUsers.contains(msg.sender), \"incorrect liquidator\");\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(from, to);\n        uint256 amt = currencyController.convertToETH(ccy, amount);\n        // TODO: rebalance required amount of collateral, transfer excess into global book\n        Position storage position = positions[_partyA][_partyB];\n\n        if (!flipped) {\n            require(position.lockedCollateralA >= amt, \"Liquidation amount not enough\");\n            position.lockedCollateralA -= amt;\n            position.lockedCollateralB += amt;\n        } else {\n            require(position.lockedCollateralB >= amt, \"Liquidation amount not enough\");\n            position.lockedCollateralB -= amt;\n            position.lockedCollateralA += amt;\n        }\n\n        books[from].lockedCollateral -= amt; // save deposited collateral in global book\n        books[to].lockedCollateral += amt; // save deposited collateral in global book\n\n        emit Liquidate(from, to, amt);\n    }\n\n    function getCollateralBook(address addr) public view returns (Book memory) {\n        return books[addr];\n    }\n\n    function checkRegisteredBook(address addr) public view returns (bool) {\n        return isRegistered[addr];\n    }\n\n    struct BilateralPositionLocalVars {\n        address partyA;\n        address partyB;\n        uint256 lockedCollateralA;\n        uint256 lockedCollateralB;\n        uint256 maxCcy;\n        bytes32[] currencies;\n        uint256[] unsettled0PVs;\n        uint256[] unsettled1PVs;\n        uint256[] party0PVs;\n        uint256[] party1PVs;\n        uint256[] netPayments;\n    }\n\n    function getBilateralPosition(address partyA, address partyB)\n        public\n        view\n        returns (Position memory)\n    {\n        (address _partyA, address _partyB, ) = _checkAddresses(partyA, partyB);\n        Position memory position = positions[_partyA][_partyB];\n\n        return position;\n    }\n\n    function getCcyExposures(\n        address partyA,\n        address partyB,\n        bytes32 ccy\n    ) public view returns (CcyNetting memory) {\n        (address _partyA, address _partyB, ) = _checkAddresses(partyA, partyB);\n\n        require(exposedCurrencies[_partyA][_partyB].contains(ccy), \"non-used ccy\");\n\n        CcyNetting memory netting = ccyNettings[_partyA][_partyB][ccy];\n\n        return netting;\n    }\n\n    function getExposedCurrencies(address partyA, address partyB)\n        public\n        view\n        returns (bytes32[] memory)\n    {\n        (address _partyA, address _partyB, ) = _checkAddresses(partyA, partyB);\n        EnumerableSet.Bytes32Set storage expCcy = exposedCurrencies[_partyA][_partyB];\n\n        uint256 numCcy = expCcy.length();\n        bytes32[] memory currencies = new bytes32[](numCcy);\n\n        for (uint256 i = 0; i < numCcy; i++) {\n            bytes32 ccy = expCcy.at(i);\n            currencies[i] = ccy;\n        }\n\n        return currencies;\n    }\n\n    // =========== INTERNAL FUNCTIONS ===========\n\n    /**\n     * @dev Triggers internaly to store new collateral book\n     * @param id Gateway token ID for KYC'd addresses\n     */\n    function _register(uint256 id) internal {\n        Book memory book;\n\n        if (id != 0) {\n            book.gatewayTokenId = id;\n        }\n\n        if (msg.value > 0) {\n            book.independentAmount = msg.value;\n        }\n\n        isRegistered[msg.sender] = true;\n        books[msg.sender] = book;\n\n        emit Register(msg.sender, id, msg.value);\n    }\n\n    /**\n     * @dev Triggers internally to check if counterparty addresses are correct, modifies the order if needed.\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     */\n    function _checkAddresses(address party0, address party1)\n        internal\n        pure\n        returns (\n            address,\n            address,\n            bool\n        )\n    {\n        require(party0 != party1, \"Identical addresses\");\n        (address _party0, address _party1) = party0 < party1 ? (party0, party1) : (party1, party0);\n        require(_party0 != address(0), \"Invalid address\");\n        require(_party1 != address(0), \"Invalid counterparty\");\n\n        if (_party0 != party0) {\n            return (_party0, _party1, true);\n        } else {\n            return (_party0, _party1, false);\n        }\n    }\n\n    /**\n     * @dev Rebalance collateral from `_mainParty` collateral book to specific bilateral position\n     */\n    function _rebalanceFromBook(\n        address _mainParty,\n        address _counterparty,\n        uint256 _amount\n    ) internal {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            _mainParty,\n            _counterparty\n        );\n        Book storage book = books[_mainParty];\n\n        (uint256 maxWidthdraw, ) = _calcMaxCollateralWidthdrawFromBook(_mainParty);\n        require(maxWidthdraw >= _amount, \"Invalid rebalance amount\");\n\n        book.independentAmount = book.independentAmount - _amount; // includes overflow checks\n        book.lockedCollateral = book.lockedCollateral + _amount;\n\n        if (!flipped) {\n            positions[_partyA][_partyB].lockedCollateralA += _amount;\n            emit Rebalance(_partyA, _partyB, _amount, 0);\n        } else {\n            positions[_partyA][_partyB].lockedCollateralB += _amount;\n            emit Rebalance(_partyA, _partyB, 0, _amount);\n        }\n    }\n\n    struct NetAndTotalPVLocalVars {\n        uint256 exp0;\n        uint256 exp1;\n        uint256 unsettledExp0;\n        uint256 unsettledExp1;\n        int256 exchangeRate;\n        uint256 totalUnsettledPV0inETH;\n        uint256 totalUnsettledPV1inETH;\n        uint256 totalPV0inETH;\n        uint256 totalPV1inETH;\n        uint256 totalCombinedPV0inETH;\n        uint256 totalCombinedPV1inETH;\n        uint256 totalHaircutPV0;\n        uint256 totalHaircutPV1;\n        uint256 haircutRatio;\n        uint256 expDiff0;\n        uint256 expDiff1;\n        uint256 netExp0;\n        uint256 netExp1;\n        CcyNetting netting;\n        uint256 maxCcy;\n    }\n\n    /**\n     * @dev Triggers to calculate netted exposures across all currencies with applied haircuts.\n     * Also used to calculate hypothetical Net PV with additional exposure in specific `_ccy`\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _party0PV Counterparty A additional present value\n     * @param _party1PV Counterparty B additional present value\n     */\n    function _netTotalAndHypotheticalPV(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool isSettled\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        EnumerableSet.Bytes32Set storage expCcy = exposedCurrencies[_party0][_party1];\n        NetAndTotalPVLocalVars memory vars;\n\n        vars.maxCcy = expCcy.length();\n\n        for (uint256 i = 0; i < vars.maxCcy; i++) {\n            bytes32 ccy = expCcy.at(i);\n            vars.netting = ccyNettings[_party0][_party1][ccy];\n            vars.exchangeRate = currencyController.getLastETHPrice(ccy);\n\n            if (_ccy == ccy) {\n                if (isSettled) {\n                    vars.exp0 =\n                        ((vars.netting.party0PV + _party0PV) * uint256(vars.exchangeRate)) /\n                        1e18;\n                    vars.exp1 =\n                        ((vars.netting.party1PV + _party1PV) * uint256(vars.exchangeRate)) /\n                        1e18;\n                } else {\n                    vars.unsettledExp0 =\n                        ((vars.netting.unsettled0PV + _party0PV) * uint256(vars.exchangeRate)) /\n                        1e18;\n                    vars.unsettledExp1 =\n                        ((vars.netting.unsettled1PV + _party1PV) * uint256(vars.exchangeRate)) /\n                        1e18;\n                }\n            } else {\n                vars.unsettledExp0 =\n                    (vars.netting.unsettled0PV * uint256(vars.exchangeRate)) /\n                    1e18;\n                vars.unsettledExp1 =\n                    (vars.netting.unsettled1PV * uint256(vars.exchangeRate)) /\n                    1e18;\n\n                vars.exp0 = (vars.netting.party0PV * uint256(vars.exchangeRate)) / 1e18;\n                vars.exp1 = (vars.netting.party1PV * uint256(vars.exchangeRate)) / 1e18;\n            }\n\n            vars.totalUnsettledPV0inETH = vars.totalUnsettledPV0inETH + vars.unsettledExp0;\n            vars.totalUnsettledPV1inETH = vars.totalUnsettledPV1inETH + vars.unsettledExp1;\n\n            vars.haircutRatio = currencyController.getHaircut(ccy);\n\n            vars.totalPV0inETH = vars.totalPV0inETH + vars.exp0;\n            vars.totalPV1inETH = vars.totalPV1inETH + vars.exp1;\n\n            vars.totalHaircutPV0 =\n                ((vars.totalHaircutPV0 + vars.exp0) * vars.haircutRatio) /\n                ProtocolTypes.BP;\n            vars.totalHaircutPV1 =\n                ((vars.totalHaircutPV1 + vars.exp1) * vars.haircutRatio) /\n                ProtocolTypes.BP;\n        }\n\n        vars.expDiff0 = vars.totalPV0inETH >= vars.totalHaircutPV1\n            ? vars.totalPV0inETH - vars.totalHaircutPV1\n            : 0;\n        vars.expDiff1 = vars.totalPV1inETH >= vars.totalHaircutPV0\n            ? vars.totalPV1inETH - vars.totalHaircutPV0\n            : 0;\n\n        (vars.netExp0, vars.netExp1) = vars.expDiff0 > vars.expDiff1\n            ? (\n                vars.expDiff0 - vars.expDiff1 + vars.totalUnsettledPV0inETH,\n                vars.totalUnsettledPV1inETH\n            )\n            : (\n                vars.totalUnsettledPV0inETH,\n                vars.expDiff1 - vars.expDiff0 + vars.totalUnsettledPV1inETH\n            );\n\n        vars.totalCombinedPV0inETH = vars.totalUnsettledPV0inETH + vars.totalPV0inETH;\n        vars.totalCombinedPV1inETH = vars.totalUnsettledPV1inETH + vars.totalPV1inETH;\n\n        return (vars.netExp0, vars.netExp1, vars.totalCombinedPV0inETH, vars.totalCombinedPV1inETH);\n    }\n\n    struct CollateralReqLocalVars {\n        uint256 net0;\n        uint256 net1;\n        uint256 total0;\n        uint256 total1;\n        uint256 minMarginRatio;\n        uint256 minMarginReq0;\n        uint256 minMarginReq1;\n        uint256 netCover0;\n        uint256 netCover1;\n        uint256 req0;\n        uint256 req1;\n    }\n\n    /**\n     * @dev Triggers to calculate collateral coverage for bilateral position with/without additional PV\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `cover0`, `cover1` uint256 coverage percentages in basis point per counterparty\n     */\n    // TODO: NOW\n    function _calculateCollateralRequirements(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) internal view returns (uint256, uint256) {\n        CollateralReqLocalVars memory vars;\n\n        (vars.net0, vars.net1, vars.total0, vars.total1) = _netTotalAndHypotheticalPV(\n            _party0,\n            _party1,\n            _ccy,\n            _party0PV,\n            _party1PV,\n            _isSettled\n        );\n\n        vars.minMarginRatio = currencyController.getMinMargin(\"ETH\");\n        vars.minMarginReq0 = (vars.total0 * vars.minMarginRatio) / ProtocolTypes.BP;\n        vars.minMarginReq1 = (vars.total1 * vars.minMarginRatio) / ProtocolTypes.BP;\n\n        if (vars.net0 > 0) {\n            vars.netCover0 = (vars.net0 * MARGINLEVEL) / ProtocolTypes.BP;\n            vars.req0 = vars.minMarginReq0 > vars.netCover0 ? vars.minMarginReq0 : vars.net0;\n        } else {\n            vars.req0 = vars.minMarginReq0;\n        }\n\n        if (vars.net1 > 0) {\n            vars.netCover1 = (vars.net1 * MARGINLEVEL) / ProtocolTypes.BP;\n            vars.req1 = vars.minMarginReq1 > vars.netCover1 ? vars.minMarginReq1 : vars.net1;\n        } else {\n            vars.req1 = vars.minMarginReq1;\n        }\n\n        return (vars.req0, vars.req1);\n    }\n\n    struct CoverageCalcLocalVars {\n        uint256 req0;\n        uint256 req1;\n        uint256 cover0;\n        uint256 cover1;\n    }\n\n    /**\n     * @dev Triggers to calculate collateral coverage for bilateral position with/without additional PV\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `cover0`, `cover1` uint256 coverage percentages in basis point per counterparty\n     */\n    // TODO: NOW\n    function _calculateCoverage(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) internal view returns (uint256, uint256) {\n        CoverageCalcLocalVars memory vars;\n\n        (vars.req0, vars.req1) = _calculateCollateralRequirements(\n            _party0,\n            _party1,\n            _ccy,\n            _party0PV,\n            _party1PV,\n            _isSettled\n        );\n\n        Position memory position = positions[_party0][_party1];\n\n        if (vars.req0 > 0) {\n            vars.cover0 = (ProtocolTypes.PCT * position.lockedCollateralA) / vars.req0;\n        }\n\n        if (vars.req1 > 0) {\n            vars.cover1 = (ProtocolTypes.PCT * position.lockedCollateralB) / vars.req1;\n        }\n\n        return (vars.cover0, vars.cover1);\n    }\n\n    struct MaxCollateralWidthdrawLocalVars {\n        uint256 req0;\n        uint256 req1;\n        uint256 targetReq0;\n        uint256 targetReq1;\n        uint256 delta0;\n        uint256 delta1;\n        uint256 maxWidthdraw0;\n        uint256 maxWidthdraw1;\n    }\n\n    /**\n     * @dev Triggers to calculate max collateral amount available to widthdraw from bilateral position\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `maxWidthdraw0`, `maxWidthdraw1` uint256 available for widthdraw collateral amounts\n     */\n    // TODO: NOW\n    function _calcMaxCollateralWidthdraw(address _party0, address _party1)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        MaxCollateralWidthdrawLocalVars memory vars;\n\n        (vars.req0, vars.req1) = _calculateCollateralRequirements(\n            _party0,\n            _party1,\n            \"\",\n            0,\n            0,\n            false\n        );\n\n        vars.targetReq0 = (vars.req0 * MARGINLEVEL) / ProtocolTypes.BP;\n        vars.targetReq1 = (vars.req1 * MARGINLEVEL) / ProtocolTypes.BP;\n\n        Position memory position = positions[_party0][_party1];\n\n        if (position.lockedCollateralA > 0 && vars.targetReq0 > 0) {\n            vars.maxWidthdraw0 = position.lockedCollateralA > vars.targetReq0\n                ? position.lockedCollateralA - vars.targetReq0\n                : 0;\n        } else {\n            vars.maxWidthdraw0 = position.lockedCollateralA;\n        }\n\n        if (position.lockedCollateralB > 0 && vars.targetReq1 > 0) {\n            vars.maxWidthdraw1 = position.lockedCollateralB > vars.targetReq1\n                ? position.lockedCollateralB - vars.targetReq1\n                : 0;\n        } else {\n            vars.maxWidthdraw1 = position.lockedCollateralB;\n        }\n\n        return (vars.maxWidthdraw0, vars.maxWidthdraw1);\n    }\n\n    struct RequiredCollateralForRebalanceLocalVars {\n        uint256 req0;\n        uint256 req1;\n        uint256 targetReq0;\n        uint256 targetReq1;\n        uint256 cover0;\n        uint256 cover1;\n        uint256 targetLocked0;\n        uint256 targetLocked1;\n        uint256 reqCollateral0;\n        uint256 reqCollateral1;\n    }\n\n    /**\n     * @dev Triggers to calculate collateral amount in ETH to rebalance to keep collateral coverage at least on MARGINLEVEL\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `amt0`, `amt1` uint256 amount of ETH to be rebalanced from parties collateral books\n     */\n    function _calcCollateralForRebalance(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _amount0,\n        uint256 _amount1,\n        bool _isSettled\n    ) internal view returns (uint256, uint256) {\n        RequiredCollateralForRebalanceLocalVars memory vars;\n\n        (vars.req0, vars.req1) = _calculateCollateralRequirements(\n            _party0,\n            _party1,\n            _ccy,\n            _amount0,\n            _amount1,\n            _isSettled\n        );\n\n        vars.targetReq0 = (vars.req0 * MARGINLEVEL) / ProtocolTypes.BP;\n        vars.targetReq1 = (vars.req1 * MARGINLEVEL) / ProtocolTypes.BP;\n\n        Position memory position = positions[_party0][_party1];\n\n        if (position.lockedCollateralA > 0 && vars.targetReq0 > 0) {\n            vars.reqCollateral0 = position.lockedCollateralA > vars.targetReq0\n                ? 0\n                : vars.targetReq0 - position.lockedCollateralA;\n        } else {\n            vars.reqCollateral0 = vars.targetReq0;\n        }\n\n        if (position.lockedCollateralB > 0 && vars.targetReq1 > 0) {\n            vars.reqCollateral1 = position.lockedCollateralB > vars.targetReq1\n                ? 0\n                : vars.targetReq1 - position.lockedCollateralB;\n        } else {\n            vars.reqCollateral1 = vars.targetReq1;\n        }\n\n        return (vars.reqCollateral0, vars.reqCollateral1);\n    }\n\n    struct NetUnsettledExpLocalVars {\n        uint256 totalExp;\n        uint256 ccyExp;\n        uint256 ccyExpInETH;\n        int256 exchangeRate;\n        uint256 maxCcy;\n    }\n\n    /**\n     * @dev Triggers to calculate total unsettled exposure across all currencies for a global collateral book.\n     * Also used to calculate hypothetical Net PV with additional exposure in specific `_ccy`\n     * @param _user User's ethereum address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _unsettledExp Additional exposure to lock into unsettled exposure\n     */\n    function _netTotalUnsettledAndHypotheticalPV(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) internal view returns (uint256) {\n        EnumerableSet.Bytes32Set storage expCcy = exposedUnsettledCurrencies[_user];\n\n        NetUnsettledExpLocalVars memory vars;\n\n        vars.maxCcy = expCcy.length();\n\n        for (uint256 i = 0; i < vars.maxCcy; i++) {\n            bytes32 ccy = expCcy.at(i);\n            vars.ccyExp = unsettledCollateral[_user][ccy];\n            vars.exchangeRate = currencyController.getLastETHPrice(ccy);\n\n            if (_ccy == ccy) {\n                vars.ccyExpInETH =\n                    ((vars.ccyExp + _unsettledExp) * uint256(vars.exchangeRate)) /\n                    1e18;\n            } else {\n                vars.ccyExpInETH = (vars.ccyExp * uint256(vars.exchangeRate)) / 1e18;\n            }\n\n            vars.totalExp = vars.totalExp + vars.ccyExpInETH;\n        }\n\n        return vars.totalExp;\n    }\n\n    struct UnsettledCoverageLocalVars {\n        uint256 totalExpInETH;\n        uint256 coverage;\n    }\n\n    function _calculateUnsettledCoverageAndTotalExposure(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) internal view returns (uint256, uint256) {\n        UnsettledCoverageLocalVars memory vars;\n\n        vars.totalExpInETH = _netTotalUnsettledAndHypotheticalPV(_user, _ccy, _unsettledExp);\n\n        Book memory book = books[_user];\n\n        if (vars.totalExpInETH > 0) {\n            vars.coverage = (ProtocolTypes.PCT * book.independentAmount) / vars.totalExpInETH;\n        } else {\n            return (0, vars.totalExpInETH);\n        }\n\n        return (vars.coverage, vars.totalExpInETH);\n    }\n\n    struct MaxCollateralBookWidthdrawLocalVars {\n        uint256 totalExpInETH;\n        uint256 coverage;\n        uint256 delta;\n        uint256 maxWidthdraw;\n    }\n\n    /**\n     * @dev Triggers to calculate maximum amount of ETH available to widthdraw from `_user` collateral book\n     * @param _user User's ethereum address\n     *\n     * @return `maxWidthdraw` max widthdrawable amount of ETH\n     */\n    function _calcMaxCollateralWidthdrawFromBook(address _user)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        MaxCollateralBookWidthdrawLocalVars memory vars;\n\n        (vars.coverage, vars.totalExpInETH) = _calculateUnsettledCoverageAndTotalExposure(\n            _user,\n            \"\",\n            0\n        );\n\n        Book memory book = books[_user];\n\n        if (vars.coverage > MARGINLEVEL) {\n            vars.delta = vars.coverage - MARGINLEVEL;\n\n            vars.maxWidthdraw = (book.independentAmount * vars.delta) / vars.coverage;\n        } else if (vars.totalExpInETH == 0) {\n            return (book.independentAmount, vars.totalExpInETH);\n        } else {\n            return (0, vars.totalExpInETH);\n        }\n\n        return (vars.maxWidthdraw, vars.totalExpInETH);\n    }\n}\n"
    },
    "contracts/mocks/ChainlinkSettlementAdapterMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ISettlementEngine.sol\";\nimport \"../interfaces/IExternalAdapterTxResponse.sol\";\n\n/**\n * @title ChainlinkSettlementAdapterMock is mocking Chainlink external adapter.\n */\ncontract ChainlinkSettlementAdapterMock is ChainlinkClient, Ownable, IExternalAdapterTxResponse {\n    using Chainlink for Chainlink.Request;\n\n    mapping(bytes32 => FulfillData) public results; // TODO: remove tmp data\n    bytes32 public jobId;\n    uint256 public requestFee;\n    bytes32 public ccy;\n\n    ISettlementEngine private settlementEngine;\n\n    /**\n     * @dev Contract constructor function.\n     * @param _oracle The address of the oracle contract\n     * @param _jobId The job id on the Chainlink node\n     * @param _requestFee The amount of LINK sent for the request\n     * @param _link The address of the LINK token contract\n     *\n     * @notice `_link` is provided for development usage\n     */\n    constructor(\n        address _oracle,\n        bytes32 _jobId,\n        uint256 _requestFee,\n        address _link,\n        bytes32 _ccy,\n        address _settlementEngine\n    ) Ownable() {\n        setChainlinkOracle(_oracle);\n        jobId = _jobId;\n        ccy = _ccy;\n\n        requestFee = _requestFee;\n\n        settlementEngine = ISettlementEngine(_settlementEngine);\n\n        if (_link == address(0)) {\n            setPublicChainlinkToken();\n        } else {\n            setChainlinkToken(_link);\n        }\n    }\n\n    /**\n     * @dev Gets contract address of the LINK token that is set at constructor\n     *\n     * @return address The address of the LINK token\n     */\n    function getChainlinkToken() public view returns (address) {\n        return chainlinkTokenAddress();\n    }\n\n    /**\n     * @dev Gets contract address of the oracle that is set at constructor\n     *\n     * @return address The address of the oracle contract\n     */\n    function getChainlinkOracle() public view returns (address) {\n        return chainlinkOracleAddress();\n    }\n\n    /**\n     * @dev Triggers to request the data from Chainlink External Adaptor.\n     * This function specify a callback function name\n     * @param _txHash The hash that is specify the data to get\n     */\n    // TODO: replace modifier for other contracts to call\n    function createRequest(string memory _txHash) public returns (bytes32 requestId) {\n        _onlySettlementEngine();\n        Chainlink.Request memory req = buildChainlinkRequest(\n            jobId,\n            address(this),\n            this.fulfill.selector\n        );\n        req.add(\"txHash\", _txHash);\n        requestId = sendChainlinkRequest(req, requestFee);\n    }\n\n    /**\n     * @dev Triggers to cancel a request if it has not been fulfilled\n     * @param _requestId The id to specify a request\n     * @param _callbackFunctionId The callback function specified for the request\n     * @param _expiration The time of the expiration for the request\n     */\n    function cancelRequest(\n        bytes32 _requestId,\n        bytes4 _callbackFunctionId,\n        uint256 _expiration\n    ) public {\n        _onlySettlementEngine();\n        cancelChainlinkRequest(_requestId, requestFee, _callbackFunctionId, _expiration);\n    }\n\n    /**\n     * @dev Triggers to receive the data from a job that is specified by `createRequestTo` function.\n     * This function name is specified when `buildChainlinkRequest` is called\n     * @param _requestId The id to specify a request\n     * @param _from The from address of the data received\n     * @param _to The to address of the data received\n     * @param _value The value of the data received\n     * @param _timestamp The timestamp of the data received\n     * @param _txHash Transaction hash for request\n     */\n    function fulfill(\n        bytes32 _requestId,\n        string calldata _from,\n        string calldata _to,\n        uint256 _value,\n        uint256 _timestamp,\n        string calldata _txHash\n    ) public {\n        FulfillData memory txData = FulfillData({\n            from: _from,\n            to: _to,\n            value: _value,\n            timestamp: _timestamp,\n            txHash: _txHash\n        });\n\n        results[_requestId] = txData;\n\n        settlementEngine.fulfillSettlementRequest(_requestId, txData, ccy);\n    }\n\n    /**\n     * @dev Triggers to withdraw LINK Token.\n     * LINK token is needed to hold by this contract to use the Chainlink\n     */\n    function withdrawLink() public onlyOwner {\n        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());\n        require(link.transfer(msg.sender, link.balanceOf(address(this))), \"Unable to transfer\");\n    }\n\n    function _onlySettlementEngine() internal view {\n        require(msg.sender == address(settlementEngine), \"NOT_SETTLEMENT_ENGINE\");\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "contracts/mocks/ExternalAdapterCallerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../interfaces/IExternalAdapterTxResponse.sol\";\nimport \"../interfaces/IExternalAdapter.sol\";\n\ncontract ExternalAdapterCallerMock is IExternalAdapterTxResponse {\n    IExternalAdapter private adapter;\n\n    function initialize(\n        address owner,\n        address resolver,\n        address WETH9I\n    ) public {}\n\n    function setExternalAdapter(address _adapter) public {\n        require(_adapter != address(0), \"Zero address\");\n        adapter = IExternalAdapter(_adapter);\n    }\n\n    function createRequest(string memory txHash) public returns (bytes32 loanId) {\n        return adapter.createRequest(txHash);\n    }\n\n    function cancelRequest(\n        string memory _txHash,\n        bytes32 _requestId,\n        bytes4 _callbackFunctionId,\n        uint256 _expiration\n    ) public {\n        return adapter.cancelRequest(_txHash, _requestId, _callbackFunctionId, _expiration);\n    }\n\n    function fulfillSettlementRequest(\n        bytes32 _requestId,\n        FulfillData memory _txData,\n        bytes32 _ccy\n    ) external pure {\n        return;\n    }\n}\n"
    },
    "contracts/ChainlinkSettlementAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IExternalAdapterTxResponse.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\n\n/**\n * @title ChainlinkSettlementAdapter is managing requests to Chainlink for a settlement process.\n */\ncontract ChainlinkSettlementAdapter is\n    IExternalAdapterTxResponse,\n    ChainlinkClient,\n    MixinAddressResolver,\n    Ownable\n{\n    using Chainlink for Chainlink.Request;\n\n    mapping(string => bool) public isRequested;\n    bytes32 public jobId;\n    uint256 public requestFee;\n    bytes32 public ccy;\n\n    /**\n     * @dev Contract constructor function.\n     * @param _resolver The address of the Address Resolver contract\n     * @param _oracle The address of the oracle contract\n     * @param _jobId The job id on the Chainlink node\n     * @param _requestFee The amount of LINK sent for the request\n     * @param _link The address of the LINK token contract\n     * @param _ccy Settlement adapter currency identifier\n     *\n     * @notice `_link` is provided for development usage\n     */\n    constructor(\n        address _resolver,\n        address _oracle,\n        bytes32 _jobId,\n        uint256 _requestFee,\n        address _link,\n        bytes32 _ccy\n    ) {\n        registerAddressResolver(_resolver);\n        setChainlinkOracle(_oracle);\n        jobId = _jobId;\n        ccy = _ccy;\n\n        requestFee = _requestFee;\n\n        if (_link == address(0)) {\n            setPublicChainlinkToken();\n        } else {\n            setChainlinkToken(_link);\n        }\n\n        buildCache();\n    }\n\n    /**\n     * @dev The overridden method from MixinAddressResolver\n     */\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](1);\n        contracts[0] = Contracts.SETTLEMENT_ENGINE;\n    }\n\n    /**\n     * @dev The overridden method from MixinAddressResolver\n     */\n    function acceptedContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](1);\n        contracts[0] = Contracts.SETTLEMENT_ENGINE;\n    }\n\n    /**\n     * @dev Gets contract address of the LINK token that is set at constructor\n     *\n     * @return address The address of the LINK token\n     */\n    function getChainlinkToken() public view returns (address) {\n        return chainlinkTokenAddress();\n    }\n\n    /**\n     * @dev Gets contract address of the oracle that is set at constructor\n     *\n     * @return address The address of the oracle contract\n     */\n    function getChainlinkOracle() public view returns (address) {\n        return chainlinkOracleAddress();\n    }\n\n    /**\n     * @dev Updates the stored oracle address\n     * @param _oracle The address of the oracle contract\n     */\n    function updateChainlinkOracle(address _oracle) public onlyOwner {\n        setChainlinkOracle(_oracle);\n    }\n\n    /**\n     * @dev Updates the stored job id\n     * @param _jobId The job id on the Cahinlink node\n     */\n    function updateJobId(bytes32 _jobId) public onlyOwner {\n        jobId = _jobId;\n    }\n\n    /**\n     * @dev Updates the stored amount of LINK to send for the request\n     * @param _requestFee The amount of LINK sent for the request\n     */\n    function updateRequestFee(uint256 _requestFee) public onlyOwner {\n        requestFee = _requestFee;\n    }\n\n    /**\n     * @dev Triggers to request the data from Chainlink External Adaptor.\n     * This function specify a callback function name\n     * @param _txHash The hash that is specify the data to get\n     */\n    function createRequest(string memory _txHash)\n        public\n        onlyAcceptedContracts\n        returns (bytes32 requestId)\n    {\n        require(!isRequested[_txHash], \"REQUEST_EXIST_ALREADY\");\n        isRequested[_txHash] = true;\n        Chainlink.Request memory req = buildChainlinkRequest(\n            jobId,\n            address(this),\n            this.fulfill.selector\n        );\n        req.add(\"txHash\", _txHash);\n        requestId = sendChainlinkRequest(req, requestFee);\n    }\n\n    /**\n     * @dev Triggers to cancell a request if it has not been fulfilled\n     * @param _txHash Trasaction hash that has been requested to fulfill\n     * @param _requestId The id to specify a request\n     * @param _callbackFunctionId The callback function specified for the request\n     * @param _expiration The time of the expiration for the request\n     */\n    function cancelRequest(\n        string memory _txHash,\n        bytes32 _requestId,\n        bytes4 _callbackFunctionId,\n        uint256 _expiration\n    ) public onlyAcceptedContracts {\n        isRequested[_txHash] = false;\n        cancelChainlinkRequest(_requestId, requestFee, _callbackFunctionId, _expiration);\n    }\n\n    /**\n     * @dev Triggers to receive the data from a job that is specified by `createRequestTo` function.\n     * This function name is specified when `buildChainlinkRequest` is called\n     * @param _requestId The id to specify a request\n     * @param _from The from address of the data received\n     * @param _to The to address of the data received\n     * @param _value The value of the data received\n     * @param _timestamp The timestamp of the data received\n     * @param _txHash The hash of the data received\n     */\n    function fulfill(\n        bytes32 _requestId,\n        string calldata _from,\n        string calldata _to,\n        uint256 _value,\n        uint256 _timestamp,\n        string calldata _txHash\n    ) public recordChainlinkFulfillment(_requestId) {\n        FulfillData memory txData = FulfillData({\n            from: _from,\n            to: _to,\n            value: _value,\n            timestamp: _timestamp,\n            txHash: _txHash\n        });\n\n        settlementEngine().fulfillSettlementRequest(_requestId, txData, ccy);\n    }\n\n    /**\n     * @dev Triggers to withdraw LINK Token.\n     * LINK token is needed to hold by this contract to use the Chainlink\n     */\n    function withdrawLink() public onlyOwner {\n        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());\n        require(link.transfer(msg.sender, link.balanceOf(address(this))), \"Unable to transfer\");\n    }\n}\n"
    },
    "contracts/mocks/LendingMarketControllerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/ILendingMarketController.sol\";\nimport \"../libraries/DiscountFactor.sol\";\nimport \"../utils/Ownable.sol\";\n\ncontract LendingMarketControllerMock is ILendingMarketController, Ownable {\n    mapping(bytes32 => mapping(uint256 => uint256)) public lendRates;\n    mapping(bytes32 => mapping(uint256 => uint256)) public borrowRates;\n    mapping(bytes32 => uint256[]) public supportedTerms;\n\n    constructor() {\n        _transferOwnership(msg.sender);\n    }\n\n    function initialize(address owner, address resolver) public {\n        _transferOwnership(owner);\n    }\n\n    /**\n     * @dev Triggers to get borrow rates for selected currency.\n     * @param _ccy Currency short identifier\n     */\n    function getBorrowRatesForCcy(bytes32 _ccy) public view override returns (uint256[] memory) {\n        uint256[] memory terms = supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint8 i = 0; i < terms.length; i++) {\n            uint256 borrowRate = borrowRates[_ccy][i];\n\n            rates[i] = borrowRate;\n        }\n\n        return rates;\n    }\n\n    /**\n     * @dev Triggers to get lend rates for selected currency.\n     * @param _ccy Currency short identifier\n     */\n    function getLendRatesForCcy(bytes32 _ccy) public view override returns (uint256[] memory) {\n        uint256[] memory terms = supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint8 i = 0; i < terms.length; i++) {\n            uint256 lendRate = lendRates[_ccy][i];\n\n            rates[i] = lendRate;\n        }\n\n        return rates;\n    }\n\n    /**\n     * @dev Triggers to get mid rates for selected currency.\n     * @param _ccy Currency short identifier\n     */\n    function getMidRatesForCcy(bytes32 _ccy) public view override returns (uint256[] memory) {\n        uint256[] memory terms = supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint8 i = 0; i < terms.length; i++) {\n            uint256 borrowRate = borrowRates[_ccy][i];\n            uint256 lendRate = lendRates[_ccy][i];\n            uint256 combinedRate = borrowRate + lendRate;\n\n            rates[i] = combinedRate / 2;\n        }\n\n        return rates;\n    }\n\n    /**\n     * @dev Triggers to set borrow rates for selected currency.\n     * @param _ccy Currency short identifier\n     */\n    function setBorrowRatesForCcy(bytes32 _ccy, uint256[] memory _rates) public onlyOwner {\n        for (uint8 i = 0; i < _rates.length; i++) {\n            borrowRates[_ccy][i] = _rates[i];\n        }\n    }\n\n    /**\n     * @dev Triggers to set lend rates for selected currency.\n     * @param _ccy Currency short identifier\n     */\n    function setLendRatesForCcy(bytes32 _ccy, uint256[] memory _rates) public onlyOwner {\n        for (uint8 i = 0; i < _rates.length; i++) {\n            lendRates[_ccy][i] = _rates[i];\n        }\n    }\n\n    function getDiscountFactorsForCcy(bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256[] memory, uint256[] memory)\n    {\n        uint256[] memory rates = getMidRatesForCcy(_ccy);\n\n        return DiscountFactor.calculateDFs(rates, supportedTerms[_ccy]);\n    }\n\n    // =========== UNUSED FUNCTIONS ===========\n\n    function deployLendingMarket(bytes32 _ccy, uint256 _term)\n        public\n        pure\n        override\n        returns (address)\n    {\n        _ccy;\n        _term;\n        return address(0);\n    }\n\n    function getLendingMarket(bytes32 _ccy, uint256 _term) public pure override returns (address) {\n        _ccy;\n        _term;\n        return address(0);\n    }\n\n    function pauseLendingMarkets(bytes32 _ccy) public pure override returns (bool) {\n        _ccy;\n        return true;\n    }\n\n    function unpauseLendingMarkets(bytes32 _ccy) public pure override returns (bool) {\n        _ccy;\n        return true;\n    }\n\n    function placeBulkOrders(Order[] memory orders) public pure override returns (bool) {\n        orders;\n        return true;\n    }\n\n    function setSupportedTerms(bytes32 _ccy, uint256[] memory terms) public {\n        supportedTerms[_ccy] = terms;\n    }\n\n    function getSupportedTerms(bytes32 _ccy) public view override returns (uint256[] memory) {\n        return supportedTerms[_ccy];\n    }\n}\n"
    },
    "contracts/test/DiscountFactorTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/DiscountFactor.sol\";\n\ncontract DiscountFactorTest {\n    function bootstrapTerms(uint256[] memory rates, uint256[] memory terms)\n        external\n        pure\n        returns (uint256[] memory, uint256[] memory)\n    {\n        return DiscountFactor.bootstrapTerms(rates, terms);\n    }\n\n    function getGasCostOfBootstrapTerms(uint256[] memory rates, uint256[] memory terms)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        DiscountFactor.bootstrapTerms(rates, terms);\n\n        return gasBefore - gasleft();\n    }\n\n    function calculateDFs(uint256[] memory rates, uint256[] memory terms)\n        external\n        pure\n        returns (uint256[] memory, uint256[] memory)\n    {\n        return DiscountFactor.calculateDFs(rates, terms);\n    }\n\n    function getGasCostOfCalculateDFs(uint256[] memory rates, uint256[] memory terms)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        DiscountFactor.calculateDFs(rates, terms);\n\n        return gasBefore - gasleft();\n    }\n\n    function interpolateDF(\n        uint256[] memory discountFactors,\n        uint256[] memory terms,\n        uint256 date\n    ) external view returns (uint256) {\n        return DiscountFactor.interpolateDF(discountFactors, terms, date);\n    }\n\n    function getGasCostOfInterpolateDF(\n        uint256[] memory discountFactors,\n        uint256[] memory terms,\n        uint256 date\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        DiscountFactor.interpolateDF(discountFactors, terms, date);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/CrosschainAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./interfaces/ICrosschainAddressResolver.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\nimport \"./utils/Proxyable.sol\";\nimport {CrosschainAddressResolverStorage as Storage} from \"./storages/CrosschainAddressResolverStorage.sol\";\n\ncontract CrosschainAddressResolver is ICrosschainAddressResolver, MixinAddressResolver, Proxyable {\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(address resolver) public initializer onlyProxy {\n        registerAddressResolver(resolver);\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](1);\n        contracts[0] = Contracts.COLLATERAL_AGGREGATOR;\n    }\n\n    function acceptedContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](1);\n        contracts[0] = Contracts.COLLATERAL_AGGREGATOR;\n    }\n\n    /**\n     * @dev Triggers to register multiple cross-chain addresses per chainId for user\n     * @param _user Secured Finance user ETH address\n     * @param _chainIds Array of chain ID number\n     * @param _addresses Array of the target blockchain addresses\n     *\n     * @notice This function triggers by the Collateral Aggregator while user is registered in a system\n     *\n     */\n    function updateAddresses(\n        address _user,\n        uint256[] memory _chainIds,\n        string[] memory _addresses\n    ) public override onlyAcceptedContracts {\n        require(_chainIds.length == _addresses.length, \"Invalid input lengths\");\n\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            _updateAddress(_user, _chainIds[i], _addresses[i]);\n        }\n    }\n\n    /**\n     * @dev Triggers to register cross-chain address per chainId by user\n     * @param _chainId Chain ID number\n     * @param _address Target blockchain address\n     *\n     * @notice This function triggers by the user, and stores addresses for `msg.sender`\n     *\n     */\n    function updateAddress(uint256 _chainId, string memory _address) public override {\n        _updateAddress(msg.sender, _chainId, _address);\n    }\n\n    /**\n     * @dev Triggers to register cross-chain address per chainId by user\n     * @param _user Secured Finance user ETH address\n     * @param _chainId Chain ID number\n     * @param _address Target blockchain address\n     *\n     * @notice This function triggers by the Collateral Aggregator while user is registered in a system\n     *\n     */\n    function updateAddress(\n        address _user,\n        uint256 _chainId,\n        string memory _address\n    ) public override onlyAcceptedContracts {\n        _updateAddress(_user, _chainId, _address);\n    }\n\n    /**\n     * @dev Triggers to get target blockchain address for a specific user.\n     * @param _user Ethereum address of the Secured Finance user\n     * @param _user Chain ID number\n     */\n    function getUserAddress(address _user, uint256 _chainId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        return Storage.slot().crosschainAddreses[_user][_chainId];\n    }\n\n    /**\n     * @dev Internal function to store cross-chain addresses for user by chainID\n     * @param _user Secured Finance user ETH address\n     * @param _chainId Chain ID number\n     * @param _address Target blockchain address\n     *\n     */\n    function _updateAddress(\n        address _user,\n        uint256 _chainId,\n        string memory _address\n    ) internal {\n        Storage.slot().crosschainAddreses[_user][_chainId] = _address;\n        emit UpdateAddress(_user, _chainId, _address);\n    }\n}\n"
    },
    "contracts/storages/CrosschainAddressResolverStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary CrosschainAddressResolverStorage {\n    bytes32 internal constant STORAGE_SLOT = keccak256(\"sf.storage.crosschainAddressResolver\");\n\n    struct Storage {\n        // Mapping for storing user cross-chain addresses\n        mapping(address => mapping(uint256 => string)) crosschainAddreses;\n    }\n\n    function slot() internal pure returns (Storage storage r) {\n        bytes32 _slot = STORAGE_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := _slot\n        }\n    }\n}\n"
    },
    "contracts/CloseOutNetting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./libraries/CloseOut.sol\";\nimport \"./interfaces/ICloseOutNetting.sol\";\nimport \"./mixins/MixinAddressResolver.sol\";\nimport \"./utils/Proxyable.sol\";\nimport {CloseOutNettingStorage as Storage} from \"./storages/CloseOutNettingStorage.sol\";\n\n/**\n * @title Close Out Netting contract is used in close out operations\n * Close out is the process while one of the counterparties declared\n * as defaulted party and all deals should be terminated\n *\n * Contract linked to all product based contracts (ex. Loan, Swap, etc), and Collateral Aggregator contract.\n */\ncontract CloseOutNetting is ICloseOutNetting, MixinAddressResolver, Proxyable {\n    /**\n     * @dev Modifier to make a function callable only by defaulted counterparty.\n     */\n    modifier defaultedParty() {\n        require(Storage.slot().isDefaulted[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by non defaulted counterparty.\n     */\n    modifier nonDefaultedParty() {\n        require(!Storage.slot().isDefaulted[msg.sender]);\n        _;\n    }\n\n    /**\n     * @notice Initializes the contract.\n     * @dev Function is invoked by the proxy contract when the contract is added to the ProxyController\n     */\n    function initialize(address resolver) public initializer onlyProxy {\n        registerAddressResolver(resolver);\n    }\n\n    function requiredContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](1);\n        contracts[0] = Contracts.PAYMENT_AGGREGATOR;\n    }\n\n    function acceptedContracts() public pure override returns (bytes32[] memory contracts) {\n        contracts = new bytes32[](1);\n        contracts[0] = Contracts.PAYMENT_AGGREGATOR;\n    }\n\n    /**\n     * @dev Returns the close out payment between two counterparties\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     */\n    function getCloseOutPayment(\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) public view returns (CloseOut.Payment memory payment) {\n        payment = CloseOut.get(Storage.slot().closeOuts, party0, party1, ccy);\n    }\n\n    /**\n     * @dev Triggers to add total payments during the registration of the deal in close out netting\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main settlement currency of the deal\n     * @param payment0 Aggregated payment for first counterparty\n     * @param payment1 Aggregated payment for second counterparty\n     *\n     * @notice Executed only be PaymentAggregator contract\n     */\n    function addPayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) external override onlyAcceptedContracts {\n        CloseOut.addPayments(Storage.slot().closeOuts, party0, party1, ccy, payment0, payment1);\n\n        emit AddCloseOutPayments(party0, party1, ccy, payment0, payment1);\n    }\n\n    /**\n     * @dev Triggers to remove aggregated payments during the liquidation of the deal in close out netting\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main settlement currency of the deal\n     * @param payment0 Aggregated payment for first counterparty\n     * @param payment1 Aggregated payment for second counterparty\n     *\n     * @notice Executed only be PaymentAggregator contract\n     */\n    function removePayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) external override onlyAcceptedContracts {\n        CloseOut.removePayments(Storage.slot().closeOuts, party0, party1, ccy, payment0, payment1);\n\n        emit RemoveCloseOutPayments(party0, party1, ccy, payment0, payment1);\n    }\n\n    /**\n     * @dev External function to check if `_party` is in default\n     */\n    function checkDefault(address _party) external view override returns (bool) {\n        return Storage.slot().isDefaulted[_party];\n    }\n\n    /**\n     * @dev Internal function to declare default for `_defaultedParty`\n     */\n    function _handleDefault(address _defaultedParty) internal {\n        Storage.slot().isDefaulted[_defaultedParty] = true;\n    }\n\n    // TODO: Need to update using CollateralAggregatorV2\n    // /**\n    //  * @dev Internal function to execute close out netting payment\n    //  * liquidates ETH from party's collateral with bigger net payment to their counterparty\n    //  * @notice Only triggers if one of the counterparties in default\n    //  */\n    // function _handleCloseOut(address party0, address party1) internal {\n    //     require(\n    //         Storage.slot().isDefaulted[party0] || Storage.slot().isDefaulted[party1],\n    //         \"NON_DEFAULTED_PARTIES\"\n    //     );\n    //     bytes32[] memory currencies = collateralAggregator.getExposedCurrencies(\n    //         party0,\n    //         party1\n    //     );\n\n    //     for (uint256 i = 0; i < currencies.length; i++) {\n    //         bytes32 ccy = currencies[i];\n\n    //         CloseOut.Payment memory payment = CloseOut.get(\n    //             Storage.slot().closeOuts,\n    //             party0,\n    //             party1,\n    //             ccy\n    //         );\n\n    //         if (payment.flipped) {\n    //             collateralAggregator.liquidate(\n    //                 party1,\n    //                 party0,\n    //                 ccy,\n    //                 payment.netPayment\n    //             );\n    //         } else {\n    //             collateralAggregator.liquidate(\n    //                 party0,\n    //                 party1,\n    //                 ccy,\n    //                 payment.netPayment\n    //             );\n    //         }\n\n    //         CloseOut.close(Storage.slot().closeOuts, party0, party1, ccy);\n    //     }\n    // }\n}\n"
    },
    "contracts/test/AddressPackingTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"../libraries/AddressPacking.sol\";\n\ncontract AddressPackingTest {\n    function pack(address party0, address party1) external pure returns (bytes32, bool) {\n        return AddressPacking.pack(party0, party1);\n    }\n\n    function getGasCostOfPack(address party0, address party1) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        AddressPacking.pack(party0, party1);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/test/StringsTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/Strings.sol\";\n\ncontract StringsTest {\n    function isEqual(string memory text0, string memory text1) external pure returns (bool) {\n        return Strings.isEqual(text0, text1);\n    }\n\n    function toHex(bytes32 _hash) external pure returns (string memory) {\n        return Strings.toHex(_hash);\n    }\n\n    function toHex16(bytes16 _halfOfHash) external pure returns (bytes32) {\n        return Strings.toHex16(_halfOfHash);\n    }\n\n    function getGasCostOfIsEqual(string memory text0, string memory text1)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        Strings.isEqual(text0, text1);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfToHex(bytes32 _hash) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        Strings.toHex(_hash);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfToHex16(bytes16 _halfOfHash) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        Strings.toHex16(_halfOfHash);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/test/TermScheduleTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport \"../libraries/TermSchedule.sol\";\n\ncontract TermScheduleTest {\n    function getTermSchedule(uint256 numDays, uint8 frequency)\n        external\n        pure\n        returns (uint256[] memory)\n    {\n        return TermSchedule.getTermSchedule(numDays, frequency);\n    }\n\n    function getNumPayments(uint256 numDays, uint8 frequency) external pure returns (uint256) {\n        return TermSchedule.getNumPayments(numDays, frequency);\n    }\n\n    function getDfFrac(uint256 numDays) external pure returns (uint256) {\n        return TermSchedule.getDfFrac(numDays);\n    }\n\n    function getGasCostOfGetTermSchedule(uint256 numDays, uint8 frequency)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        TermSchedule.getTermSchedule(numDays, frequency);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetNumPayment(uint256 numDays, uint8 frequency)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        TermSchedule.getNumPayments(numDays, frequency);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetDfFrac(uint256 numDays) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        TermSchedule.getDfFrac(numDays);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}