{
  "language": "Solidity",
  "sources": {
    "contracts/SettlementEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12 <=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./libraries/Strings.sol\";\nimport \"./libraries/SafeTransfer.sol\";\nimport \"./interfaces/IExternalAdapter.sol\";\nimport \"./interfaces/ISettlementEngine.sol\";\nimport \"./interfaces/ICurrencyController.sol\";\nimport \"./interfaces/ILiquidations.sol\";\nimport \"./interfaces/IPaymentAggregator.sol\";\nimport \"./interfaces/ICrosschainAddressResolver.sol\";\nimport \"./interfaces/IExternalAdapterTxResponse.sol\";\n\n/**\n * @title Settlement Engine contract is used in settlement operations\n * of the Secured Finance protocol. Settlement is divided per 1 calendar\n * day and verified by either external adapters (for cross-chain transaction)\n * or native ETH-chain settlement.\n *\n * Contract linked to the PaymentAggregator contract and all External Adapters per target chain.\n */\ncontract SettlementEngine is\n    ISettlementEngine,\n    IExternalAdapterTxResponse,\n    SafeTransfer\n{\n    using SafeMath for uint256;\n    using Address for address;\n    using Strings for string;\n\n    struct SettlementRequest {\n        address payer;\n        address receiver;\n        uint16 chainId;\n        uint256 timestamp;\n        string txHash;\n    }\n\n    address public override owner;\n    uint16 private constant VERSION = 1;\n\n    ICurrencyController private currencyController;\n    ILiquidations private liquidationEngine;\n    IPaymentAggregator private paymentAggregator;\n    ICrosschainAddressResolver private crosschainResolver;\n\n    // Mapping to external providers addresses by Chain Ids\n    // for ETH-based currencies there is no need for external adapters\n    mapping(uint16 => address) public override externalAdapters;\n\n    // Mapping of cross-chain settlement requests per requestId\n    mapping(bytes32 => SettlementRequest) public override settlementRequests;\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"INVALID_ACCESS\");\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     *\n     * @notice sets contract deployer as owner of this contract\n     */\n    constructor(\n        address _paymentAggregator,\n        address _currencyController,\n        address _crosschainResolver,\n        address _WETH9\n    ) public SafeTransfer(_WETH9) {\n        owner = msg.sender;\n\n        paymentAggregator = IPaymentAggregator(_paymentAggregator);\n        currencyController = ICurrencyController(_currencyController);\n        crosschainResolver = ICrosschainAddressResolver(_crosschainResolver);\n    }\n\n    /**\n     * @dev Trigers to add new external adapter for specific `_ccy`\n     * @param _adapter External adapter contract address\n     * @param _ccy Short identifier of a currency\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function addExternalAdapter(address _adapter, bytes32 _ccy)\n        public\n        override\n        onlyOwner\n    {\n        require(_adapter.isContract(), \"NOT_CONTRACT\");\n        require(currencyController.isSupportedCcy(_ccy), \"NON_SUPPORTED_CCY\");\n\n        uint16 chainId = currencyController.getChainId(_ccy);\n        require(chainId != 60, \"NOT_ANOTHER_CHAIN\");\n        require(\n            externalAdapters[chainId] == address(0),\n            \"CAN'T_REPLACE_EXTERNAL_ADAPTER\"\n        );\n\n        externalAdapters[chainId] = _adapter;\n\n        emit ExternalAdapterAdded(_adapter, _ccy);\n    }\n\n    /**\n     * @dev Trigers to replace existing external adapter for specific `_ccy`\n     * @param _adapter External adapter contract address\n     * @param _ccy Short identifier of a currency\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function replaceExternalAdapter(address _adapter, bytes32 _ccy)\n        public\n        override\n        onlyOwner\n    {\n        require(_adapter.isContract(), \"NOT_CONTRACT\");\n        uint16 chainId = currencyController.getChainId(_ccy);\n\n        require(\n            externalAdapters[chainId] != address(0),\n            \"ADAPTER_DOESN'T_EXIST\"\n        );\n\n        externalAdapters[chainId] = _adapter;\n\n        emit ExternalAdapterUpdated(_adapter, _ccy);\n    }\n\n    /**\n     * @dev External function to verify payment by msg.sender as a part of a settlement process\n     * It could validate either a cross-chain settlment or native settlement\n     * @param _counterparty Counterparty address\n     * @param _ccy Main payment settlement currency\n     * @param _payment Payment amount in currency\n     * @param _timestamp Timeslot timestamp for settlement operation\n     * @param _txHash Cross-chain transfer txHash\n     */\n    function verifyPayment(\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _payment,\n        uint256 _timestamp,\n        string memory _txHash\n    ) external payable override returns (bytes32) {\n        // TODO: add a way for third party to trigger ERC20 approved coupon payments\n        uint16 chainId = currencyController.getChainId(_ccy);\n        bytes32 requestId;\n\n        require(\n            !paymentAggregator.isSettled(\n                msg.sender,\n                _counterparty,\n                _ccy,\n                _timestamp\n            ),\n            \"TIMESLOT_SETTLED_ALREADY\"\n        );\n\n        if (chainId == 60) {\n            _performNativeSettlement(\n                msg.sender,\n                _counterparty,\n                _ccy,\n                _payment,\n                _timestamp\n            );\n        } else {\n            requestId = _performCrosschainSettlement(\n                msg.sender,\n                _counterparty,\n                chainId,\n                _timestamp,\n                _txHash\n            );\n        }\n\n        return requestId;\n    }\n\n    /**\n     * @dev External function to fullfill cross-chain settlement request.\n     * Expects to get transaction object to validate the correct settlement values\n     * on the PaymentAggregator contract level\n     * @param _txData Transaction object from external adapter\n     * @param _ccy Main currency of the external adapter\n     *\n     * @notice Trigers only be external adapter for specific chain\n     */\n    function fullfillSettlementRequest(\n        bytes32 _requestId,\n        FulfillData memory _txData,\n        bytes32 _ccy\n    ) external override {\n        uint16 chainId = currencyController.getChainId(_ccy);\n        require(\n            externalAdapters[chainId] == msg.sender,\n            \"NOT_EXTERNAL_ADAPTER\"\n        );\n\n        SettlementRequest memory request = settlementRequests[_requestId];\n        _validateSettlementRequest(chainId, request, _txData);\n\n        bytes32 _settlementId = keccak256(abi.encodePacked(_txData.txHash));\n\n        paymentAggregator.verifyPayment(\n            request.payer,\n            request.receiver,\n            _ccy,\n            request.timestamp,\n            _txData.value,\n            _settlementId\n        );\n\n        emit CrosschainSettlementRequestFulfilled(\n            _txData.from,\n            _txData.to,\n            chainId,\n            _txData.value,\n            _txData.timestamp,\n            _txData.txHash,\n            _settlementId\n        );\n\n        delete settlementRequests[_requestId];\n    }\n\n    /**\n     * @dev Internal function to create a settlement validation request for an external adapter\n     * @param _payer Payer of the settlement transfer\n     * @param _counterparty Receiver of the settlement transfer\n     * @param _chainId Target chain id\n     * @param _txHash Target chain transaction hash\n     */\n    function _performCrosschainSettlement(\n        address _payer,\n        address _counterparty,\n        uint16 _chainId,\n        uint256 _timestamp,\n        string memory _txHash\n    ) internal returns (bytes32) {\n        require(msg.value == 0, \"INCORRECT_ETH_VALUE\");\n        require(\n            paymentAggregator.checkSettlementWindow(_timestamp),\n            \"OUT_OF_SETTLEMENT_WINDOW\"\n        );\n\n        address adapterAddr = externalAdapters[_chainId];\n        require(adapterAddr != address(0), \"ADAPTER_DOESN'T_EXIST\");\n        IExternalAdapter adapter = IExternalAdapter(adapterAddr);\n\n        bytes32 requestId = adapter.createRequest(_txHash);\n        // TODO: make sure we're not duplicating requests with the same txHashes\n        // on external adapter contract\n\n        settlementRequests[requestId] = SettlementRequest({\n            payer: _payer,\n            receiver: _counterparty,\n            chainId: _chainId,\n            timestamp: _timestamp,\n            txHash: _txHash\n        });\n\n        emit CrosschainSettlementRequested(\n            _payer,\n            _counterparty,\n            _chainId,\n            _timestamp,\n            _txHash,\n            requestId\n        );\n\n        return requestId;\n    }\n\n    /**\n     * @dev Internal function to settle payments on native ETH-based settlement.\n     * If currency is a ERC20 token it would transfer the `_payment` amount of tokens\n     * from msg.sender to `_counterparty` address.\n     * If currency is ETH, native Ether would be transfered accordingly\n     *\n     * @param _payer Payment sender address\n     * @param _counterparty Payment receiver address\n     * @param _ccy Main payment settlement currency\n     * @param _payment Payment amount in currency\n     */\n    function _performNativeSettlement(\n        address _payer,\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _payment,\n        uint256 _timestamp\n    ) internal {\n        if (_ccy == \"ETH\") {\n            require(msg.value == _payment, \"INCORRECT_ETH_VALUE\");\n            _safeTransferETH(_counterparty, msg.value);\n        } else {\n            require(msg.value == 0, \"INCORRECT_ETH_VALUE\");\n            address token = currencyController.tokenAddresses(_ccy);\n            require(token != address(0), \"INVALID_TOKEN_ADDRESS\");\n            _safeTransferFrom(token, _payer, _counterparty, _payment);\n        }\n\n        bytes32 _settlementId = keccak256(\n            abi.encodePacked(_payer, _counterparty, _ccy, _payment, _timestamp)\n        );\n\n        paymentAggregator.verifyPayment(\n            _payer,\n            _counterparty,\n            _ccy,\n            _timestamp,\n            _payment,\n            _settlementId\n        );\n    }\n\n    /**\n     * @dev Internal function to cross-chain settlement request against\n     * a transaction object from an external adapter\n     */\n    function _validateSettlementRequest(\n        uint16 _chainId,\n        SettlementRequest memory _request,\n        FulfillData memory _txData\n    ) internal view returns (bool) {\n        require(_request.txHash.isEqual(_txData.txHash), \"INCORRECT_TX_HASH\");\n\n        string memory payerAddress = crosschainResolver.getUserAddress(\n            _request.payer,\n            _chainId\n        );\n\n        string memory receiverAddress = crosschainResolver.getUserAddress(\n            _request.receiver,\n            _chainId\n        );\n\n        require(payerAddress.isEqual(_txData.from), \"INCORRECT_ADDRESS_FROM\");\n        require(receiverAddress.isEqual(_txData.to), \"INCORRECT_ADDRESS_TO\");\n    }\n\n    /**\n     * @dev Get the version of the underlying contract\n     * @return implementation version\n     */\n    function getVersion() public view override returns (uint16) {\n        return VERSION;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nlibrary Strings {\n    /**\n     * @dev Helper function to check wether strings are equal\n     * @param text0 First string to compare\n     * @param text1 Second string to compare\n     * @return Boolean statement\n     */\n    function isEqual(string memory text0, string memory text1)\n        internal\n        pure\n        returns (bool)\n    {\n        return\n            keccak256(abi.encodePacked(text0)) ==\n            keccak256(abi.encodePacked(text1));\n    }\n\n    function toHex(bytes32 data) public pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"0x\",\n                    toHex16(bytes16(data)),\n                    toHex16(bytes16(data << 128))\n                )\n            );\n    }\n\n    function toHex16(bytes16 data) internal pure returns (bytes32 result) {\n        result =\n            (bytes32(data) &\n                0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000) |\n            ((bytes32(data) &\n                0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000) >>\n                64);\n        result =\n            (result &\n                0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000) |\n            ((result &\n                0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000) >>\n                32);\n        result =\n            (result &\n                0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000) |\n            ((result &\n                0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000) >>\n                16);\n        result =\n            (result &\n                0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000) |\n            ((result &\n                0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000) >>\n                8);\n        result =\n            ((result &\n                0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000) >>\n                4) |\n            ((result &\n                0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00) >>\n                8);\n        result = bytes32(\n            0x3030303030303030303030303030303030303030303030303030303030303030 +\n                uint256(result) +\n                (((uint256(result) +\n                    0x0606060606060606060606060606060606060606060606060606060606060606) >>\n                    4) &\n                    0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F) *\n                7\n        );\n    }\n}\n"
    },
    "contracts/libraries/SafeTransfer.sol": {
      "content": "pragma solidity 0.6.12;\n\nimport \"../interfaces/IWETH9.sol\";\n\nabstract contract SafeTransfer {\n    address public immutable WETH9;\n\n    constructor(address _WETH9) public {\n        WETH9 = _WETH9;\n    }\n\n    receive() external payable {\n        require(msg.sender == WETH9, \"Not WETH9\");\n    }\n\n    function _depositAssets(\n        address _token,\n        address _payer,\n        address _receiver,\n        uint256 _amount\n    ) internal {\n        if (address(_token) == WETH9 && address(this).balance >= _amount) {\n            _wrapWETH(_receiver, _amount);\n        } else if (_receiver == address(this)) {\n            _safeTransferFrom(_token, _payer, _amount);\n        } else {\n            _safeTransferFrom(_token, _payer, _receiver, _amount);\n        }\n    }\n\n    function _withdrawAssets(\n        address _token,\n        address _receiver,\n        uint256 _amount\n    ) internal {\n        if (address(_token) == WETH9) {\n            _unwrapWETH(_receiver, _amount);\n        } else {\n            _safeTransfer(_token, _receiver, _amount);\n        }\n    }\n\n    function _wrapWETH(address _receiver, uint256 _amount) internal {\n        _amount = msg.value;\n\n        IWETH9(WETH9).deposit{value: _amount}();\n        IWETH9(WETH9).transfer(_receiver, _amount);\n    }\n\n    function _unwrapWETH(address _receiver, uint256 _amount) internal {\n        uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));\n        require(balanceWETH9 >= _amount, \"Insufficient WETH9\");\n\n        if (balanceWETH9 > 0) {\n            IWETH9(WETH9).withdraw(_amount);\n            _safeTransferETH(_receiver, _amount);\n        }\n    }\n\n    /// @dev Transfer helper from UniswapV2 Router\n    function _safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    /**\n     * There are many non-compliant ERC20 tokens... this can handle most, adapted from UniSwap V2\n     * Im trying to make it a habit to put external calls last (reentrancy)\n     * You can put this in an internal function if you like.\n     */\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // 0xa9059cbb = bytes4(keccak256(\"transfer(address,uint256)\"))\n            abi.encodeWithSelector(0xa9059cbb, to, amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        ); // ERC20 Transfer failed\n    }\n\n    function _safeTransferFrom(\n        address token,\n        address from,\n        uint256 amount\n    ) internal virtual {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, bytes memory data) = token.call(\n            // 0x23b872dd = bytes4(keccak256(\"transferFrom(address,address,uint256)\"))\n            abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        ); // ERC20 TransferFrom failed\n    }\n\n    function _safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    },
    "contracts/interfaces/IExternalAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface IExternalAdapter {\n    function createRequest(string memory _txHash)\n        external\n        returns (bytes32 requestId);\n\n    function cancelRequest(\n        bytes32 _requestId,\n        bytes4 _callbackFunctionId,\n        uint256 _expiration\n    ) external;\n\n    function fulfill(\n        bytes32 _requestId,\n        string calldata _from,\n        string calldata _to,\n        uint256 _value,\n        uint256 _timestamp\n    ) external;\n}\n"
    },
    "contracts/interfaces/ISettlementEngine.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\npragma solidity >=0.6.12 <=0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"./IExternalAdapterTxResponse.sol\";\n\ninterface ISettlementEngine {\n    event CrosschainSettlementRequested(\n        address payer,\n        address receiver,\n        uint16 chainId,\n        uint256 timestamp,\n        string txHash,\n        bytes32 requestId\n    );\n    event CrosschainSettlementRequestFulfilled(\n        string payer,\n        string receiver,\n        uint16 chainId,\n        uint256 amount,\n        uint256 timestamp,\n        string txHash,\n        bytes32 settlementId\n    );\n    event ExternalAdapterAdded(address indexed adapter, bytes32 ccy);\n    event ExternalAdapterUpdated(address indexed adapter, bytes32 ccy);\n\n    function addExternalAdapter(address _adapter, bytes32 _ccy) external;\n\n    function externalAdapters(uint16) external view returns (address);\n\n    function fullfillSettlementRequest(\n        bytes32 _requestId,\n        IExternalAdapterTxResponse.FulfillData memory _txData,\n        bytes32 _ccy\n    ) external;\n\n    function getVersion() external view returns (uint16);\n\n    function owner() external view returns (address);\n\n    function replaceExternalAdapter(address _adapter, bytes32 _ccy) external;\n\n    function settlementRequests(bytes32)\n        external\n        view\n        returns (\n            address payer,\n            address receiver,\n            uint16 chainId,\n            uint256 timestamp,\n            string memory txHash\n        );\n\n    function verifyPayment(\n        address _counterparty,\n        bytes32 _ccy,\n        uint256 _payment,\n        uint256 _timestamp,\n        string calldata _txHash\n    ) external payable returns (bytes32);\n}\n"
    },
    "contracts/interfaces/ICurrencyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev Currency Controller contract is responsible for managing supported\n * currencies in Secured Finance Protocol\n *\n * Contract links new currencies to ETH Chainlink price feeds, without existing price feed\n * contract owner is not able to add a new currency into the protocol\n *\n * Currency controller contract copies the logic of FXRatesAggregator contract, and\n * will replace that contract in connection with Collateral Aggregator\n */\ninterface ICurrencyController {\n    event CcyAdded(\n        bytes32 indexed ccy,\n        string name,\n        uint16 chainId,\n        uint256 haircut\n    );\n    event CcyCollateralUpdate(bytes32 indexed ccy, bool isCollateral);\n    event CcySupportUpdate(bytes32 indexed ccy, bool isSupported);\n    event HaircutUpdated(bytes32 indexed ccy, uint256 haircut);\n    event MinMarginUpdated(bytes32 indexed ccy, uint256 minMargin);\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n    event PriceFeedAdded(\n        bytes32 ccy,\n        string secondCcy,\n        address indexed priceFeed\n    );\n    event PriceFeedRemoved(\n        bytes32 ccy,\n        string secondCcy,\n        address indexed priceFeed\n    );\n\n    function convertBulkToETH(bytes32 _ccy, uint256[] memory _amounts)\n        external\n        view\n        returns (uint256[] memory);\n\n    function convertFromETH(bytes32 _ccy, uint256 _amountETH)\n        external\n        view\n        returns (uint256);\n\n    function convertToETH(bytes32 _ccy, uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    function currencies(bytes32)\n        external\n        view\n        returns (\n            bool isSupported,\n            string memory name,\n            uint16 chainId\n        );\n\n    function ethDecimals(bytes32) external view returns (uint8);\n\n    function getHaircut(bytes32 _ccy) external view returns (uint256);\n\n    function getHistoricalETHPrice(bytes32 _ccy, uint80 _roundId)\n        external\n        view\n        returns (int256);\n\n    function getHistoricalUSDPrice(bytes32 _ccy, uint80 _roundId)\n        external\n        view\n        returns (int256);\n\n    function getLastETHPrice(bytes32 _ccy) external view returns (int256);\n\n    function getLastUSDPrice(bytes32 _ccy) external view returns (int256);\n\n    function getMinMargin(bytes32 _ccy) external view returns (uint256);\n\n    function getChainId(bytes32 _ccy) external view returns (uint16);\n\n    function haircuts(bytes32) external view returns (uint256);\n\n    function isCollateral(bytes32) external view returns (bool);\n\n    function isSupportedCcy(bytes32 _ccy) external view returns (bool);\n\n    function last_ccy_index() external view returns (uint8);\n\n    function linkPriceFeed(\n        bytes32 _ccy,\n        address _priceFeedAddr,\n        bool _isEthPriceFeed\n    ) external returns (bool);\n\n    function minMargins(bytes32) external view returns (uint256);\n\n    function owner() external view returns (address);\n\n    function removePriceFeed(bytes32 _ccy, bool _isEthPriceFeed) external;\n\n    function setOwner(address _owner) external;\n\n    function supportCurrency(\n        bytes32 _ccy,\n        string memory _name,\n        uint16 _chainId,\n        address _ethPriceFeed,\n        uint256 _haircut,\n        address _tokenAddress\n    ) external returns (bool);\n\n    function supportedCurrencies() external view returns (uint8);\n\n    function updateCcyHaircut(bytes32 _ccy, uint256 _haircut)\n        external\n        returns (bool);\n\n    function updateCollateralSupport(bytes32 _ccy, bool _isSupported)\n        external\n        returns (bool);\n\n    function updateCurrencySupport(bytes32 _ccy, bool _isSupported)\n        external\n        returns (bool);\n\n    function updateMinMargin(bytes32 _ccy, uint256 _minMargin)\n        external\n        returns (bool);\n\n    function usdDecimals(bytes32) external view returns (uint8);\n\n    function tokenAddresses(bytes32) external view returns (address);\n}\n"
    },
    "contracts/interfaces/ILiquidations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface ILiquidations {\n    event DealAddedToLiquidationQueue(\n        address party0,\n        address party1,\n        bytes32 dealId\n    );\n    event DealRemovedFromLiquidationQueue(\n        address party0,\n        address party1,\n        bytes32 dealId\n    );\n    event LinkedContract(address addr);\n    event LiquidationAgentAdded(address indexed liquidationAgent);\n    event LiquidationAgentRemoved(address indexed liquidationAgent);\n    event OffsetUpdated(uint256 oldOffset, uint256 newOffset);\n    event OwnerUpdated(address indexed oldOwner, address indexed newOwner);\n\n    function addDealToLiquidationQueue(\n        address party0,\n        address party1,\n        bytes32 dealId\n    ) external;\n\n    function addLiquidationAgent(address _liquidationAgent) external;\n\n    function linkContract(address _addr) external;\n\n    function liquidateDeals(\n        address party0,\n        address party1,\n        bytes32[] memory dealIds\n    ) external;\n\n    function liquidateDeals(address party0, address party1) external;\n\n    function offset() external view returns (uint256);\n\n    function removeDealFromLiquidationQueue(\n        address party0,\n        address party1,\n        bytes32 dealId\n    ) external;\n\n    function removeLiquidationAgent(address _liquidationAgent) external;\n\n    function updateLiquidationOffset(uint256 _offset) external;\n}\n"
    },
    "contracts/interfaces/IPaymentAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nstruct Slot {\n    uint256 totalPayment0;\n    uint256 totalPayment1;\n    uint256 netPayment;\n    bool flipped;\n    bytes32 paymentProof;\n    address verificationParty;\n    bool isSettled;\n}\n\ninterface IPaymentAggregator {\n    event UpdateCloseOutNetting(\n        address indexed prevContract,\n        address indexed closeOutNetting\n    );\n    event UpdateMarkToMarket(\n        address indexed prevContract,\n        address indexed closeOutNetting\n    );\n    event UpdateSettlementEngine(\n        address indexed prevContract,\n        address indexed settlementEngine\n    );\n\n    event RegisterPayment(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        bytes32 timeSlot,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 payment0,\n        uint256 payment1\n    );\n    event VerifyPayment(\n        address indexed verifier,\n        address indexed counterparty,\n        bytes32 ccy,\n        bytes32 timeSlot,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 payment,\n        bytes32 settlementId\n    );\n    event SettlePayment(\n        address indexed verifier,\n        address indexed counterparty,\n        bytes32 ccy,\n        bytes32 timeSlot,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        bytes32 settlementId\n    );\n    event RemovePayment(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        bytes32 timeSlot,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 payment0,\n        uint256 payment1\n    );\n\n    function addPaymentAggregatorUser(address _user) external returns (bool);\n\n    function isPaymentAggregatorUser(address _user)\n        external\n        view\n        returns (bool);\n\n    function owner() external view returns (address);\n\n    function registerPayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] memory timestamps,\n        uint256[] memory payments0,\n        uint256[] memory payments1\n    ) external;\n\n    function removePaymentAggregatorUser(address _user) external returns (bool);\n\n    function removePayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] calldata timestamps,\n        uint256[] calldata payments0,\n        uint256[] calldata payments1\n    ) external;\n\n    function verifyPayment(\n        address verifier,\n        address counterparty,\n        bytes32 ccy,\n        uint256 timestamp,\n        uint256 payment,\n        bytes32 settlementId\n    ) external;\n\n    function isSettled(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 timestamp\n    ) external view returns (bool status);\n\n    function getDealsFromSlot(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slotPosition\n    ) external view returns (bytes32[] memory);\n\n    // function getTimeSlotByDate(\n    //     address party0,\n    //     address party1,\n    //     bytes32 ccy,\n    //     uint256 year,\n    //     uint256 month,\n    //     uint256 day\n    // ) external view returns (Slot memory timeSlot);\n\n    // function getTimeSlotBySlotId(\n    //     address party0,\n    //     address party1,\n    //     bytes32 ccy,\n    //     bytes32 slot\n    // ) external view returns (Slot memory timeSlot);\n\n    function settlementWindow() external view returns (uint256);\n\n    function checkSettlementWindow(uint256 targetTime)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "contracts/interfaces/ICrosschainAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface ICrosschainAddressResolver {\n    event UpdateAddress(address _user, uint256 _chainId, string _address);\n\n    /**\n     * @dev Trigers to register multiple cross-chain addresses per chainId for user\n     * @param _user Secured Finance user ETH address\n     * @param _chainIds Array of chain ID number\n     * @param _addresses Array of the target blockchain addresses\n     *\n     * @notice This function triggers by the Collateral Aggregator while user is registered in a system\n     *\n     */\n    function updateAddresses(\n        address _user,\n        uint256[] memory _chainIds,\n        string[] memory _addresses\n    ) external;\n\n    /**\n     * @dev Trigers to register cross-chain address per chainId by user\n     * @param _chainId Chain ID number\n     * @param _address Target blockchain address\n     *\n     */\n    function updateAddress(uint256 _chainId, string memory _address) external;\n\n    /**\n     * @dev Trigers to register cross-chain address per chainId by user\n     * @param _user Secured Finance user ETH address\n     * @param _chainId Chain ID number\n     * @param _address Target blockchain address\n     *\n     */\n    function updateAddress(\n        address _user,\n        uint256 _chainId,\n        string memory _address\n    ) external;\n\n    /**\n     * @dev Trigers to get target blockchain address for a specific user.\n     * @param _user Ethereum address of the Secured Finance user\n     * @param _user Chain ID number\n     */\n    function getUserAddress(address _user, uint256 _chainId)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/interfaces/IExternalAdapterTxResponse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12 <=0.7.0;\npragma experimental ABIEncoderV2;\n\ninterface IExternalAdapterTxResponse {\n    struct FulfillData {\n        string from;\n        string to;\n        uint256 value;\n        uint256 timestamp;\n        string txHash;\n    }\n}\n"
    },
    "contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH9 is IERC20 {\n    event Deposit(address user, uint256 amount);\n    event Withdrawal(address user, uint256 amount);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/CrosschainAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./ProtocolTypes.sol\";\nimport \"./interfaces/ICrosschainAddressResolver.sol\";\nimport \"./interfaces/ICollateralAggregatorV2.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract CrosschainAddressResolver is ICrosschainAddressResolver {\n    using SafeMath for uint256;\n\n    address public owner;\n\n    // Mapping for storing user cross-chain addresses\n    mapping(address => mapping(uint256 => string)) _crosschainAddreses;\n\n    // Contracts\n    address collateralAggregator;\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyCollateralAggregator() {\n        require(msg.sender == collateralAggregator);\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     *\n     * @notice sets contract deployer as owner of this contract and connects to the collateral aggregator contract\n     */\n    constructor(address _collateralAggregator) public {\n        owner = msg.sender;\n        collateralAggregator = _collateralAggregator;\n    }\n\n    /**\n     * @dev Trigers to register multiple cross-chain addresses per chainId for user\n     * @param _user Secured Finance user ETH address\n     * @param _chainIds Array of chain ID number\n     * @param _addresses Array of the target blockchain addresses\n     *\n     * @notice This function triggers by the Collateral Aggregator while user is registered in a system\n     *\n     */\n    function updateAddresses(\n        address _user,\n        uint256[] memory _chainIds,\n        string[] memory _addresses\n    ) public override onlyCollateralAggregator {\n        require(_chainIds.length == _addresses.length, \"Invalid input lengths\");\n\n        for (uint256 i = 0; i < _chainIds.length; i++) {\n            _updateAddress(_user, _chainIds[i], _addresses[i]);\n        }\n    }\n\n    /**\n     * @dev Trigers to register cross-chain address per chainId by user\n     * @param _chainId Chain ID number\n     * @param _address Target blockchain address\n     *\n     * @notice This function triggers by the user, and stores addresses for `msg.sender`\n     *\n     */\n    function updateAddress(uint256 _chainId, string memory _address)\n        public\n        override\n    {\n        _updateAddress(msg.sender, _chainId, _address);\n    }\n\n    /**\n     * @dev Trigers to register cross-chain address per chainId by user\n     * @param _user Secured Finance user ETH address\n     * @param _chainId Chain ID number\n     * @param _address Target blockchain address\n     *\n     * @notice This function triggers by the Collateral Aggregator while user is registered in a system\n     *\n     */\n    function updateAddress(\n        address _user,\n        uint256 _chainId,\n        string memory _address\n    ) public override onlyCollateralAggregator {\n        _updateAddress(_user, _chainId, _address);\n    }\n\n    /**\n     * @dev Trigers to get target blockchain address for a specific user.\n     * @param _user Ethereum address of the Secured Finance user\n     * @param _user Chain ID number\n     */\n    function getUserAddress(address _user, uint256 _chainId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        return _crosschainAddreses[_user][_chainId];\n    }\n\n    /**\n     * @dev Internal function to store cross-chain addresses for user by chainID\n     * @param _user Secured Finance user ETH address\n     * @param _chainId Chain ID number\n     * @param _address Target blockchain address\n     *\n     */\n    function _updateAddress(\n        address _user,\n        uint256 _chainId,\n        string memory _address\n    ) internal {\n        _crosschainAddreses[_user][_chainId] = _address;\n        emit UpdateAddress(_user, _chainId, _address);\n    }\n}\n"
    },
    "contracts/ProtocolTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @dev ProtocolTypes is a base-level contract that holds common Secured Finance protocol types\n * @author Secured Finance\n */\ncontract ProtocolTypes {\n    // Constant values\n    uint8 internal constant NUMCCY = 3;\n    uint8 internal constant NUMTERM = 6;\n    uint8 internal constant NUMDF = 7; // number of discount factors\n    uint256 internal constant BP = 10000; // basis point\n\n    uint256 internal constant PCT = 10000; // percentage point in basis\n    uint256 internal constant PENALTYLEVEL = 1000; // 10% settlement failure penalty\n    uint256 internal constant MKTMAKELEVEL = 2000; // 20% for market making\n\n    // Lending market common types\n    enum Side {\n        LEND,\n        BORROW\n    }\n    enum Ccy {\n        ETH,\n        FIL,\n        USDC,\n        BTC\n    }\n\n    // Loan common types\n    enum LoanState {\n        REGISTERED,\n        WORKING,\n        DUE,\n        PAST_DUE,\n        CLOSED,\n        TERMINATED\n    }\n    enum DFTERM {\n        _3m,\n        _6m,\n        _1y,\n        _2y,\n        _3y,\n        _4y,\n        _5y\n    }\n\n    // Collateral common types\n    enum CollateralState {\n        EMPTY,\n        AVAILABLE,\n        IN_USE,\n        MARGIN_CALL,\n        LIQUIDATION_IN_PROGRESS,\n        LIQUIDATION\n    }\n\n    // FXMarket common types\n    enum CcyPair {\n        FILETH,\n        FILUSDC,\n        ETHUSDC,\n        BTCUSDC,\n        BTCETH,\n        BTCFIL\n    }\n    enum FXSide {\n        BID,\n        OFFER\n    }\n\n    enum PaymentFrequency {\n        ANNUAL,\n        SEMI_ANNUAL,\n        QUARTERLY,\n        MONTHLY,\n        FORWARD\n    }\n}\n"
    },
    "contracts/interfaces/ICollateralAggregatorV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface ICollateralAggregator {\n    event Register(address indexed addr);\n    event Release(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    );\n    event Liquidate(\n        address indexed from,\n        address indexed to,\n        bytes32 ccy,\n        uint256 amount\n    );\n    event ReleaseUnsettled(address indexed party, bytes32 ccy, uint256 amount);\n    event SettleCollateral(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    );\n    event UpdatePV(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    );\n    event UseCollateral(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    );\n    event UseUnsettledCollateral(\n        address indexed party,\n        bytes32 ccy,\n        uint256 amount\n    );\n\n    function checkRegisteredUser(address addr) external view returns (bool);\n\n    function enterVault(address _user) external;\n\n    function enterVault(address _party0, address _party1) external;\n\n    function exitVault(address _user) external;\n\n    function exitVault(address _party0, address _party1) external;\n\n    function getCcyExposures(\n        address partyA,\n        address partyB,\n        bytes32 ccy\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getCoverage(address _party0, address _party1)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getExposedCurrencies(address partyA, address partyB)\n        external\n        view\n        returns (bytes32[] memory);\n\n    function getMaxCollateralBookWidthdraw(address _user)\n        external\n        view\n        returns (uint256 maxWithdraw);\n\n    function getMaxCollateralWidthdraw(address _party0, address _party1)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getNetAndTotalPV(address _party0, address _party1)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getRebalanceCollateralAmounts(address _party0, address _party1)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getTotalUnsettledExp(address _user)\n        external\n        view\n        returns (uint256);\n\n    function getUnsettledCoverage(address _user)\n        external\n        view\n        returns (uint256 coverage);\n\n    function isCovered(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) external view returns (bool, bool);\n\n    function isCoveredUnsettled(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) external view returns (bool);\n\n    function liquidate(\n        address from,\n        address to,\n        uint256 liquidationInETH\n    ) external;\n\n    function liquidate(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 liquidationAmount,\n        uint256 pv,\n        bool isSettled\n    ) external;\n\n    function register() external;\n\n    function register(string[] memory _addresses, uint256[] memory _chainIds)\n        external;\n\n    function releaseCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external;\n\n    function releaseUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external;\n\n    function settleCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    ) external;\n\n    function updatePV(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) external;\n\n    function useCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external;\n\n    function useUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external;\n\n    function getUsedVaults(address user)\n        external\n        view\n        returns (address[] memory);\n\n    function getUsedVaults(address party0, address party1)\n        external\n        view\n        returns (address[] memory);\n}\n"
    },
    "contracts/test/TimeSlotTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/TimeSlot.sol\";\nimport \"../libraries/AddressPacking.sol\";\n\ncontract TimeSlotTest {\n    using TimeSlot for TimeSlot.Slot;\n    using SafeMath for uint256;\n\n    mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) _timeSlots;\n    bytes32 public ccy = \"0xSampleCCY\";\n\n    function position(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) external pure returns (bytes32) {\n        return TimeSlot.position(year, month, day);\n    }\n\n    function getGasCostOfPosition(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        TimeSlot.position(year, month, day);\n\n        return gasBefore - gasleft();\n    }\n\n    function get(\n        address party0,\n        address party1,\n        uint256 year,\n        uint256 month,\n        uint256 day\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        )\n    {\n        return TimeSlot.get(_timeSlots, party0, party1, ccy, year, month, day);\n    }\n\n    function getPaymentConfirmation(\n        address party0,\n        address party1,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        bytes32 settlementId\n    ) external view returns (address, uint256) {\n        return\n            TimeSlot.getPaymentConfirmation(\n                _timeSlots,\n                party0,\n                party1,\n                ccy,\n                year,\n                month,\n                day,\n                settlementId\n            );\n    }\n\n    function addPayment(\n        address party0,\n        address party1,\n        bytes32 slot,\n        uint256 payment0,\n        uint256 payment1\n    ) external {\n        (bytes32 addrPack, bool flipped) = AddressPacking.pack(party0, party1);\n        TimeSlot.Slot memory timeSlot = _timeSlots[addrPack][ccy][slot];\n\n        uint256 totalPaymentBefore0 = timeSlot.totalPayment0;\n        uint256 totalPaymentBefore1 = timeSlot.totalPayment1;\n\n        TimeSlot.addPayment(\n            _timeSlots,\n            party0,\n            party1,\n            ccy,\n            slot,\n            payment0,\n            payment1\n        );\n\n        timeSlot = _timeSlots[addrPack][ccy][slot];\n\n        if (flipped) {\n            require(\n                timeSlot.totalPayment0 == totalPaymentBefore0.add(payment1),\n                \"PAYMENT1 CHANGED INCORRECTLY\"\n            );\n            require(\n                timeSlot.totalPayment1 == totalPaymentBefore1.add(payment0),\n                \"PAYMENT0 CHANGED INCORRECTLY\"\n            );\n        } else {\n            require(\n                timeSlot.totalPayment0 == totalPaymentBefore0.add(payment0),\n                \"PAYMENT0 CHANGED INCORRECTLY\"\n            );\n            require(\n                timeSlot.totalPayment1 == totalPaymentBefore1.add(payment1),\n                \"PAYMENT1 CHANGED INCORRECTLY\"\n            );\n        }\n    }\n\n    function removePayment(\n        address party0,\n        address party1,\n        bytes32 slot,\n        uint256 payment0,\n        uint256 payment1\n    ) external {\n        (bytes32 addrPack, bool flipped) = AddressPacking.pack(party0, party1);\n        TimeSlot.Slot memory timeSlot = _timeSlots[addrPack][ccy][slot];\n        require(!timeSlot.isSettled, \"TIMESLOT SETTLED ALREADY\");\n\n        uint256 totalPaymentBefore0 = timeSlot.totalPayment0;\n        uint256 totalPaymentBefore1 = timeSlot.totalPayment1;\n\n        TimeSlot.removePayment(\n            _timeSlots,\n            party0,\n            party1,\n            ccy,\n            slot,\n            payment0,\n            payment1\n        );\n\n        timeSlot = _timeSlots[addrPack][ccy][slot];\n\n        if (flipped) {\n            require(\n                timeSlot.totalPayment0 == totalPaymentBefore0.sub(payment1),\n                \"PAYMENT1 REMOVED INCORRECTLY\"\n            );\n            require(\n                timeSlot.totalPayment1 == totalPaymentBefore1.sub(payment0),\n                \"PAYMENT0 REMOVED INCORRECTLY\"\n            );\n        } else {\n            require(\n                timeSlot.totalPayment0 == totalPaymentBefore0.sub(payment0),\n                \"PAYMENT0 REMOVED INCORRECTLY\"\n            );\n            require(\n                timeSlot.totalPayment1 == totalPaymentBefore1.sub(payment1),\n                \"PAYMENT1 REMOVED INCORRECTLY\"\n            );\n        }\n    }\n\n    function verifyPayment(\n        address counterparty,\n        bytes32 slot,\n        uint256 payment,\n        bytes32 settlementId\n    ) external {\n        (bytes32 addrPack, ) = AddressPacking.pack(msg.sender, counterparty);\n        TimeSlot.Slot storage timeSlot = _timeSlots[addrPack][ccy][slot];\n        TimeSlot.verifyPayment(\n            _timeSlots,\n            msg.sender,\n            counterparty,\n            ccy,\n            slot,\n            payment,\n            settlementId\n        );\n\n        timeSlot = _timeSlots[addrPack][ccy][slot];\n\n        require(\n            timeSlot.confirmations[settlementId].verificationParty ==\n                msg.sender,\n            \"INCORRECT VERIFIER\"\n        );\n        require(\n            timeSlot.confirmations[settlementId].amount == payment,\n            \"INCORRECT PAYMENT AMOUNT\"\n        );\n    }\n\n    function clear(\n        address party0,\n        address party1,\n        bytes32 slot\n    ) public {\n        (bytes32 addrPack, ) = AddressPacking.pack(party0, party1);\n        TimeSlot.clear(_timeSlots, party0, party1, ccy, slot);\n\n        require(\n            _timeSlots[addrPack][ccy][slot].totalPayment0 == 0,\n            \"PAYMENT NOT CLEARED\"\n        );\n        require(\n            _timeSlots[addrPack][ccy][slot].totalPayment1 == 0,\n            \"PAYMENT NOT CLEARED\"\n        );\n    }\n\n    function isSettled(\n        address party0,\n        address party1,\n        bytes32 slot\n    ) external view returns (bool) {\n        return TimeSlot.isSettled(_timeSlots, party0, party1, ccy, slot);\n    }\n\n    function getGasCostOfIsSettled(\n        address party0,\n        address party1,\n        bytes32 slot\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        TimeSlot.isSettled(_timeSlots, party0, party1, ccy, slot);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/libraries/TimeSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./BokkyPooBahsDateTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./AddressPacking.sol\";\n\nlibrary TimeSlot {\n    using BokkyPooBahsDateTimeLibrary for uint256;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Slot keeps track of total payments to be settled per one day\n     * by two counterparties per currency, net payment and\n     * an indicator if parties obligations are flipped\n     */\n    struct Slot {\n        uint256 totalPayment0;\n        uint256 totalPayment1;\n        uint256 netPayment;\n        uint256 paidAmount;\n        bool flipped;\n        bool isSettled;\n        mapping(bytes32 => PaymentConfirmation) confirmations;\n    }\n\n    struct PaymentConfirmation {\n        address verificationParty;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Computes the time slot position in the mapping by preconfigured time\n     * @param year Year in which to find a timeslot\n     * @param month Month in which to find a timeslot\n     * @param day Day in which to find a timeslot\n     */\n    function position(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(year, month, day));\n    }\n\n    /**\n     * @dev Returns the time slot information from the mapping and preconfigured time\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param year Year in which to find a timeslot\n     * @param month Month in which to find a timeslot\n     * @param day Day in which to find a timeslot\n     */\n    function get(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot)))\n            storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 year,\n        uint256 month,\n        uint256 day\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        )\n    {\n        return\n            getBySlotId(\n                self,\n                party0,\n                party1,\n                ccy,\n                keccak256(abi.encodePacked(year, month, day))\n            );\n    }\n\n    /**\n     * @dev Returns timeSlot payment confirmation for a transaction with specified `txHash`\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param year Year in which to find a timeslot\n     * @param month Month in which to find a timeslot\n     * @param day Day in which to find a timeslot\n     * @param settlementId Unique settlement id to find payment confirmation for\n     */\n    function getPaymentConfirmation(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot)))\n            storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        bytes32 settlementId\n    ) internal view returns (address, uint256) {\n        return\n            getPaymentConfirmationById(\n                self,\n                party0,\n                party1,\n                ccy,\n                keccak256(abi.encodePacked(year, month, day)),\n                settlementId\n            );\n    }\n\n    /**\n     * @dev Returns timeSlot payment confirmation for a transaction with specified `txHash`\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slotId Time slot identifier\n     * @param settlementId Unique settlement id to find payment confirmation for\n     */\n    function getPaymentConfirmationById(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot)))\n            storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slotId,\n        bytes32 settlementId\n    ) internal view returns (address, uint256) {\n        (bytes32 addr, ) = AddressPacking.pack(party0, party1);\n        TimeSlot.Slot storage timeSlot = self[addr][ccy][slotId];\n\n        TimeSlot.PaymentConfirmation memory confirmation = timeSlot\n            .confirmations[settlementId];\n\n        return (confirmation.verificationParty, confirmation.amount);\n    }\n\n    /**\n     * @dev Returns the time slot information from the mapping\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slotId Time slot identifier\n     */\n    function getBySlotId(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot)))\n            storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slotId\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        )\n    {\n        (bytes32 addr, bool flipped) = AddressPacking.pack(party0, party1);\n        TimeSlot.Slot memory timeSlot = self[addr][ccy][slotId];\n        if (flipped) {\n            uint256 oldPayment0 = timeSlot.totalPayment0;\n            uint256 oldPayment1 = timeSlot.totalPayment1;\n            timeSlot.totalPayment0 = oldPayment1;\n            timeSlot.totalPayment1 = oldPayment0;\n        }\n\n        if (timeSlot.totalPayment1 > timeSlot.totalPayment0) {\n            timeSlot.netPayment = timeSlot.totalPayment1.sub(\n                timeSlot.totalPayment0\n            );\n            timeSlot.flipped = true;\n        } else {\n            timeSlot.netPayment = timeSlot.totalPayment0.sub(\n                timeSlot.totalPayment1\n            );\n            timeSlot.flipped = false;\n        }\n\n        return (\n            timeSlot.totalPayment0,\n            timeSlot.totalPayment1,\n            timeSlot.netPayment,\n            timeSlot.paidAmount,\n            timeSlot.flipped,\n            timeSlot.isSettled\n        );\n    }\n\n    /**\n     * @dev Adds payment into the time slot with provided information\n     * @param self The mapping with all time slots\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slot Time slot identifier to be updated\n     * @param payment0 Payment obligated to the first counterparty\n     * @param payment1 Payment obligated to the second counterparty\n     */\n    function addPayment(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot)))\n            storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot,\n        uint256 payment0,\n        uint256 payment1\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            party0,\n            party1\n        );\n        TimeSlot.Slot storage timeSlot = self[packedAddrs][ccy][slot];\n        require(!timeSlot.isSettled, \"TIMESLOT SETTLED ALREADY\");\n\n        timeSlot.totalPayment0 = flipped\n            ? timeSlot.totalPayment0.add(payment1)\n            : timeSlot.totalPayment0.add(payment0);\n        timeSlot.totalPayment1 = flipped\n            ? timeSlot.totalPayment1.add(payment0)\n            : timeSlot.totalPayment1.add(payment1);\n    }\n\n    /**\n     * @dev Removes payment from the time slot with provided information\n     * @param self The mapping with all time slots\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slot Time slot identifier to be updated\n     * @param payment0 Payment amount to remove for the first counterparty\n     * @param payment1 Payment amount to remove for the second counterparty\n     */\n    function removePayment(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot)))\n            storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot,\n        uint256 payment0,\n        uint256 payment1\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            party0,\n            party1\n        );\n        TimeSlot.Slot storage timeSlot = self[packedAddrs][ccy][slot];\n        if (timeSlot.isSettled) return;\n\n        timeSlot.totalPayment0 = flipped\n            ? timeSlot.totalPayment0.sub(payment1)\n            : timeSlot.totalPayment0.sub(payment0);\n        timeSlot.totalPayment1 = flipped\n            ? timeSlot.totalPayment1.sub(payment0)\n            : timeSlot.totalPayment1.sub(payment1);\n    }\n\n    /**\n     * @dev Verifies the net payment for time slot\n     * @param self The mapping with all time slots\n     * @param sender Payment sender address\n     * @param recipient Resipient's counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slot Time slot identifier to be verified\n     * @param payment Net payment amount\n     * @param settlementId Unique settlement id of the successfull payment\n     */\n    function verifyPayment(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot)))\n            storage self,\n        address sender,\n        address recipient,\n        bytes32 ccy,\n        bytes32 slot,\n        uint256 payment,\n        bytes32 settlementId\n    ) internal {\n        (bytes32 addr, bool flipped) = AddressPacking.pack(sender, recipient);\n        TimeSlot.Slot storage timeSlot = self[addr][ccy][slot];\n        require(!timeSlot.isSettled, \"TIMESLOT SETTLED ALREADY\");\n        uint256 netPayment;\n\n        if (flipped) {\n            require(\n                timeSlot.totalPayment1 > timeSlot.totalPayment0,\n                \"Incorrect verification party\"\n            );\n            netPayment = timeSlot.totalPayment1.sub(timeSlot.totalPayment0);\n        } else {\n            require(\n                timeSlot.totalPayment0 > timeSlot.totalPayment1,\n                \"Incorrect verification party\"\n            );\n            netPayment = timeSlot.totalPayment0.sub(timeSlot.totalPayment1);\n        }\n\n        timeSlot.paidAmount = timeSlot.paidAmount.add(payment);\n        require(timeSlot.paidAmount <= netPayment, \"Payment overflow\");\n\n        TimeSlot.PaymentConfirmation memory confirmation;\n        confirmation.amount = payment;\n        confirmation.verificationParty = sender;\n        timeSlot.confirmations[settlementId] = confirmation;\n\n        if (netPayment.sub(timeSlot.paidAmount) == 0) {\n            timeSlot.isSettled = true;\n        }\n    }\n\n    /**\n     * @dev Clears the time slot, triggered only when the timeslot has empty payments for both parties and 0 net payment\n     * @param self The mapping with all time slots\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slot TimeSlot identifier to be cleared\n     */\n    function clear(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot)))\n            storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot\n    ) internal {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        delete self[packedAddrs][ccy][slot];\n    }\n\n    /**\n     * @dev Verifies if TimeSlot was settled\n     * @param self The mapping with all time slots\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the time slot\n     * @param slot TimeSlot identifier to be cleared\n     * @return Boolean of settlement status\n     */\n    function isSettled(\n        mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot)))\n            storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot\n    ) internal view returns (bool) {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        return self[packedAddrs][ccy][slot].isSettled;\n    }\n}\n"
    },
    "contracts/libraries/AddressPacking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nlibrary AddressPacking {\n    /**\n     * @dev Packs two addresses into one hash to reduce the number of arguments\n     * @param addr0 First address\n     * @param addr1 Second address\n     * @return Boolean to identify if addresses were flipped\n     */\n    function pack(address addr0, address addr1)\n        internal\n        pure\n        returns (bytes32, bool)\n    {\n        require(addr0 != addr1, \"Identical addresses\");\n        (address _addr0, address _addr1) = addr0 < addr1\n            ? (addr0, addr1)\n            : (addr1, addr0);\n        require(_addr0 != address(0), \"Invalid address\");\n\n        if (_addr0 != addr0) {\n            return (keccak256(abi.encode(_addr0, _addr1)), true);\n        } else {\n            return (keccak256(abi.encode(_addr0, _addr1)), false);\n        }\n    }\n}\n"
    },
    "contracts/libraries/BokkyPooBahsDateTimeLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n// ----------------------------------------------------------------------------\n\nlibrary BokkyPooBahsDateTimeLibrary {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    uint256 constant DOW_MON = 1;\n    uint256 constant DOW_TUE = 2;\n    uint256 constant DOW_WED = 3;\n    uint256 constant DOW_THU = 4;\n    uint256 constant DOW_FRI = 5;\n    uint256 constant DOW_SAT = 6;\n    uint256 constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days = _day -\n            32075 +\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\n            4 +\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n            12 -\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n            4 -\n            OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function timestampFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n\n    function timestampFromDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 timestamp) {\n        timestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            hour *\n            SECONDS_PER_HOUR +\n            minute *\n            SECONDS_PER_MINUTE +\n            second;\n    }\n\n    function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n\n    function isValidDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint256 daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n\n    function isValidDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n\n    function isLeapYear(uint256 timestamp)\n        internal\n        pure\n        returns (bool leapYear)\n    {\n        (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n\n    function isWeekDay(uint256 timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n\n    function getDaysInMonth(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 daysInMonth)\n    {\n        (uint256 year, uint256 month, ) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n\n    function _getDaysInMonth(uint256 year, uint256 month)\n        internal\n        pure\n        returns (uint256 daysInMonth)\n    {\n        if (\n            month == 1 ||\n            month == 3 ||\n            month == 5 ||\n            month == 7 ||\n            month == 8 ||\n            month == 10 ||\n            month == 12\n        ) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 dayOfWeek)\n    {\n        uint256 _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = ((_days + 3) % 7) + 1;\n    }\n\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getHour(uint256 timestamp) internal pure returns (uint256 hour) {\n        uint256 secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n\n    function getMinute(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 minute)\n    {\n        uint256 secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n\n    function getSecond(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 second)\n    {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n\n    function addYears(uint256 timestamp, uint256 _years)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        year += _years;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMonths(uint256 timestamp, uint256 _months)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        month += _months;\n        year += (month - 1) / 12;\n        month = ((month - 1) % 12) + 1;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp >= timestamp);\n    }\n\n    function addDays(uint256 timestamp, uint256 _days)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addHours(uint256 timestamp, uint256 _hours)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addMinutes(uint256 timestamp, uint256 _minutes)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n\n    function addSeconds(uint256 timestamp, uint256 _seconds)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n\n    function subYears(uint256 timestamp, uint256 _years)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        year -= _years;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp <= timestamp);\n    }\n\n    function subMonths(uint256 timestamp, uint256 _months)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        (uint256 year, uint256 month, uint256 day) = _daysToDate(\n            timestamp / SECONDS_PER_DAY\n        );\n        uint256 yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = (yearMonth % 12) + 1;\n        uint256 daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp =\n            _daysFromDate(year, month, day) *\n            SECONDS_PER_DAY +\n            (timestamp % SECONDS_PER_DAY);\n        require(newTimestamp <= timestamp);\n    }\n\n    function subDays(uint256 timestamp, uint256 _days)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subHours(uint256 timestamp, uint256 _hours)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subMinutes(uint256 timestamp, uint256 _minutes)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n\n    function subSeconds(uint256 timestamp, uint256 _seconds)\n        internal\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _years)\n    {\n        require(fromTimestamp <= toTimestamp);\n        (uint256 fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint256 toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _months)\n    {\n        require(fromTimestamp <= toTimestamp);\n        (uint256 fromYear, uint256 fromMonth, ) = _daysToDate(\n            fromTimestamp / SECONDS_PER_DAY\n        );\n        (uint256 toYear, uint256 toMonth, ) = _daysToDate(\n            toTimestamp / SECONDS_PER_DAY\n        );\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _days)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _hours)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _minutes)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 _seconds)\n    {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}\n"
    },
    "contracts/test/CloseOutTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/AddressPacking.sol\";\nimport \"../libraries/CloseOut.sol\";\n\ncontract CloseOutTest {\n    using SafeMath for uint256;\n\n    mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) _closeOuts;\n    bytes32 ccy = \"0xSampleCCY\";\n\n    function get(address party0, address party1)\n        external\n        view\n        returns (CloseOut.Payment memory payment)\n    {\n        payment = CloseOut.get(_closeOuts, party0, party1, ccy);\n    }\n\n    function addPayments(\n        address party0,\n        address party1,\n        uint256 payment0,\n        uint256 payment1\n    ) external {\n        CloseOut.addPayments(\n            _closeOuts,\n            party0,\n            party1,\n            ccy,\n            payment0,\n            payment1\n        );\n    }\n\n    function removePayments(\n        address party0,\n        address party1,\n        uint256 payment0,\n        uint256 payment1\n    ) external {\n        CloseOut.removePayments(\n            _closeOuts,\n            party0,\n            party1,\n            ccy,\n            payment0,\n            payment1\n        );\n    }\n\n    function close(address party0, address party1) external {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        CloseOut.close(_closeOuts, party0, party1, ccy);\n        require(\n            _closeOuts[packedAddrs][ccy].closed == true,\n            \"PAYMENTS NOT SETTLED\"\n        );\n    }\n\n    function clear(address party0, address party1) external {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        CloseOut.clear(_closeOuts, party0, party1, ccy);\n        require(\n            _closeOuts[packedAddrs][ccy].netPayment == 0,\n            \"PAYMENTS NOT CLEARED\"\n        );\n    }\n}\n"
    },
    "contracts/libraries/CloseOut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./AddressPacking.sol\";\n\nlibrary CloseOut {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Payment keeps track of net payment for close out netting\n     * and an indicator if party's obligations are flipped\n     */\n    struct Payment {\n        uint256 netPayment;\n        bool flipped;\n        bool closed;\n    }\n\n    /**\n     * @dev Returns the close out payment between 2 counterparties\n     * @param self The mapping with all close out netting payments\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the close out\n     */\n    function get(\n        mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) internal view returns (CloseOut.Payment memory payment) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            party0,\n            party1\n        );\n        payment = self[packedAddrs][ccy];\n\n        flipped ? payment.flipped = !payment.flipped : payment.flipped = payment\n            .flipped;\n    }\n\n    struct CloseOutLocalVars {\n        bytes32 packedAddrs;\n        bool flipped;\n        uint256 payment0;\n        uint256 payment1;\n    }\n\n    /**\n     * @dev Adds payments into the close out with provided information\n     * @param self The mapping with all close out netting payments\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the close out\n     * @param payment0 New payment obligated to the first counterparty\n     * @param payment1 New payment obligated to the second counterparty\n     * @return Boolean wether close out net amount was flipped during the update, if close out is flipped the net payment obligated to the second party and vice versa\n     */\n    function addPayments(\n        mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) internal returns (bool) {\n        CloseOutLocalVars memory vars;\n        (vars.packedAddrs, vars.flipped) = AddressPacking.pack(party0, party1);\n\n        if (vars.flipped) {\n            vars.payment0 = payment1;\n            vars.payment1 = payment0;\n        } else {\n            vars.payment0 = payment0;\n            vars.payment1 = payment1;\n        }\n\n        CloseOut.Payment storage closeOut = self[vars.packedAddrs][ccy];\n\n        if (closeOut.flipped) {\n            if (\n                vars.payment0 > closeOut.netPayment &&\n                vars.payment1 < vars.payment0\n            ) {\n                closeOut.netPayment = vars.payment0.sub(\n                    closeOut.netPayment.add(vars.payment1)\n                );\n                closeOut.flipped = false;\n            } else {\n                closeOut.netPayment = closeOut\n                    .netPayment\n                    .add(vars.payment1)\n                    .sub(vars.payment0);\n            }\n        } else {\n            if (\n                vars.payment1 > closeOut.netPayment &&\n                vars.payment0 < vars.payment1\n            ) {\n                closeOut.netPayment = vars.payment1.sub(\n                    closeOut.netPayment.add(vars.payment0)\n                );\n                closeOut.flipped = true;\n            } else {\n                closeOut.netPayment = closeOut\n                    .netPayment\n                    .add(vars.payment0)\n                    .sub(vars.payment1);\n            }\n        }\n\n        return closeOut.flipped;\n    }\n\n    /**\n     * @dev Removes payments from the close out with provided information\n     * @param self The mapping with all close out netting payments\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the close out\n     * @param payment0 Payment to remove for the first counterparty\n     * @param payment1 Payment to remove for the second counterparty\n     * @return Boolean wether close out net amount was flipped during the update, if close out is flipped the net payment obligated to the second party and vice versa\n     */\n    function removePayments(\n        mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) internal returns (bool) {\n        CloseOutLocalVars memory vars;\n        (vars.packedAddrs, vars.flipped) = AddressPacking.pack(party0, party1);\n\n        if (vars.flipped) {\n            vars.payment0 = payment1;\n            vars.payment1 = payment0;\n        } else {\n            vars.payment0 = payment0;\n            vars.payment1 = payment1;\n        }\n\n        CloseOut.Payment storage closeOut = self[vars.packedAddrs][ccy];\n        uint256 paymentDelta = vars.payment0 > vars.payment1\n            ? vars.payment0.sub(vars.payment1)\n            : vars.payment1.sub(vars.payment0);\n        bool substraction;\n\n        if (closeOut.flipped) {\n            substraction = vars.payment0 >= vars.payment1 ? false : true;\n        } else {\n            substraction = vars.payment0 >= vars.payment1 ? true : false;\n        }\n\n        if (paymentDelta >= closeOut.netPayment && substraction) {\n            closeOut.netPayment = paymentDelta.sub(closeOut.netPayment);\n            closeOut.flipped = !closeOut.flipped;\n        } else {\n            closeOut.netPayment = substraction\n                ? closeOut.netPayment.sub(paymentDelta)\n                : closeOut.netPayment.add(paymentDelta);\n        }\n\n        return closeOut.flipped;\n    }\n\n    /**\n     * @dev Closes the close out payment if both parties don't have any trading activities anymore\n     * @param self The mapping with all close out netting payments\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the close out\n     */\n    function close(\n        mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) internal {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        CloseOut.Payment storage closeOut = self[packedAddrs][ccy];\n\n        closeOut.closed = true;\n    }\n\n    /**\n     * @dev Clears the state of close out payment\n     * @param self The mapping with all close out netting payments\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main currency for the close out\n     */\n    function clear(\n        mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) internal {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        delete self[packedAddrs][ccy];\n    }\n}\n"
    },
    "contracts/CloseOutNetting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./ProtocolTypes.sol\";\nimport \"./libraries/CloseOut.sol\";\nimport \"./libraries/AddressPacking.sol\";\nimport \"./interfaces/ICollateralAggregator.sol\";\n\n/**\n * @title Close Out Netting contract is used in close out operations\n * Close out is the process while one of the counterparties declared\n * as defaulted party and all deals should be terminated\n *\n * Contract linked to all product based contracts (ex. Loan, Swap, etc), and Collateral Aggregator contract.\n */\ncontract CloseOutNetting {\n    using SafeMath for uint256;\n    using Address for address;\n    using CloseOut for CloseOut.Payment;\n\n    event UpdatePaymentAggregator(\n        address indexed prevAddr,\n        address indexed addr\n    );\n    event UpdateCollateralAggregator(\n        address indexed prevAddr,\n        address indexed addr\n    );\n\n    event AddCloseOutPayments(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    );\n    event RemoveCloseOutPayments(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    );\n    event VerifyCloseOut(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 netPayment,\n        bytes32 txHash\n    );\n    event SettleCloseOut(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 netPayment,\n        bytes32 txHash\n    );\n\n    address public owner;\n\n    // Linked contract addresses\n    ICollateralAggregator private collateralAggregator;\n    address private paymentAggregator;\n\n    // Mapping structure for storing Close Out payments\n    mapping(bytes32 => mapping(bytes32 => CloseOut.Payment)) _closeOuts;\n\n    // Mapping structure for storing default boolean per address\n    mapping(address => bool) _isDefaulted;\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by payment aggregator contract.\n     */\n    modifier onlyPaymentAggregator() {\n        require(msg.sender == paymentAggregator);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by passing contract address checks.\n     */\n    modifier onlyContractAddr(address addr) {\n        require(addr != address(0), \"INVALID_ADDRESS\");\n        require(addr.isContract(), \"NOT_CONTRACT\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by defaulted counterparty.\n     */\n    modifier defaultedParty() {\n        require(_isDefaulted[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by non defaulted counterparty.\n     */\n    modifier nonDefaultedParty() {\n        require(!_isDefaulted[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     * @notice sets contract deployer as owner of this contract\n     * @param _paymentAggregator PaymentAggregator contract address\n     */\n    constructor(address _paymentAggregator) public {\n        owner = msg.sender;\n        paymentAggregator = _paymentAggregator;\n        // collateralAggregator = ICollateralAggregator(_collateralAggregator);\n    }\n\n    /**\n     * @dev Trigers to update Payment Aggregator contract address\n     * @param addr New PaymentAggregator contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address or non contract address\n     */\n    function updatePaymentAggregator(address addr)\n        public\n        onlyOwner\n        onlyContractAddr(addr)\n    {\n        emit UpdatePaymentAggregator(paymentAggregator, addr);\n        paymentAggregator = addr;\n    }\n\n    /**\n     * @dev Trigers to update Collateral Aggregator contract address\n     * @param addr New CollateralAggregator contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address or non contract address\n     */\n    function updateCollateralAggregator(address addr)\n        public\n        onlyOwner\n        onlyContractAddr(addr)\n    {\n        address prevAddr = address(collateralAggregator);\n\n        emit UpdateCollateralAggregator(prevAddr, addr);\n        collateralAggregator = ICollateralAggregator(addr);\n    }\n\n    /**\n     * @dev Returns the close out payment between two counterparties\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     */\n    function getCloseOutPayment(\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) public view returns (CloseOut.Payment memory payment) {\n        payment = CloseOut.get(_closeOuts, party0, party1, ccy);\n    }\n\n    /**\n     * @dev Triggers to add total payments during the registration of the deal in close out netting\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main settlement currency of the deal\n     * @param payment0 Aggregated payment for first counterparty\n     * @param payment1 Aggregated payment for second counterparty\n     *\n     * @notice Executed only be PaymentAggregator contract\n     */\n    function addPayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) external onlyPaymentAggregator {\n        CloseOut.addPayments(\n            _closeOuts,\n            party0,\n            party1,\n            ccy,\n            payment0,\n            payment1\n        );\n\n        emit AddCloseOutPayments(party0, party1, ccy, payment0, payment1);\n    }\n\n    /**\n     * @dev Triggers to remove aggregated payments during the liquidation of the deal in close out netting\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main settlement currency of the deal\n     * @param payment0 Aggregated payment for first counterparty\n     * @param payment1 Aggregated payment for second counterparty\n     *\n     * @notice Executed only be PaymentAggregator contract\n     */\n    function removePayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) external onlyPaymentAggregator {\n        CloseOut.removePayments(\n            _closeOuts,\n            party0,\n            party1,\n            ccy,\n            payment0,\n            payment1\n        );\n\n        emit RemoveCloseOutPayments(party0, party1, ccy, payment0, payment1);\n    }\n\n    /**\n     * @dev External function to check if `_party` is in default\n     */\n    function checkDefault(address _party) external view returns (bool) {\n        return _isDefaulted[_party];\n    }\n\n    /**\n     * @dev Internal function to declare default for `_defaultedParty`\n     */\n    function _handleDefault(address _defaultedParty) internal {\n        _isDefaulted[_defaultedParty] = true;\n    }\n\n    /**\n     * @dev Internal function to execute close out netting payment\n     * liquidates ETH from party's collateral with bigger net payment to their counterparty\n     * @notice Only triggers if one of the counterparties in default\n     */\n    function _handleCloseOut(address party0, address party1) internal {\n        require(\n            _isDefaulted[party0] || _isDefaulted[party1],\n            \"NON_DEFAULTED_PARTIES\"\n        );\n        bytes32[] memory currencies = collateralAggregator.getExposedCurrencies(\n            party0,\n            party1\n        );\n\n        for (uint256 i = 0; i < currencies.length; i++) {\n            bytes32 ccy = currencies[i];\n\n            CloseOut.Payment memory payment = CloseOut.get(\n                _closeOuts,\n                party0,\n                party1,\n                ccy\n            );\n\n            if (payment.flipped) {\n                collateralAggregator.liquidate(\n                    party1,\n                    party0,\n                    ccy,\n                    payment.netPayment\n                );\n            } else {\n                collateralAggregator.liquidate(\n                    party0,\n                    party1,\n                    ccy,\n                    payment.netPayment\n                );\n            }\n\n            CloseOut.close(_closeOuts, party0, party1, ccy);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/interfaces/ICollateralAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface ICollateralAggregator {\n    event Deposit(address indexed addr, uint256 amount);\n    event Liquidate(address indexed from, address indexed to, uint256 amount);\n    event PositionDeposit(\n        address indexed partyA,\n        address indexed partyB,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event PositionWithdraw(\n        address indexed partyA,\n        address indexed partyB,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event Rebalance(\n        address indexed partyA,\n        address indexed partyB,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event RebalancePositions(\n        address[] fromParties,\n        address[] toParties,\n        uint256[] fromAmounts,\n        uint256[] toAmounts\n    );\n    event Register(address indexed addr, uint256 id, uint256 amount);\n    event Release(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    );\n    event UpdatePV(\n        address indexed addr,\n        uint256 prevPV,\n        uint256 newPV,\n        uint8 ccy\n    );\n    event UpdateState(address indexed addr, uint8 prevState, uint8 currState);\n    event UseCollateral(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    );\n    event Withdraw(address indexed addr, uint256 amount);\n\n    function AUTOLQLEVEL() external view returns (uint256);\n\n    function LQLEVEL() external view returns (uint256);\n\n    function MARGINLEVEL() external view returns (uint256);\n\n    function addCollateralUser(address _user) external returns (bool);\n\n    function currencyController() external view returns (address);\n\n    function deposit() external payable;\n\n    function deposit(address _counterparty) external payable;\n\n    function getCoverage(address party0, address party1)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getExposedCurrencies(address partyA, address partyB)\n        external\n        view\n        returns (bytes32[] memory);\n\n    function isCovered(\n        address party0,\n        address party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) external view returns (bool, bool);\n\n    function liquidateUnsettled(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 amount\n    ) external;\n\n    function liquidate(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 amount\n    ) external;\n\n    function owner() external view returns (address);\n\n    function rebalanceFrom(\n        address _fromParty,\n        address _toParty,\n        uint256 _amount\n    ) external;\n\n    function rebalanceTo(\n        address _mainParty,\n        address _counterparty,\n        uint256 _amount\n    ) external;\n\n    function rebalanceTo(address _counterparty, uint256 _amount) external;\n\n    function register() external payable;\n\n    function register(uint256 id) external payable;\n\n    function releaseUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external;\n\n    function releaseCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external;\n\n    function removeCollateralUser(address _user) external returns (bool);\n\n    function updateLiquidationPrice(uint256 _price) external;\n\n    function updateLiquidationThreshold(uint256 _ratio) external;\n\n    function updateMarginCallThreshold(uint256 _ratio) external;\n\n    function updatePV(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) external;\n\n    function useUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external;\n\n    function useCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external;\n\n    function settleCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    ) external;\n\n    function withdraw(uint256 _amt) external;\n\n    function withdrawFrom(address _counterparty, uint256 _amt) external;\n\n    function checkRegisteredBook(address addr) external view returns (bool);\n\n    function getMaxCollateralWidthdraw(address _party0, address _party1)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getMaxCollateralBookWidthdraw(address _user)\n        external\n        view\n        returns (uint256);\n\n    function enterVault(address _user) external;\n\n    function enterVault(address _party0, address _party1) external;\n\n    function exitVault(address _user) external;\n\n    function exitVault(address _party0, address _party1) external;\n}\n"
    },
    "contracts/LendingMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./interfaces/ICollateralAggregator.sol\";\nimport \"./interfaces/ILoanV2.sol\";\nimport \"./interfaces/ILendingMarketController.sol\";\nimport \"./libraries/HitchensOrderStatisticsTreeLib.sol\";\nimport \"./ProtocolTypes.sol\";\n\n/**\n * @dev Lending Market contract module which allows lending market participants\n * to create/take/cancel market orders.\n *\n * It will store market orders in structured red-black tree and doubly linked list in each node.\n */\ncontract LendingMarket is ProtocolTypes, ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n    using HitchensOrderStatisticsTreeLib for HitchensOrderStatisticsTreeLib.Tree;\n\n    // Contracts interfaces\n    ICollateralAggregator collateralAggregator;\n    ILoanV2 loan;\n\n    /**\n     * @dev Emitted when market order created by market maker.\n     */\n    event MakeOrder(\n        uint256 orderId,\n        address indexed maker,\n        Side side,\n        bytes32 ccy,\n        uint256 term,\n        uint256 amount,\n        uint256 rate\n    );\n\n    /**\n     * @dev Emitted when market order canceled by market maker.\n     *\n     * Requirements:\n     *\n     * - Market order must be active and cancelable.\n     */\n    event CancelOrder(\n        uint256 orderId,\n        address indexed maker,\n        Side side,\n        uint256 amount,\n        uint256 rate\n    );\n\n    /**\n     * @dev Emitted when market order taken by market taker.\n     *\n     * Requirements:\n     *\n     * - Market order must be active.\n     */\n    event TakeOrder(\n        uint256 orderId,\n        address indexed taker,\n        Side side,\n        uint256 amount,\n        uint256 rate\n    );\n\n    uint256 public last_order_id;\n    bytes32 public MarketCcy;\n    uint256 public MarketTerm;\n    address public lendingController;\n\n    struct MarketOrder {\n        Side side;\n        uint256 amount;\n        uint256 rate; // in basis points\n        address maker;\n    }\n\n    /**\n     * @dev Order Book mapping for all Market Orders.\n     */\n    mapping(uint256 => MarketOrder) public orders;\n    HitchensOrderStatisticsTreeLib.Tree lendOrders;\n    HitchensOrderStatisticsTreeLib.Tree borrowOrders;\n\n    /**\n     * @dev Constructor.\n     * @param _ccy The main currency for order book lending deals\n     * @param _term The main term for order book lending deals\n     */\n    constructor(\n        bytes32 _ccy,\n        uint256 _term,\n        address _lendingController\n    ) public {\n        MarketCcy = _ccy;\n        MarketTerm = _term;\n        lendingController = _lendingController;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by lending market controller owner.\n     */\n    modifier onlyLendingControllerAdmin() {\n        require(\n            msg.sender == ILendingMarketController(lendingController).owner() ||\n                msg.sender == lendingController,\n            \"Incorrect access\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by order maker.\n     * @param orderId Market order id\n     */\n    modifier onlyMaker(uint256 orderId) {\n        require(msg.sender == getMaker(orderId), \"No access to cancel order\");\n        _;\n    }\n\n    /**\n     * @dev Triggers to make a set collateral contract address.\n     * @param colAddr Collateral contract addreess\n     *\n     * Requirements:\n     *\n     * - Can be executed only by lending market controller owner.\n     */\n    function setCollateral(address colAddr) public onlyLendingControllerAdmin {\n        collateralAggregator = ICollateralAggregator(colAddr);\n    }\n\n    /**\n     * @dev Triggers to make a set loan contract address.\n     * @param addr Loan smart contract addreess\n     *\n     * Requirements:\n     *\n     * - Can be executed only by lending market controller owner.\n     */\n    function setLoan(address addr) public onlyLendingControllerAdmin {\n        loan = ILoanV2(addr);\n    }\n\n    /**\n     * @dev Triggers to get order maker address.\n     * @param orderId Market order id\n     */\n    function getMaker(uint256 orderId) public view returns (address maker) {\n        return orders[orderId].maker;\n    }\n\n    /**\n     * @dev Triggers to get highest borrow rate.\n     */\n    function getBorrowRate() public view returns (uint256 rate) {\n        return borrowOrders.last();\n    }\n\n    /**\n     * @dev Triggers to get highest lend rate.\n     */\n    function getLendRate() public view returns (uint256 rate) {\n        return lendOrders.last();\n    }\n\n    /**\n     * @dev Triggers to get mid rate.\n     */\n    function getMidRate() public view returns (uint256 rate) {\n        uint256 borrowRate = getBorrowRate();\n        uint256 lendRate = getLendRate();\n        uint256 combinedRate = borrowRate.add(lendRate);\n\n        return combinedRate.div(2);\n    }\n\n    /**\n     * @dev Triggers to get market order information.\n     * @param orderId Market order id\n     */\n    function getOrder(uint256 orderId)\n        public\n        view\n        returns (MarketOrder memory)\n    {\n        return orders[orderId];\n    }\n\n    function getOrderFromTree(uint256 orderId)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        MarketOrder memory order = orders[orderId];\n\n        if (order.side == Side.LEND) {\n            return lendOrders.getOrderById(order.rate, orderId);\n        } else {\n            return borrowOrders.getOrderById(order.rate, orderId);\n        }\n    }\n\n    /**\n     * @dev Internally triggered to increase and return id of last order in order book.\n     */\n    function _next_id() internal returns (uint256) {\n        last_order_id++;\n        return last_order_id;\n    }\n\n    /**\n     * @dev Triggered to cancel market order.\n     * @param orderId Market order id\n     *\n     * Requirements:\n     * - Order has to be cancelable by market maker\n     */\n    function cancelOrder(uint256 orderId)\n        public\n        onlyMaker(orderId)\n        returns (bool success)\n    {\n        _beforeMarketOrder();\n\n        MarketOrder memory order = orders[orderId];\n        if (order.side == Side.LEND) {\n            lendOrders.remove(order.amount, order.rate, orderId);\n        } else if (order.side == Side.BORROW) {\n            borrowOrders.remove(order.amount, order.rate, orderId);\n        }\n        delete orders[orderId];\n\n        collateralAggregator.releaseUnsettledCollateral(\n            order.maker,\n            MarketCcy,\n            order.amount.mul(MKTMAKELEVEL).div(PCT)\n        );\n        emit CancelOrder(\n            orderId,\n            order.maker,\n            order.side,\n            order.amount,\n            order.rate\n        );\n\n        success = true;\n    }\n\n    /**\n     * @dev Triggered to make new market order.\n     * @param _side Borrow or Lend order position\n     * @param _amount Amount of funds maker wish to borrow/lend\n     * @param _rate Preferable interest rate\n     */\n    function makeOrder(\n        Side _side,\n        uint256 _amount,\n        uint256 _rate\n    ) internal returns (uint256 orderId) {\n        MarketOrder memory order;\n\n        require(_amount > 0, \"Can't place empty amount\");\n        require(_rate > 0, \"Can't place empty rate\");\n        _beforeMarketOrder();\n\n        order.side = _side;\n        order.amount = _amount;\n        order.rate = _rate;\n        order.maker = msg.sender;\n        orderId = _next_id();\n\n        orders[orderId] = order;\n        collateralAggregator.useUnsettledCollateral(\n            msg.sender,\n            MarketCcy,\n            _amount.mul(MKTMAKELEVEL).div(PCT)\n        );\n        if (order.side == Side.LEND) {\n            lendOrders.insert(order.amount, order.rate, orderId);\n        } else if (order.side == Side.BORROW) {\n            borrowOrders.insert(order.amount, order.rate, orderId);\n        }\n\n        emit MakeOrder(\n            orderId,\n            order.maker,\n            order.side,\n            MarketCcy,\n            MarketTerm,\n            order.amount,\n            order.rate\n        );\n    }\n\n    /**\n     * @dev Triggered to take market order.\n     * @param orderId Market Order id in Order Book\n     * @param _amount Amount of funds taker wish to borrow/lend\n     *\n     * Requirements:\n     * - Market order has to be active\n     */\n    function takeOrder(\n        Side side,\n        uint256 orderId,\n        uint256 _amount\n    ) internal returns (bool) {\n        MarketOrder memory order = orders[orderId];\n        require(_amount <= order.amount, \"Insuficient amount\");\n        require(order.maker != msg.sender, \"Maker couldn't take its order\");\n        _beforeMarketOrder();\n\n        orders[orderId].amount = order.amount.sub(_amount);\n        if (order.side == Side.LEND) {\n            require(\n                lendOrders.fillOrder(order.rate, orderId, _amount),\n                \"Couldn't fill order\"\n            );\n        } else if (order.side == Side.BORROW) {\n            require(\n                borrowOrders.fillOrder(order.rate, orderId, _amount),\n                \"Couldn't fill order\"\n            );\n        }\n\n        loan.register(\n            order.maker,\n            msg.sender,\n            uint8(order.side),\n            MarketCcy,\n            MarketTerm,\n            _amount,\n            order.rate\n        );\n\n        emit TakeOrder(orderId, msg.sender, side, _amount, order.rate);\n\n        if (order.amount == 0) {\n            delete orders[orderId];\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Triggered to get matching market order.\n     * @param side Market order side it can be borrow or lend\n     * @param amount Amount of funds taker wish to borrow/lend\n     * @param rate Amount of interest rate taker wish to borrow/lend\n     *\n     * Returns zero if didn't find a matched order, reverts if no orders for specified interest rate\n     */\n    function matchOrders(\n        Side side,\n        uint256 amount,\n        uint256 rate\n    ) public view returns (uint256) {\n        if (side == Side.LEND) {\n            require(\n                borrowOrders.exists(rate),\n                \"No orders exists for selected interest rate\"\n            );\n            return borrowOrders.findOrderIdForAmount(rate, amount);\n        } else {\n            require(\n                lendOrders.exists(rate),\n                \"No orders exists for selected interest rate\"\n            );\n            return lendOrders.findOrderIdForAmount(rate, amount);\n        }\n    }\n\n    /**\n     * @dev Triggered to execute market order, if order matched it takes order, if not matched places new order.\n     * @param side Market order side it can be borrow or lend\n     * @param amount Amount of funds maker/taker wish to borrow/lend\n     * @param rate Amount of interest rate maker/taker wish to borrow/lend\n     *\n     * Returns true after successful execution\n     */\n    function order(\n        Side side,\n        uint256 amount,\n        uint256 rate\n    ) public nonReentrant returns (bool) {\n        uint256 orderId;\n\n        if (side == Side.LEND) {\n            orderId = borrowOrders.findOrderIdForAmount(rate, amount);\n            if (orderId != 0) return takeOrder(Side.BORROW, orderId, amount);\n        } else {\n            orderId = lendOrders.findOrderIdForAmount(rate, amount);\n            if (orderId != 0) return takeOrder(Side.LEND, orderId, amount);\n        }\n\n        makeOrder(side, amount, rate);\n        return true;\n    }\n\n    /**\n     * @dev Triggered to pause lending market.\n     */\n    function pauseMarket() public virtual onlyLendingControllerAdmin {\n        _pause();\n    }\n\n    /**\n     * @dev Triggered to pause lending market.\n     */\n    function unpauseMarket() public virtual onlyLendingControllerAdmin {\n        _unpause();\n    }\n\n    /**\n     * @dev Additional checks before making/taking orders.\n     */\n    function _beforeMarketOrder() internal view {\n        require(!paused(), \"Market paused\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () internal {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/ILoanV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nstruct LoanDeal {\n    address lender;\n    address borrower;\n    bytes32 ccy;\n    uint256 term;\n    uint256 notional;\n    uint256 rate;\n    uint256 start;\n    uint256 end;\n    uint256 pv;\n    bytes32 startTxHash;\n    uint8 state;\n}\n\ninterface ILoanV2 {\n    event EarlyTermination(\n        bytes32 dealId,\n        address indexed acceptedBy,\n        uint256 payment\n    );\n    event Liquidate(bytes32 dealId);\n    event MarkToMarket(bytes32 dealId, uint256 prevPV, uint256 currPV);\n    event Novation(bytes32 indexed dealId, address currLender);\n    event Register(\n        address indexed lender,\n        address indexed borrower,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate,\n        bytes32 indexed dealId\n    );\n    event RejectTermination(bytes32 dealId, address indexed rejectedBy);\n    event RequestTermination(bytes32 dealId, address indexed requestedBy);\n\n    function acceptTermination(bytes32 loanId) external;\n\n    function addLendingMarket(\n        bytes32 _ccy,\n        uint256 _term,\n        address addr\n    ) external;\n\n    function getDF(bytes32 loanId, uint256 date)\n        external\n        view\n        returns (uint256);\n\n    function getDealPV(bytes32 loanId) external view returns (uint256 pv);\n\n    function getDealLastPV(\n        address party0,\n        address party1,\n        bytes32 loanId\n    ) external view returns (uint256, uint256);\n\n    function getDealSettlementStatus(bytes32 loanId)\n        external\n        view\n        returns (bool);\n\n    function getLastSettledPayment(bytes32 loanId)\n        external\n        view\n        returns (uint256);\n\n    function getLoanDeal(bytes32 loanId)\n        external\n        view\n        returns (LoanDeal memory);\n\n    function getPaymentSchedule(bytes32 loanId)\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            bool[] memory\n        );\n\n    function getVersion() external view returns (uint16);\n\n    function isTransferable() external view returns (bool);\n\n    function last_loan_id() external view returns (uint256);\n\n    function lendingMarkets(bytes32, uint256) external view returns (address);\n\n    function liquidate(bytes32 loanId) external;\n\n    function markToMarket(bytes32 loanId) external returns (bool);\n\n    function novation(bytes32 loanId, address newOwner) external;\n\n    function owner() external view returns (address);\n\n    function register(\n        address maker,\n        address taker,\n        uint8 side,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate\n    ) external returns (bytes32 loanId);\n\n    function rejectTermination(bytes32 loanId) external;\n\n    function requestTermination(bytes32 loanId) external;\n\n    function setCollateralAddr(address addr) external;\n\n    function setIsTransferable(bool isAccepted) external;\n\n    function setLendingControllerAddr(address addr) external;\n\n    function setPaymentAggregator(address addr) external;\n}\n"
    },
    "contracts/interfaces/ILendingMarketController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nstruct Order {\n    bytes32 ccy;\n    uint256 term;\n    uint8 side;\n    uint256 amount;\n    uint256 rate;\n}\n\ninterface ILendingMarketController {\n    event LendingMarketCreated(\n        bytes32 ccy,\n        uint256 term,\n        address indexed marketAddr\n    );\n    event LendingMarketsPaused(bytes32 ccy);\n    event LendingMarketsUnpaused(bytes32 ccy);\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    function deployLendingMarket(bytes32 _ccy, uint256 _term)\n        external\n        returns (address market);\n\n    function getBorrowRatesForCcy(bytes32 _ccy)\n        external\n        view\n        returns (uint256[] memory rates);\n\n    function getDiscountFactorsForCcy(bytes32 _ccy)\n        external\n        view\n        returns (uint256[] memory, uint256[] memory);\n\n    function getLendRatesForCcy(bytes32 _ccy)\n        external\n        view\n        returns (uint256[] memory rates);\n\n    function getMidRatesForCcy(bytes32 _ccy)\n        external\n        view\n        returns (uint256[] memory rates);\n\n    function lendingMarkets(bytes32, uint256) external view returns (address);\n\n    function owner() external view returns (address);\n\n    function pauseLendingMarkets(bytes32 _ccy) external returns (bool);\n\n    function placeBulkOrders(Order[] memory orders) external returns (bool);\n\n    function unpauseLendingMarkets(bytes32 _ccy) external returns (bool);\n\n    function numberOfMarkets() external view returns (uint256);\n\n    function getSupportedTerms(bytes32 _ccy)\n        external\n        view\n        returns (uint256[] memory);\n}\n"
    },
    "contracts/libraries/HitchensOrderStatisticsTreeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary HitchensOrderStatisticsTreeLib {\n    using SafeMath for uint256;\n    uint256 private constant EMPTY = 0;\n\n    struct Node {\n        uint256 parent;\n        uint256 left;\n        uint256 right;\n        bool red;\n        uint256 head;\n        uint256 tail;\n        uint256 orderCounter;\n        mapping(uint256 => OrderItem) orders;\n    }\n\n    struct OrderItem {\n        uint256 orderId;\n        uint256 next;\n        uint256 prev;\n        uint256 timestamp;\n        uint256 amount;\n    }\n\n    struct Tree {\n        uint256 root;\n        mapping(uint256 => Node) nodes;\n    }\n\n    function first(Tree storage self) internal view returns (uint256 _value) {\n        _value = self.root;\n        if (_value == EMPTY) return 0;\n        while (self.nodes[_value].left != EMPTY) {\n            _value = self.nodes[_value].left;\n        }\n    }\n\n    function last(Tree storage self) internal view returns (uint256 _value) {\n        _value = self.root;\n        if (_value == EMPTY) return 0;\n        while (self.nodes[_value].right != EMPTY) {\n            _value = self.nodes[_value].right;\n        }\n    }\n\n    function next(Tree storage self, uint256 value)\n        internal\n        view\n        returns (uint256 _cursor)\n    {\n        require(\n            value != EMPTY,\n            \"OrderStatisticsTree(401) - Starting value cannot be zero\"\n        );\n        if (self.nodes[value].right != EMPTY) {\n            _cursor = treeMinimum(self, self.nodes[value].right);\n        } else {\n            _cursor = self.nodes[value].parent;\n            while (_cursor != EMPTY && value == self.nodes[_cursor].right) {\n                value = _cursor;\n                _cursor = self.nodes[_cursor].parent;\n            }\n        }\n    }\n\n    function prev(Tree storage self, uint256 value)\n        internal\n        view\n        returns (uint256 _cursor)\n    {\n        require(\n            value != EMPTY,\n            \"OrderStatisticsTree(402) - Starting value cannot be zero\"\n        );\n        if (self.nodes[value].left != EMPTY) {\n            _cursor = treeMaximum(self, self.nodes[value].left);\n        } else {\n            _cursor = self.nodes[value].parent;\n            while (_cursor != EMPTY && value == self.nodes[_cursor].left) {\n                value = _cursor;\n                _cursor = self.nodes[_cursor].parent;\n            }\n        }\n    }\n\n    function exists(Tree storage self, uint256 value)\n        internal\n        view\n        returns (bool _exists)\n    {\n        if (value == EMPTY) return false;\n        if (value == self.root) return true;\n        if (self.nodes[value].parent != EMPTY) return true;\n        return false;\n    }\n\n    function amountExistsInNode(\n        Tree storage self,\n        uint256 amount,\n        uint256 value\n    ) internal view returns (bool) {\n        if (!exists(self, value)) return false;\n        return isAmountExistsInList(self, value, amount);\n    }\n\n    function orderExistsInNode(\n        Tree storage self,\n        uint256 amount,\n        uint256 value,\n        uint256 orderId\n    ) internal view returns (bool) {\n        if (!exists(self, value)) return false;\n        return isOrderIdExists(self, value, amount, orderId);\n    }\n\n    function getNode(Tree storage self, uint256 value)\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        require(\n            exists(self, value),\n            \"OrderStatisticsTree(403) - Value does not exist.\"\n        );\n        Node storage gn = self.nodes[value];\n        return (\n            gn.parent,\n            gn.left,\n            gn.right,\n            gn.red,\n            gn.head,\n            gn.tail,\n            gn.orderCounter\n        );\n    }\n\n    function getNodeCount(Tree storage self, uint256 value)\n        internal\n        view\n        returns (uint256)\n    {\n        Node storage gn = self.nodes[value];\n        return gn.orderCounter;\n    }\n\n    function count(Tree storage self) internal view returns (uint256 _count) {\n        return getNodeCount(self, self.root);\n    }\n\n    function insert(\n        Tree storage self,\n        uint256 amount,\n        uint256 value,\n        uint256 orderId\n    ) internal {\n        require(\n            value != EMPTY,\n            \"OrderStatisticsTree(405) - Value to insert cannot be zero\"\n        );\n        uint256 cursor;\n        uint256 probe = self.root;\n        while (probe != EMPTY) {\n            cursor = probe;\n            if (value < probe) {\n                probe = self.nodes[probe].left;\n            } else if (value > probe) {\n                probe = self.nodes[probe].right;\n            } else if (value == probe) {\n                insertOrder(self, probe, amount, orderId);\n                return;\n            }\n        }\n        Node storage nValue = self.nodes[value];\n        nValue.parent = cursor;\n        nValue.left = EMPTY;\n        nValue.right = EMPTY;\n        nValue.red = true;\n        insertOrder(self, value, amount, orderId);\n        if (cursor == EMPTY) {\n            self.root = value;\n        } else if (value < cursor) {\n            self.nodes[cursor].left = value;\n        } else {\n            self.nodes[cursor].right = value;\n        }\n        insertFixup(self, value);\n    }\n\n    function remove(\n        Tree storage self,\n        uint256 amount,\n        uint256 value,\n        uint256 orderId\n    ) internal {\n        require(\n            value != EMPTY,\n            \"OrderStatisticsTree(407) - Value to delete cannot be zero\"\n        );\n        require(\n            orderExistsInNode(self, amount, value, orderId),\n            \"OrderStatisticsTree(408) - Value to delete does not exist.\"\n        );\n        Node storage nValue = self.nodes[value];\n        removeOrder(self, value, orderId);\n        uint256 probe;\n        uint256 cursor;\n        if (nValue.orderCounter == 0) {\n            if (\n                self.nodes[value].left == EMPTY ||\n                self.nodes[value].right == EMPTY\n            ) {\n                cursor = value;\n            } else {\n                cursor = self.nodes[value].right;\n                while (self.nodes[cursor].left != EMPTY) {\n                    cursor = self.nodes[cursor].left;\n                }\n            }\n            if (self.nodes[cursor].left != EMPTY) {\n                probe = self.nodes[cursor].left;\n            } else {\n                probe = self.nodes[cursor].right;\n            }\n            uint256 cursorParent = self.nodes[cursor].parent;\n            self.nodes[probe].parent = cursorParent;\n            if (cursorParent != EMPTY) {\n                if (cursor == self.nodes[cursorParent].left) {\n                    self.nodes[cursorParent].left = probe;\n                } else {\n                    self.nodes[cursorParent].right = probe;\n                }\n            } else {\n                self.root = probe;\n            }\n            bool doFixup = !self.nodes[cursor].red;\n            if (cursor != value) {\n                replaceParent(self, cursor, value);\n                self.nodes[cursor].left = self.nodes[value].left;\n                self.nodes[self.nodes[cursor].left].parent = cursor;\n                self.nodes[cursor].right = self.nodes[value].right;\n                self.nodes[self.nodes[cursor].right].parent = cursor;\n                self.nodes[cursor].red = self.nodes[value].red;\n                (cursor, value) = (value, cursor);\n            }\n            if (doFixup) {\n                removeFixup(self, probe);\n            }\n            delete self.nodes[cursor];\n        }\n    }\n\n    function treeMinimum(Tree storage self, uint256 value)\n        private\n        view\n        returns (uint256)\n    {\n        while (self.nodes[value].left != EMPTY) {\n            value = self.nodes[value].left;\n        }\n        return value;\n    }\n\n    function treeMaximum(Tree storage self, uint256 value)\n        private\n        view\n        returns (uint256)\n    {\n        while (self.nodes[value].right != EMPTY) {\n            value = self.nodes[value].right;\n        }\n        return value;\n    }\n\n    function rotateLeft(Tree storage self, uint256 value) private {\n        uint256 cursor = self.nodes[value].right;\n        uint256 parent = self.nodes[value].parent;\n        uint256 cursorLeft = self.nodes[cursor].left;\n        self.nodes[value].right = cursorLeft;\n        if (cursorLeft != EMPTY) {\n            self.nodes[cursorLeft].parent = value;\n        }\n        self.nodes[cursor].parent = parent;\n        if (parent == EMPTY) {\n            self.root = cursor;\n        } else if (value == self.nodes[parent].left) {\n            self.nodes[parent].left = cursor;\n        } else {\n            self.nodes[parent].right = cursor;\n        }\n        self.nodes[cursor].left = value;\n        self.nodes[value].parent = cursor;\n    }\n\n    function rotateRight(Tree storage self, uint256 value) private {\n        uint256 cursor = self.nodes[value].left;\n        uint256 parent = self.nodes[value].parent;\n        uint256 cursorRight = self.nodes[cursor].right;\n        self.nodes[value].left = cursorRight;\n        if (cursorRight != EMPTY) {\n            self.nodes[cursorRight].parent = value;\n        }\n        self.nodes[cursor].parent = parent;\n        if (parent == EMPTY) {\n            self.root = cursor;\n        } else if (value == self.nodes[parent].right) {\n            self.nodes[parent].right = cursor;\n        } else {\n            self.nodes[parent].left = cursor;\n        }\n        self.nodes[cursor].right = value;\n        self.nodes[value].parent = cursor;\n    }\n\n    function insertFixup(Tree storage self, uint256 value) private {\n        uint256 cursor;\n        while (value != self.root && self.nodes[self.nodes[value].parent].red) {\n            uint256 valueParent = self.nodes[value].parent;\n            if (\n                valueParent == self.nodes[self.nodes[valueParent].parent].left\n            ) {\n                cursor = self.nodes[self.nodes[valueParent].parent].right;\n                if (self.nodes[cursor].red) {\n                    self.nodes[valueParent].red = false;\n                    self.nodes[cursor].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    value = self.nodes[valueParent].parent;\n                } else {\n                    if (value == self.nodes[valueParent].right) {\n                        value = valueParent;\n                        rotateLeft(self, value);\n                    }\n                    valueParent = self.nodes[value].parent;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    rotateRight(self, self.nodes[valueParent].parent);\n                }\n            } else {\n                cursor = self.nodes[self.nodes[valueParent].parent].left;\n                if (self.nodes[cursor].red) {\n                    self.nodes[valueParent].red = false;\n                    self.nodes[cursor].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    value = self.nodes[valueParent].parent;\n                } else {\n                    if (value == self.nodes[valueParent].left) {\n                        value = valueParent;\n                        rotateRight(self, value);\n                    }\n                    valueParent = self.nodes[value].parent;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    rotateLeft(self, self.nodes[valueParent].parent);\n                }\n            }\n        }\n        self.nodes[self.root].red = false;\n    }\n\n    function replaceParent(\n        Tree storage self,\n        uint256 a,\n        uint256 b\n    ) private {\n        uint256 bParent = self.nodes[b].parent;\n        self.nodes[a].parent = bParent;\n        if (bParent == EMPTY) {\n            self.root = a;\n        } else {\n            if (b == self.nodes[bParent].left) {\n                self.nodes[bParent].left = a;\n            } else {\n                self.nodes[bParent].right = a;\n            }\n        }\n    }\n\n    function removeFixup(Tree storage self, uint256 value) private {\n        uint256 cursor;\n        while (value != self.root && !self.nodes[value].red) {\n            uint256 valueParent = self.nodes[value].parent;\n            if (value == self.nodes[valueParent].left) {\n                cursor = self.nodes[valueParent].right;\n                if (self.nodes[cursor].red) {\n                    self.nodes[cursor].red = false;\n                    self.nodes[valueParent].red = true;\n                    rotateLeft(self, valueParent);\n                    cursor = self.nodes[valueParent].right;\n                }\n                if (\n                    !self.nodes[self.nodes[cursor].left].red &&\n                    !self.nodes[self.nodes[cursor].right].red\n                ) {\n                    self.nodes[cursor].red = true;\n                    value = valueParent;\n                } else {\n                    if (!self.nodes[self.nodes[cursor].right].red) {\n                        self.nodes[self.nodes[cursor].left].red = false;\n                        self.nodes[cursor].red = true;\n                        rotateRight(self, cursor);\n                        cursor = self.nodes[valueParent].right;\n                    }\n                    self.nodes[cursor].red = self.nodes[valueParent].red;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[cursor].right].red = false;\n                    rotateLeft(self, valueParent);\n                    value = self.root;\n                }\n            } else {\n                cursor = self.nodes[valueParent].left;\n                if (self.nodes[cursor].red) {\n                    self.nodes[cursor].red = false;\n                    self.nodes[valueParent].red = true;\n                    rotateRight(self, valueParent);\n                    cursor = self.nodes[valueParent].left;\n                }\n                if (\n                    !self.nodes[self.nodes[cursor].right].red &&\n                    !self.nodes[self.nodes[cursor].left].red\n                ) {\n                    self.nodes[cursor].red = true;\n                    value = valueParent;\n                } else {\n                    if (!self.nodes[self.nodes[cursor].left].red) {\n                        self.nodes[self.nodes[cursor].right].red = false;\n                        self.nodes[cursor].red = true;\n                        rotateLeft(self, cursor);\n                        cursor = self.nodes[valueParent].left;\n                    }\n                    self.nodes[cursor].red = self.nodes[valueParent].red;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[cursor].left].red = false;\n                    rotateRight(self, valueParent);\n                    value = self.root;\n                }\n            }\n        }\n        self.nodes[value].red = false;\n    }\n\n    // Double linked list functions\n    /**\n     * @dev Retrieves the Object denoted by `_id`.\n     */\n    function getOrderById(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        require(\n            exists(self, value),\n            \"OrderStatisticsTree(403) - Value does not exist.\"\n        );\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[orderId];\n        return (\n            order.orderId,\n            order.next,\n            order.prev,\n            order.timestamp,\n            order.amount\n        );\n    }\n\n    /**\n     * @dev Return boolean if value, amount and orderId exist in doubly linked list\n     */\n    function isOrderIdExists(\n        Tree storage self,\n        uint256 value,\n        uint256 amount,\n        uint256 orderId\n    ) internal view returns (bool) {\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[orderId];\n        if (order.amount != amount) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Return boolean if value and amount exist in doubly linked list.\n     */\n    function isAmountExistsInList(\n        Tree storage self,\n        uint256 value,\n        uint256 amount\n    ) internal view returns (bool) {\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[gn.head];\n        while (order.next != 0 && order.amount < amount) {\n            order = gn.orders[order.next];\n        }\n        if (order.amount == 0) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Return the id of the first OrderItem matching `_amount` in the amount field.\n     */\n    function findOrderIdForAmount(\n        Tree storage self,\n        uint256 value,\n        uint256 amount\n    ) internal view returns (uint256) {\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[gn.head];\n        while (order.orderId != gn.tail && order.amount < amount) {\n            order = gn.orders[order.next];\n        }\n        if (order.amount >= amount) {\n            return order.orderId;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @dev Reduces order amount once market order taken.\n     */\n    function fillOrder(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId,\n        uint256 _amount\n    ) internal returns (bool) {\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[orderId];\n        uint256 newAmount = order.amount.sub(_amount);\n        gn.orders[orderId].amount = newAmount;\n\n        if (gn.orders[orderId].amount == 0) {\n            remove(self, newAmount, value, orderId);\n        } else {\n            if (gn.orders[gn.head].amount < newAmount) {\n                OrderItem memory rootOrder = gn.orders[gn.head];\n                while (\n                    rootOrder.orderId != gn.tail && rootOrder.amount < newAmount\n                ) {\n                    rootOrder = gn.orders[rootOrder.next];\n                }\n                if (order.amount > _amount) {\n                    OrderItem memory prevOrder = gn.orders[rootOrder.prev];\n                    _link(self, value, order.orderId, rootOrder.orderId);\n                    _link(self, value, prevOrder.orderId, order.orderId);\n                } else {\n                    OrderItem memory nextOrder = gn.orders[rootOrder.next];\n                    _link(self, value, order.orderId, nextOrder.orderId);\n                    _link(self, value, rootOrder.orderId, order.orderId);\n                }\n            } else {\n                _link(self, value, order.orderId, gn.head);\n                _setHead(self, value, order.orderId);\n                if (gn.tail == 0) _setTail(self, value, order.orderId);\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Up size order by market maker.\n     */\n    function upSizeOrder(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId,\n        uint256 _amount\n    ) internal returns (bool) {\n        require(_amount > 0, \"Couldn't up size order with 0\");\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[orderId];\n        uint256 newAmount = order.amount.add(_amount);\n        gn.orders[orderId].amount = newAmount;\n\n        if (gn.orders[gn.head].amount < newAmount) {\n            OrderItem memory rootOrder = gn.orders[gn.head];\n            while (\n                rootOrder.orderId != gn.tail && rootOrder.amount < newAmount\n            ) {\n                rootOrder = gn.orders[rootOrder.next];\n            }\n            if (order.amount > _amount) {\n                OrderItem memory prevOrder = gn.orders[rootOrder.prev];\n                _link(self, value, order.orderId, rootOrder.orderId);\n                _link(self, value, prevOrder.orderId, order.orderId);\n            } else {\n                OrderItem memory nextOrder = gn.orders[rootOrder.next];\n                _link(self, value, order.orderId, nextOrder.orderId);\n                _link(self, value, rootOrder.orderId, order.orderId);\n            }\n        } else {\n            _link(self, value, order.orderId, gn.head);\n            _setHead(self, value, order.orderId);\n            if (gn.tail == 0) _setTail(self, value, order.orderId);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Insert a new OrderItem as the new Head with `_amount` in the amount field, and orderId.\n     */\n    function addHead(\n        Tree storage self,\n        uint256 value,\n        uint256 _amount,\n        uint256 _orderId\n    ) internal {\n        Node storage gn = self.nodes[value];\n        uint256 orderId = _createOrder(self, value, _amount, _orderId);\n        _link(self, value, orderId, gn.head);\n        _setHead(self, value, orderId);\n        if (gn.tail == 0) _setTail(self, value, orderId);\n    }\n\n    /**\n     * @dev Insert a new OrderItem as the new Tail with `_amount` in the amount field, and orderId.\n     */\n    function addTail(\n        Tree storage self,\n        uint256 value,\n        uint256 _amount,\n        uint256 _orderId\n    ) internal {\n        Node storage gn = self.nodes[value];\n\n        if (gn.head == 0) {\n            addHead(self, value, _amount, _orderId);\n        } else {\n            uint256 orderId = _createOrder(self, value, _amount, _orderId);\n            _link(self, value, gn.tail, orderId);\n            _setTail(self, value, orderId);\n        }\n    }\n\n    /**\n     * @dev Remove the OrderItem denoted by `_id` from the List.\n     */\n    function removeOrder(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId\n    ) internal {\n        require(\n            exists(self, value),\n            \"OrderStatisticsTree(403) - Value does not exist.\"\n        );\n        Node storage gn = self.nodes[value];\n\n        OrderItem memory order = gn.orders[orderId];\n        if (gn.head == orderId && gn.tail == orderId) {\n            _setHead(self, value, 0);\n            _setTail(self, value, 0);\n        } else if (gn.head == orderId) {\n            _setHead(self, value, order.next);\n            gn.orders[order.next].prev = 0;\n        } else if (gn.tail == orderId) {\n            _setTail(self, value, order.prev);\n            gn.orders[order.prev].next = 0;\n        } else {\n            _link(self, value, order.prev, order.next);\n        }\n        delete gn.orders[order.orderId];\n        gn.orderCounter -= 1;\n    }\n\n    /**\n     * @dev Insert a new OrderItem after the last OrderItem with the same `_amount`.\n     */\n    function insertOrder(\n        Tree storage self,\n        uint256 value,\n        uint256 _amount,\n        uint256 _orderId\n    ) internal {\n        require(_amount > 0, \"Insuficient amount\");\n\n        Node storage gn = self.nodes[value];\n        if (gn.head == 0) {\n            addHead(self, value, _amount, _orderId);\n        } else {\n            if (gn.orders[gn.head].amount < _amount) {\n                OrderItem memory order = gn.orders[gn.head];\n                while (order.next != 0 && order.amount <= _amount) {\n                    order = gn.orders[order.next];\n                }\n                if (order.amount > _amount) {\n                    insertOrderBefore(\n                        self,\n                        value,\n                        order.orderId,\n                        _amount,\n                        _orderId\n                    );\n                } else {\n                    insertOrderAfter(\n                        self,\n                        value,\n                        order.orderId,\n                        _amount,\n                        _orderId\n                    );\n                }\n            } else {\n                addHead(self, value, _amount, _orderId);\n            }\n        }\n    }\n\n    /**\n     * @dev Insert a new OrderImer after the Order denoted by `_id` with `_amount` and `_orderId` in the amount field.\n     */\n    function insertOrderAfter(\n        Tree storage self,\n        uint256 value,\n        uint256 _prevId,\n        uint256 _amount,\n        uint256 _orderId\n    ) internal {\n        require(_amount > 0, \"Insuficient amount\");\n\n        Node storage gn = self.nodes[value];\n\n        if (_prevId == gn.tail) {\n            addTail(self, value, _amount, _orderId);\n        } else {\n            OrderItem memory prevOrder = gn.orders[_prevId];\n            OrderItem memory nextOrder = gn.orders[prevOrder.next];\n            uint256 newOrderId = _createOrder(self, value, _amount, _orderId);\n            _link(self, value, newOrderId, nextOrder.orderId);\n            _link(self, value, prevOrder.orderId, newOrderId);\n        }\n    }\n\n    /**\n     * @dev Insert a new Object before the Object denoted by `_id` with `_amount` and `_orderId` in the data field.\n     */\n    function insertOrderBefore(\n        Tree storage self,\n        uint256 value,\n        uint256 _nextId,\n        uint256 _amount,\n        uint256 _orderId\n    ) internal {\n        Node storage gn = self.nodes[value];\n\n        if (_nextId == gn.head) {\n            addHead(self, value, _amount, _orderId);\n        } else {\n            insertOrderAfter(\n                self,\n                value,\n                gn.orders[_nextId].prev,\n                _amount,\n                _orderId\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to update the Head pointer.\n     */\n    function _setHead(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId\n    ) internal {\n        Node storage gn = self.nodes[value];\n\n        gn.head = orderId;\n    }\n\n    /**\n     * @dev Internal function to update the Tail pointer.\n     */\n    function _setTail(\n        Tree storage self,\n        uint256 value,\n        uint256 orderId\n    ) internal {\n        Node storage gn = self.nodes[value];\n\n        gn.tail = orderId;\n    }\n\n    /**\n     * @dev Internal function to create an unlinked Order.\n     */\n    function _createOrder(\n        Tree storage self,\n        uint256 value,\n        uint256 amount,\n        uint256 orderId\n    ) internal returns (uint256) {\n        Node storage gn = self.nodes[value];\n        uint256 newId;\n        if (gn.orderCounter == 0) {\n            newId = 1;\n        }\n        gn.orderCounter += 1;\n        OrderItem memory order = OrderItem(\n            orderId,\n            0,\n            0,\n            block.timestamp,\n            amount\n        );\n        gn.orders[order.orderId] = order;\n        return order.orderId;\n    }\n\n    /**\n     * @dev Internal function to link an Object to another.\n     */\n    function _link(\n        Tree storage self,\n        uint256 value,\n        uint256 _prevId,\n        uint256 _nextId\n    ) internal {\n        Node storage gn = self.nodes[value];\n\n        gn.orders[_prevId].next = _nextId;\n        gn.orders[_nextId].prev = _prevId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/LendingMarketController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./libraries/QuickSort.sol\";\nimport \"./libraries/DiscountFactor.sol\";\nimport \"./LendingMarket.sol\";\nimport \"./interfaces/ILendingMarketController.sol\";\nimport \"./interfaces/ILendingMarket.sol\";\nimport \"./interfaces/ICurrencyController.sol\";\nimport \"./interfaces/ITermStructure.sol\";\n\n/**\n * @dev Lending Market Controller contract is managing separated lending\n * order-book markets (per term) and responsible to calculate Discount Factors per currency\n * and construct yield curve\n *\n * It will store lending market addresses by ccy and term in lendingMarkets mapping.\n */\ncontract LendingMarketController is ILendingMarketController {\n    using SafeMath for uint256;\n    using QuickSort for uint256[];\n\n    bytes4 constant prefix = 0x21aaa47b;\n    address public override owner;\n    ICurrencyController public currencyController;\n    ITermStructure public termStructure;\n    uint256 public override numberOfMarkets = 0;\n\n    mapping(bytes32 => mapping(uint256 => address))\n        public\n        override lendingMarkets;\n    mapping(bytes32 => uint256[]) public supportedTerms;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"INVALID_ACCESS\");\n        _;\n    }\n\n    /**\n     * @dev Lending Market Controller Constructor.\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Sets owner of the controller market.\n     * @param _owner Address of new owner\n     */\n    function setOwner(address _owner) public onlyOwner {\n        require(_owner != address(0), \"new owner is the zero address\");\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    /**\n     * @dev Triggers to link with Currency Controller contract.\n     * @param addr CurrencyController smart contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function setCurrencyController(address addr) public onlyOwner {\n        currencyController = ICurrencyController(addr);\n    }\n\n    /**\n     * @dev Triggers to link with TermStructure contract.\n     * @param addr TermStructure smart contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function setTermStructure(address addr) public onlyOwner {\n        termStructure = ITermStructure(addr);\n    }\n\n    // =========== YIELD CURVE FUNCTIONS ===========\n\n    /**\n     * @dev Triggers to get borrow rates for selected currency.\n     * @param _ccy Currency\n     */\n    function getBorrowRatesForCcy(bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256[] memory terms = supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint256 i = 0; i < terms.length; i++) {\n            uint256 term = terms[i];\n            ILendingMarket market = ILendingMarket(lendingMarkets[_ccy][term]);\n            rates[i] = market.getBorrowRate();\n        }\n\n        return rates;\n    }\n\n    /**\n     * @dev Triggers to get lend rates for selected currency.\n     * @param _ccy Currency\n     */\n    function getLendRatesForCcy(bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256[] memory terms = supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint256 i = 0; i < terms.length; i++) {\n            uint256 term = terms[i];\n            ILendingMarket market = ILendingMarket(lendingMarkets[_ccy][term]);\n            rates[i] = market.getLendRate();\n        }\n\n        return rates;\n    }\n\n    /**\n     * @dev Triggers to get mid rates for selected currency.\n     * @param _ccy Currency\n     */\n    function getMidRatesForCcy(bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256[] memory terms = supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint256 i = 0; i < terms.length; i++) {\n            uint256 term = terms[i];\n            ILendingMarket market = ILendingMarket(lendingMarkets[_ccy][term]);\n            rates[i] = market.getMidRate();\n        }\n\n        return rates;\n    }\n\n    // =========== DISCOUNT FACTORS CALCULATION ===========\n\n    function getDiscountFactorsForCcy(bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256[] memory, uint256[] memory)\n    {\n        uint256[] memory rates = getMidRatesForCcy(_ccy);\n        return DiscountFactor.calculateDFs(rates, supportedTerms[_ccy]);\n    }\n\n    function getSupportedTerms(bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return supportedTerms[_ccy];\n    }\n\n    // =========== MARKET DEPLOYMENT FUNCTIONS ===========\n\n    /**\n     * @dev Deploys new Lending Market and save address at lendingMarkets mapping.\n     * @param _ccy Main currency for new lending market\n     * @param _term Term for new Lending Market\n     *\n     * @notice Reverts on deployment market with existing currency and term\n     */\n    function deployLendingMarket(bytes32 _ccy, uint256 _term)\n        public\n        override\n        onlyOwner\n        returns (address market)\n    {\n        require(currencyController.isSupportedCcy(_ccy), \"NON SUPPORTED CCY\");\n        require(\n            termStructure.isSupportedTerm(_term, prefix, _ccy),\n            \"NON SUPPORTED TERM\"\n        );\n        require(\n            lendingMarkets[_ccy][_term] == address(0),\n            \"Couldn't rewrite existing market\"\n        );\n        market = address(new LendingMarket(_ccy, _term, address(this)));\n        lendingMarkets[_ccy][_term] = market;\n\n        supportedTerms[_ccy].push(_term);\n        supportedTerms[_ccy] = supportedTerms[_ccy].sort();\n\n        emit LendingMarketCreated(_ccy, _term, market);\n        return market;\n    }\n\n    // =========== LENDING MARKETS MANAGEMENT FUNCTIONS ===========\n\n    /**\n     * @dev Pauses previously deployed lending market by currency\n     * @param _ccy Currency for pausing all lending markets\n     */\n    function pauseLendingMarkets(bytes32 _ccy)\n        public\n        override\n        onlyOwner\n        returns (bool)\n    {\n        uint256[] memory terms = supportedTerms[_ccy];\n\n        for (uint256 i = 0; i < terms.length; i++) {\n            uint256 term = terms[i];\n            ILendingMarket market = ILendingMarket(lendingMarkets[_ccy][term]);\n            market.pauseMarket();\n        }\n\n        emit LendingMarketsPaused(_ccy);\n        return true;\n    }\n\n    /**\n     * @dev Unpauses previously deployed lending market by currency\n     * @param _ccy Currency for pausing all lending markets\n     */\n    function unpauseLendingMarkets(bytes32 _ccy)\n        public\n        override\n        onlyOwner\n        returns (bool)\n    {\n        uint256[] memory terms = supportedTerms[_ccy];\n\n        for (uint256 i = 0; i < terms.length; i++) {\n            uint256 term = terms[i];\n            ILendingMarket market = ILendingMarket(lendingMarkets[_ccy][term]);\n            market.unpauseMarket();\n        }\n\n        emit LendingMarketsUnpaused(_ccy);\n        return true;\n    }\n\n    // =========== BULK TRADE FUNCTIONS ===========\n\n    /**\n     * @dev Places orders in multiple Lending Markets.\n     * @param orders Lending Market orders array with ccy and terms to identify right market\n     */\n    function placeBulkOrders(Order[] memory orders)\n        public\n        override\n        returns (bool)\n    {\n        for (uint8 i = 0; i < orders.length; i++) {\n            Order memory order = orders[i];\n\n            ILendingMarket market = ILendingMarket(\n                lendingMarkets[order.ccy][order.term]\n            );\n            market.order(uint8(order.side), order.amount, order.rate);\n        }\n    }\n}\n"
    },
    "contracts/libraries/QuickSort.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nlibrary QuickSort {\n    function sort(uint256[] memory data)\n        public\n        pure\n        returns (uint256[] memory)\n    {\n        quickSort(data, int256(0), int256(data.length - 1));\n        return data;\n    }\n\n    function quickSort(\n        uint256[] memory arr,\n        int256 left,\n        int256 right\n    ) internal pure {\n        int256 i = left;\n        int256 j = right;\n        if (i == j) return;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n        while (i <= j) {\n            while (arr[uint256(i)] < pivot) i++;\n            while (pivot < arr[uint256(j)]) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (\n                    arr[uint256(j)],\n                    arr[uint256(i)]\n                );\n                i++;\n                j--;\n            }\n        }\n        if (left < j) quickSort(arr, left, j);\n        if (i < right) quickSort(arr, i, right);\n    }\n}\n"
    },
    "contracts/libraries/DiscountFactor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary DiscountFactor {\n    using SafeMath for uint256;\n\n    uint256 internal constant BP = 10000; // basis point\n    uint256 internal constant NON_ANNUAL_TERMS = 3;\n\n    function determineDF(\n        uint256 rate,\n        uint256 term,\n        uint256[] memory cache,\n        uint256 dfSum,\n        uint256 index\n    ) internal pure returns (uint256 df) {\n        if (term < 365) {\n            df = BP.mul(BP).div((BP.add(rate.mul(term).div(360))));\n        } else if (term == 365) {\n            df = BP.mul(BP).div((BP.add(rate)));\n            dfSum = dfSum.add(df);\n        } else {\n            uint256 rateSum = (rate.mul(dfSum)).div(BP);\n            if (rateSum > BP) {\n                df = 0;\n            } else {\n                df = BP.mul(BP.sub(rate.mul(dfSum).div(BP))).div(BP.add(rate));\n            }\n            dfSum = dfSum.add(df);\n        }\n\n        cache[index] = df;\n\n        return dfSum;\n    }\n\n    function calculateDFs(uint256[] memory rates, uint256[] memory terms)\n        public\n        pure\n        returns (uint256[] memory, uint256[] memory)\n    {\n        require(rates.length == terms.length, \"INVALID_PARAMS\");\n\n        (\n            uint256[] memory bootstrapedRates,\n            uint256[] memory bootstrapedTerms\n        ) = bootstrapTerms(rates, terms);\n\n        uint256 len = bootstrapedTerms.length;\n        uint256[] memory dfs = new uint256[](len);\n        uint256 dfSum;\n\n        for (uint256 i = 0; i < len; i++) {\n            dfSum = determineDF(\n                bootstrapedRates[i],\n                bootstrapedTerms[i],\n                dfs,\n                dfSum,\n                i\n            );\n        }\n\n        return (dfs, bootstrapedTerms);\n    }\n\n    function maxDFs(uint256 maxTerm) internal pure returns (uint256) {\n        return maxTerm.div(365).add(NON_ANNUAL_TERMS);\n    }\n\n    struct TermBootstrapingLocalVars {\n        uint256 extendedTerms;\n        uint256 delta;\n        uint256 numItems;\n        uint256 lastKnownRate;\n        uint256 nextKnownRate;\n        uint256 nextKnownTerm;\n        bool upwards;\n        uint256 deltaRate;\n        uint256 step;\n    }\n\n    function bootstrapTerms(uint256[] memory rates, uint256[] memory terms)\n        public\n        pure\n        returns (uint256[] memory, uint256[] memory)\n    {\n        uint256 len = maxDFs(terms[terms.length - 1]);\n\n        uint256[] memory filledRates = new uint256[](len);\n        uint256[] memory filledTerms = new uint256[](len);\n        TermBootstrapingLocalVars memory vars;\n\n        for (uint256 i = 0; i < terms.length.sub(1); i++) {\n            if (terms[i] < 365) {\n                filledRates[i] = rates[i];\n                filledTerms[i] = terms[i];\n                continue;\n            }\n            vars.delta = terms[i + 1].sub(terms[i]);\n\n            if (vars.delta <= 365) {\n                filledRates[i] = rates[i];\n                filledTerms[i] = terms[i];\n                continue;\n            }\n\n            vars.numItems = vars.delta.div(365);\n            vars.lastKnownRate = rates[i];\n\n            if (vars.extendedTerms == 0) {\n                filledRates[i] = vars.lastKnownRate;\n                filledTerms[i] = terms[i];\n            }\n            vars.nextKnownRate = rates[i + 1];\n            vars.nextKnownTerm = terms[i + 1];\n            vars.upwards = vars.nextKnownRate > vars.lastKnownRate\n                ? true\n                : false;\n            vars.deltaRate = vars.upwards\n                ? vars.nextKnownRate.sub(vars.lastKnownRate)\n                : vars.lastKnownRate.sub(vars.nextKnownRate);\n            vars.step = vars.deltaRate.div(vars.numItems);\n\n            for (uint256 j = 1; j < vars.numItems; j++) {\n                vars.extendedTerms = vars.extendedTerms.add(1);\n\n                uint256 newIndex = i.add(vars.extendedTerms);\n                uint256 missedRate = vars.upwards\n                    ? filledRates[newIndex.sub(1)].add(vars.step)\n                    : filledRates[newIndex.sub(1)].sub(vars.step);\n                uint256 missedTerm = terms[i].add(uint256(365).mul(j));\n\n                filledRates[newIndex] = missedRate;\n                filledTerms[newIndex] = missedTerm;\n\n                if (j == vars.numItems.sub(1)) {\n                    uint256 shifterIndex = newIndex.add(1);\n\n                    filledRates[shifterIndex] = vars.nextKnownRate;\n                    filledTerms[shifterIndex] = vars.nextKnownTerm;\n                }\n            }\n        }\n\n        return (filledRates, filledTerms);\n    }\n\n    struct DFInterpolationLocalVars {\n        uint256 timeDelta;\n        uint256 termSeconds;\n        uint256 prevTermSeconds;\n        uint256 left;\n        uint256 right;\n        uint256 total;\n    }\n\n    /**\n     * @dev Triggers to adjust discount factors by interpolating to current loan maturity\n     * @param discountFactors Discount factors array\n     * @param terms Array of terms\n     * @param date Date to calculate discount factors for\n     *\n     */\n    function interpolateDF(\n        uint256[] memory discountFactors,\n        uint256[] memory terms,\n        uint256 date\n    ) public view returns (uint256) {\n        DFInterpolationLocalVars memory vars;\n        vars.timeDelta = date.sub(block.timestamp);\n\n        if (vars.timeDelta <= terms[0].mul(86400)) {\n            vars.termSeconds = terms[0].mul(86400);\n            vars.left = vars.termSeconds.sub(vars.timeDelta);\n\n            return\n                (BP.mul(vars.left).add(discountFactors[0].mul(vars.timeDelta)))\n                    .div(vars.termSeconds);\n        } else {\n            for (uint256 i = 1; i < terms.length; i++) {\n                vars.termSeconds = terms[i].mul(86400);\n                vars.prevTermSeconds = terms[i - 1].mul(86400);\n\n                if (\n                    vars.prevTermSeconds < vars.timeDelta &&\n                    vars.timeDelta <= vars.termSeconds\n                ) {\n                    vars.left = vars.timeDelta.sub(vars.prevTermSeconds);\n\n                    if (vars.left == 0) {\n                        return discountFactors[i]; // gas savings only\n                    }\n\n                    vars.right = vars.termSeconds.sub(vars.timeDelta);\n                    if (vars.right == 0) {\n                        return discountFactors[i];\n                    }\n\n                    vars.total = vars.termSeconds.sub(vars.prevTermSeconds);\n\n                    return (\n                        (discountFactors[i - 1].mul(vars.right))\n                            .add((discountFactors[i].mul(vars.left)))\n                            .div(vars.total)\n                    );\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ILendingMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nstruct MarketOrder {\n    uint8 side;\n    uint256 amount;\n    uint256 rate;\n    uint256 deadline;\n    address maker;\n}\n\ninterface ILendingMarket {\n    event CancelOrder(\n        uint256 orderId,\n        address indexed maker,\n        uint8 side,\n        uint256 amount,\n        uint256 rate\n    );\n    event MakeOrder(\n        uint256 orderId,\n        address indexed maker,\n        uint8 side,\n        bytes32 ccy,\n        uint8 term,\n        uint256 amount,\n        uint256 rate\n    );\n    event Paused(address account);\n    event TakeOrder(\n        uint256 orderId,\n        address indexed taker,\n        uint8 side,\n        uint256 amount,\n        uint256 rate\n    );\n    event Unpaused(address account);\n\n    function MarketCcy() external view returns (bytes32);\n\n    function MarketTerm() external view returns (uint8);\n\n    function cancelOrder(uint256 orderId) external returns (bool success);\n\n    function getBorrowRate() external view returns (uint256 rate);\n\n    function getLendRate() external view returns (uint256 rate);\n\n    function getMaker(uint256 orderId) external view returns (address maker);\n\n    function getMidRate() external view returns (uint256 rate);\n\n    function getOrder(uint256 orderId)\n        external\n        view\n        returns (MarketOrder memory);\n\n    function getOrderFromTree(uint256 orderId)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function last_order_id() external view returns (uint256);\n\n    function lendingController() external view returns (address);\n\n    function matchOrders(\n        uint8 side,\n        uint256 amount,\n        uint256 rate\n    ) external view returns (uint256);\n\n    function order(\n        uint8 side,\n        uint256 amount,\n        uint256 rate\n    ) external returns (bool);\n\n    function orders(uint256)\n        external\n        view\n        returns (\n            uint8 side,\n            uint256 amount,\n            uint256 rate,\n            address maker\n        );\n\n    function pauseMarket() external;\n\n    function paused() external view returns (bool);\n\n    function setCollateral(address colAddr) external;\n\n    function setLoan(address addr) external;\n\n    function unpauseMarket() external;\n}\n"
    },
    "contracts/interfaces/ITermStructure.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface ITermStructure {\n    event TermAdded(uint256 numDays);\n    event ProductTermSupportUpdated(\n        uint256 numDays,\n        bytes4 product,\n        bytes32 _ccy,\n        bool isSupported\n    );\n    event TermSupportUpdated(uint256 numDays, bool isSupported);\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    function getDfFrac(uint256 _numDays) external view returns (uint256);\n\n    function getNumDays(uint256 _numDays) external view returns (uint256);\n\n    function getNumPayments(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (uint256);\n\n    function getTerm(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getTermSchedule(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isSupportedTerm(\n        uint256 _numDays,\n        bytes4 _product,\n        bytes32 _ccy\n    ) external view returns (bool);\n\n    function last_term_index() external view returns (uint8);\n\n    function owner() external view returns (address);\n\n    function setCurrencyController(address _currencyController) external;\n\n    function setOwner(address _owner) external;\n\n    function supportTerm(\n        uint256 _numDays,\n        bytes4[] memory _products,\n        bytes32[] memory _currencies\n    ) external returns (bool);\n\n    function updateTermSupport(\n        uint256 _numDays,\n        bytes4 _product,\n        bytes32 _ccy,\n        bool _isSupported\n    ) external returns (bool);\n\n    function getTermsForProductAndCcy(\n        bytes4 _product,\n        bytes32 _ccy,\n        bool sort\n    ) external view returns (uint256[] memory);\n}\n"
    },
    "contracts/TermStructure.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./interfaces/ITermStructure.sol\";\nimport \"./interfaces/ICurrencyController.sol\";\nimport \"./interfaces/IProductAddressResolver.sol\";\nimport \"./libraries/QuickSort.sol\";\nimport \"./libraries/TermSchedule.sol\";\n\n/**\n * @dev Term Structure contract is responsible for managing supported\n * terms in Secured Finance Protocol per product and currency\n *\n */\ncontract TermStructure is ITermStructure {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using QuickSort for uint256[];\n\n    address public override owner;\n    uint8 public override last_term_index;\n\n    ICurrencyController private currencyController;\n    IProductAddressResolver private productResolver;\n\n    struct Term {\n        uint256 numDays;\n        uint256 dfFrac;\n        uint256 numPayments;\n    }\n\n    mapping(uint256 => uint256) private terms;\n    mapping(bytes4 => mapping(bytes32 => EnumerableSet.UintSet))\n        private termsForProductAndCcy;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier existingTermOnly(uint256 _numDays) {\n        require(terms[_numDays] == _numDays, \"NON EXISTING TERM\");\n        _;\n    }\n\n    /**\n     * @dev Term Structure Constructor.\n     */\n    constructor(address _currencyController, address _productAddressResolver)\n        public\n    {\n        owner = msg.sender;\n        currencyController = ICurrencyController(_currencyController);\n        productResolver = IProductAddressResolver(_productAddressResolver);\n    }\n\n    /**\n     * @dev Sets owner of the controller market.\n     * @param _owner Address of new owner\n     */\n    function setOwner(address _owner) public override onlyOwner {\n        require(_owner != address(0), \"new owner is the zero address\");\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    /**\n     * @dev Triggers to link with Currency Controller contract.\n     * @param _currencyController CurrencyController smart contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function setCurrencyController(address _currencyController)\n        public\n        override\n        onlyOwner\n    {\n        currencyController = ICurrencyController(_currencyController);\n    }\n\n    /**\n     * @dev Triggers to add new term into the protocol\n     * @param _numDays Number of calendar days in a term\n     * @param _currencies Array of currencies supporting this term\n     * @param _products Array of products supporting this term\n     */\n    function supportTerm(\n        uint256 _numDays,\n        bytes4[] memory _products,\n        bytes32[] memory _currencies\n    ) public override onlyOwner returns (bool) {\n        last_term_index = last_term_index++;\n\n        terms[_numDays] = _numDays;\n\n        if (_products.length > 0) {\n            for (uint256 i = 0; i < _products.length; i++) {\n                bytes4 product = _products[i];\n\n                for (uint256 j = 0; j < _currencies.length; j++) {\n                    bytes32 ccy = _currencies[j];\n                    updateTermSupport(_numDays, product, ccy, true);\n                }\n            }\n        }\n\n        emit TermAdded(_numDays);\n    }\n\n    /**\n     * @dev Triggers to update product and currency support for term\n     * @param _numDays Number of days in term\n     * @param _product Product prefix\n     * @param _ccy Currency short identifier\n     * @param _isSupported Boolean whether term supported for specified `_product` and `_ccy`\n     */\n    function updateTermSupport(\n        uint256 _numDays,\n        bytes4 _product,\n        bytes32 _ccy,\n        bool _isSupported\n    ) public override onlyOwner existingTermOnly(_numDays) returns (bool) {\n        require(\n            productResolver.isSupportedProduct(_product),\n            \"NON SUPPORTED PRODUCT\"\n        );\n        require(currencyController.isSupportedCcy(_ccy), \"NON SUPPORTED CCY\");\n\n        if (_isSupported) {\n            termsForProductAndCcy[_product][_ccy].add(_numDays);\n        } else {\n            termsForProductAndCcy[_product][_ccy].remove(_numDays);\n        }\n\n        emit ProductTermSupportUpdated(_numDays, _product, _ccy, _isSupported);\n    }\n\n    /**\n     * @dev Triggers to get term structure.\n     * @param _numDays Number of days in term\n     */\n    function getTerm(uint256 _numDays, uint8 _frequency)\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Term memory term;\n\n        term.numDays = terms[_numDays];\n        term.dfFrac = getDfFrac(_numDays);\n        term.numPayments = getNumPayments(_numDays, _frequency);\n\n        return (term.numDays, term.dfFrac, term.numPayments);\n    }\n\n    /**\n     * @dev Triggers to get payment schedule for supported term according to the payment frequency\n     * number of days follows ACT365 market convention\n     * @param _numDays Number of days in term\n     * @param _frequency Payment frequency (like annual, semi-annual, etc.)\n     */\n    function getTermSchedule(uint256 _numDays, uint8 _frequency)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return TermSchedule.getTermSchedule(_numDays, _frequency);\n    }\n\n    /**\n     * @dev Triggers to get number of days for supported term.\n     * number of days follows ACT365 market convention\n     * @param _numDays Number of days in term\n     */\n    function getNumDays(uint256 _numDays)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return terms[_numDays];\n    }\n\n    /**\n     * @dev Triggers to get discount factor fractions.\n     * @param _numDays Number of days in term\n     */\n    function getDfFrac(uint256 _numDays)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return TermSchedule.getDfFrac(_numDays);\n    }\n\n    /**\n     * @dev Triggers to get number of coupon payments.\n     * @param _numDays Number of days in term\n     * @param _frequency Payment frequency (like annual, semi-annual, etc.)\n     */\n    function getNumPayments(uint256 _numDays, uint8 _frequency)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return TermSchedule.getNumPayments(_numDays, _frequency);\n    }\n\n    /**\n     * @dev Triggers to get if specified term is supported for a particular ccy and product.\n     * @param _numDays Number of days in term\n     * @param _product Product prefix\n     * @param _ccy Currency short identifier\n     */\n    function isSupportedTerm(\n        uint256 _numDays,\n        bytes4 _product,\n        bytes32 _ccy\n    ) public view override returns (bool) {\n        EnumerableSet.UintSet storage set = termsForProductAndCcy[_product][\n            _ccy\n        ];\n        return set.contains(_numDays);\n    }\n\n    /**\n     * @dev Returns an array of supported terms for a specific product and currency\n     * @param _product Product prefix\n     * @param _ccy Currency short identifier\n     */\n    function getTermsForProductAndCcy(\n        bytes4 _product,\n        bytes32 _ccy,\n        bool sort\n    ) public view override returns (uint256[] memory) {\n        EnumerableSet.UintSet storage set = termsForProductAndCcy[_product][\n            _ccy\n        ];\n        uint256 numTerms = set.length();\n        uint256[] memory supportedTerms = new uint256[](numTerms);\n\n        for (uint256 i = 0; i < numTerms; i++) {\n            uint256 term = set.at(i);\n            supportedTerms[i] = term;\n        }\n\n        if (sort) {\n            supportedTerms = supportedTerms.sort();\n        }\n\n        return supportedTerms;\n    }\n}\n"
    },
    "contracts/interfaces/IProductAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface IProductAddressResolver {\n    event RegisterProduct(\n        bytes4 prefix,\n        address indexed product,\n        address indexed controller\n    );\n\n    /**\n     * @dev Trigers to register new product type in a address resolver\n     * @param _prefix Bytes4 prefix for product type\n     * @param _contract Product contract address\n     * @param _controller Market controller address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving contract which is not supporting a common interface\n     */\n    function registerProduct(\n        bytes4 _prefix,\n        address _contract,\n        address _controller\n    ) external;\n\n    /**\n     * @dev Trigers to register several product types in a address resolver\n     * @param _prefixes Array of Bytes4 prefixes for each product type\n     * @param _contracts Array of smart contract addresses for each product\n     * @param _controllers Array of market controller addresses\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving contract which is not supporting common interface\n     */\n    function registerProducts(\n        bytes4[] calldata _prefixes,\n        address[] calldata _contracts,\n        address[] calldata _controllers\n    ) external;\n\n    /**\n     * @dev Trigers to get product address by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     * @notice To work with the contract this address should be wrapped around IProduct interface\n     */\n    function getProductContract(bytes4 _prefix) external view returns (address);\n\n    /**\n     * @dev Trigers to get product address by deal id\n     * @param _dealId Product deal idenfitier\n     * @notice To work with the contract this address should be wrapped around IProduct interface\n     */\n    function getProductContractByDealId(bytes32 _dealId)\n        external\n        view\n        returns (address);\n\n    /**\n     * @dev Trigers to get market controller address by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\n     */\n    function getControllerContract(bytes4 _prefix)\n        external\n        view\n        returns (address);\n\n    /**\n     * @dev Trigers to get market controller address by deal id\n     * @param _dealId Product deal idenfitier\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\n     */\n    function getControllerContractByDealId(bytes32 _dealId)\n        external\n        view\n        returns (address);\n\n    /**\n     * @dev Triggers to verify if a specific product is supported by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     */\n    function isSupportedProduct(bytes4 _prefix) external view returns (bool);\n\n    /**\n     * @dev Triggers to verify if a specific product is supported by deal id.\n     * @param _dealId Product deal idenfitier\n     */\n    function isSupportedProductByDealId(bytes32 _dealId)\n        external\n        view\n        returns (bool);\n}\n"
    },
    "contracts/libraries/TermSchedule.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nlibrary TermSchedule {\n    using SafeMath for uint256;\n\n    enum PaymentFrequency {\n        ANNUAL,\n        SEMI_ANNUAL,\n        QUARTERLY,\n        MONTHLY,\n        FORWARD\n    }\n\n    /**\n     * @dev Triggers to get payment schedule for supported term according to the payment frequency\n     * number of days follows ACT365 market convention\n     * @param _numDays Number of days in term\n     * @param _frequency Payment frequency (like annual, semi-annual, etc.)\n     */\n    function getTermSchedule(uint256 _numDays, uint8 _frequency)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        if (PaymentFrequency(_frequency) == PaymentFrequency.ANNUAL) {\n            if (_numDays >= 365) {\n                uint256 numYears = _numDays.div(365);\n                uint256[] memory paymentSchedule = new uint256[](numYears);\n\n                for (uint256 i = 0; i < numYears; i++) {\n                    uint256 j = i.add(1);\n                    paymentSchedule[i] = j.mul(365);\n                }\n\n                return paymentSchedule;\n            } else if (_numDays > 0) {\n                uint256[] memory paymentSchedule = new uint256[](1);\n                paymentSchedule[0] = _numDays;\n\n                return paymentSchedule;\n            }\n        } else if (\n            PaymentFrequency(_frequency) == PaymentFrequency.SEMI_ANNUAL\n        ) {\n            if (_numDays >= 180) {\n                uint256 numHalfYears = _numDays.div(180);\n                uint256[] memory paymentSchedule = new uint256[](numHalfYears);\n\n                for (uint256 i = 0; i < numHalfYears; i++) {\n                    uint256 j = i.add(1);\n                    paymentSchedule[i] = j.mul(180);\n                }\n\n                return paymentSchedule;\n            } else if (_numDays > 0) {\n                uint256[] memory paymentSchedule = new uint256[](1);\n                paymentSchedule[0] = _numDays;\n\n                return paymentSchedule;\n            }\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.QUARTERLY) {\n            if (_numDays >= 90) {\n                uint256 numQuarters = _numDays.div(90);\n                uint256[] memory paymentSchedule = new uint256[](numQuarters);\n\n                for (uint256 i = 0; i < numQuarters; i++) {\n                    uint256 j = i.add(1);\n                    paymentSchedule[i] = j.mul(90);\n                }\n\n                return paymentSchedule;\n            } else if (_numDays > 0) {\n                uint256[] memory paymentSchedule = new uint256[](1);\n                paymentSchedule[0] = _numDays;\n\n                return paymentSchedule;\n            }\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.MONTHLY) {\n            if (_numDays >= 30) {\n                uint256 numMonths = _numDays.div(30);\n                uint256[] memory paymentSchedule = new uint256[](numMonths);\n\n                for (uint256 i = 0; i < numMonths; i++) {\n                    uint256 j = i.add(1);\n                    paymentSchedule[i] = j.mul(30);\n                }\n\n                return paymentSchedule;\n            } else if (_numDays > 0) {\n                uint256[] memory paymentSchedule = new uint256[](1);\n                paymentSchedule[0] = _numDays;\n\n                return paymentSchedule;\n            }\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.FORWARD) {\n            uint256[] memory paymentSchedule = new uint256[](1);\n            paymentSchedule[0] = _numDays;\n\n            return paymentSchedule;\n        }\n    }\n\n    /**\n     * @dev Triggers to get discount factor fractions.\n     * @param _numDays Number of days in term\n     */\n    function getDfFrac(uint256 _numDays) internal pure returns (uint256) {\n        if (_numDays >= 365) {\n            return 10000;\n        } else if (_numDays < 365) {\n            uint256 sectors = uint256(360).div(_numDays);\n            return uint256(10000).div(sectors);\n        }\n    }\n\n    /**\n     * @dev Triggers to get number of coupon payments.\n     * @param _numDays Number of days in term\n     * @param _frequency Payment frequency (like annual, semi-annual, etc.)\n     */\n    function getNumPayments(uint256 _numDays, uint8 _frequency)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (PaymentFrequency(_frequency) == PaymentFrequency.ANNUAL) {\n            if (_numDays >= 365) {\n                return _numDays.div(365);\n            } else if (_numDays > 0) {\n                return 1;\n            } else return 0;\n        } else if (\n            PaymentFrequency(_frequency) == PaymentFrequency.SEMI_ANNUAL\n        ) {\n            if (_numDays >= 365) {\n                uint256 _monthConvention = _numDays.sub(\n                    _numDays.div(365).mul(5)\n                );\n                return _monthConvention.div(180);\n            } else if (_numDays >= 180) {\n                return _numDays.div(180);\n            } else if (_numDays > 0) {\n                return 1;\n            } else return 0;\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.QUARTERLY) {\n            if (_numDays >= 365) {\n                uint256 _monthConvention = _numDays.sub(\n                    _numDays.div(365).mul(5)\n                );\n                return _monthConvention.div(90);\n            } else if (_numDays >= 90) {\n                return _numDays.div(90);\n            } else if (_numDays > 0) {\n                return 1;\n            } else return 0;\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.MONTHLY) {\n            if (_numDays >= 365) {\n                uint256 _monthConvention = _numDays.sub(\n                    _numDays.div(365).mul(5)\n                );\n                return _monthConvention.div(30);\n            } else if (_numDays >= 30) {\n                return _numDays.div(30);\n            } else if (_numDays > 0) {\n                return 1;\n            } else return 0;\n        } else if (PaymentFrequency(_frequency) == PaymentFrequency.FORWARD) {\n            return 1;\n        }\n    }\n}\n"
    },
    "contracts/test/TermStructureTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../TermStructure.sol\";\n\ncontract TermStructureTest is TermStructure {\n    constructor(address _currencyController, address _productAddressResolver)\n        public\n        TermStructure(_currencyController, _productAddressResolver)\n    {}\n\n    function getGasCostOfGetTerm(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        getTerm(_numDays, frequency);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetTermSchedule(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        getTermSchedule(_numDays, frequency);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetNumDays(uint256 _numDays)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        getNumDays(_numDays);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetDfFrac(uint256 _numDays)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        getDfFrac(_numDays);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetNumPayments(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        getNumPayments(_numDays, frequency);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfIsSupportedTerm(\n        uint256 _numDays,\n        bytes4 _product,\n        bytes32 _ccy\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        isSupportedTerm(_numDays, _product, _ccy);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetTermsForProductAndCcy(\n        bytes4 _product,\n        bytes32 _ccy,\n        bool sort\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        getTermsForProductAndCcy(_product, _ccy, sort);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/test/TermScheduleTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\n\nimport \"../libraries/TermSchedule.sol\";\n\ncontract TermScheduleTest {\n    function getTermSchedule(uint256 numDays, uint8 frequency)\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return TermSchedule.getTermSchedule(numDays, frequency);\n    }\n\n    function getNumPayments(uint256 numDays, uint8 frequency)\n        external\n        view\n        returns (uint256)\n    {\n        return TermSchedule.getNumPayments(numDays, frequency);\n    }\n\n    function getDfFrac(uint256 numDays) external view returns (uint256) {\n        return TermSchedule.getDfFrac(numDays);\n    }\n\n    function getGasCostOfGetTermSchedule(uint256 numDays, uint8 frequency)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        TermSchedule.getTermSchedule(numDays, frequency);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetNumPayment(uint256 numDays, uint8 frequency)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        TermSchedule.getNumPayments(numDays, frequency);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetDfFrac(uint256 numDays)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        TermSchedule.getDfFrac(numDays);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/ProductAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/IProductAddressResolver.sol\";\nimport \"./libraries/DealId.sol\";\n\n/**\n * @title ProductAddressResolver contract is used to store addresses for each product\n * type supported on the protocol. Addresses stored per bytes4 prefixes which\n * are a simple identifiers of the product type\n */\ncontract ProductAddressResolver is IProductAddressResolver {\n    using Address for address;\n\n    event RegisterProduct(\n        bytes4 prefix,\n        address indexed product,\n        address indexed controller\n    );\n\n    address public owner;\n\n    // Mapping for storing product contract addresses\n    mapping(bytes4 => address) _productContracts;\n    mapping(bytes4 => address) _controllerContracts;\n\n    /**\n     * @dev Modifier to check if passed prefix is valid\n     */\n    modifier validPrefix(bytes4 _prefix) {\n        require(_productContracts[_prefix] != address(0), \"INVALID_ADDRESS\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"INVALID_ACCESS\");\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     *\n     * @notice sets contract deployer as owner of this contract\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Trigers to register new product type in a address resolver\n     * @param _prefix Bytes4 prefix for product type\n     * @param _contract Product contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving contract which is not supporting a common interface\n     */\n    function registerProduct(\n        bytes4 _prefix,\n        address _contract,\n        address _controller\n    ) public override onlyOwner {\n        require(_contract.isContract(), \"Can't add non-contract address\");\n        require(_controller.isContract(), \"Can't add non-contract address\");\n        _productContracts[_prefix] = _contract;\n        _controllerContracts[_prefix] = _controller;\n        emit RegisterProduct(_prefix, _contract, _controller);\n    }\n\n    /**\n     * @dev Trigers to register several product types in a address resolver\n     * @param _prefixes Array of Bytes4 prefixes for each product type\n     * @param _contracts Array of smart contract addresses for each product\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving contract which is not supporting common interface\n     */\n    function registerProducts(\n        bytes4[] calldata _prefixes,\n        address[] calldata _contracts,\n        address[] calldata _controllers\n    ) public override onlyOwner {\n        require(_prefixes.length == _contracts.length, \"Invalid input lengths\");\n\n        for (uint256 i = 0; i < _prefixes.length; i++) {\n            bytes4 prefix = _prefixes[i];\n            address addr = _contracts[i];\n            require(addr.isContract(), \"Can't add non-contract address\");\n\n            address controller = _controllers[i];\n            require(controller.isContract(), \"Can't add non-contract address\");\n\n            _productContracts[prefix] = addr;\n            _controllerContracts[prefix] = controller;\n\n            emit RegisterProduct(prefix, addr, controller);\n        }\n    }\n\n    /**\n     * @dev Trigers to get product address by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     * @notice To work with the contract this address should be wrapped around IProduct interface\n     */\n    function getProductContract(bytes4 _prefix)\n        public\n        view\n        override\n        returns (address)\n    {\n        return _productContracts[_prefix];\n    }\n\n    /**\n     * @dev Trigers to get product address by deal id\n     * @param _dealId Product deal idenfitier\n     * @notice To work with the contract this address should be wrapped around IProduct interface\n     */\n    function getProductContractByDealId(bytes32 _dealId)\n        public\n        view\n        override\n        returns (address)\n    {\n        bytes4 prefix = DealId.getPrefix(_dealId);\n        return _productContracts[prefix];\n    }\n\n    /**\n     * @dev Trigers to get market controller address by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\n     */\n    function getControllerContract(bytes4 _prefix)\n        public\n        view\n        override\n        returns (address)\n    {\n        return _controllerContracts[_prefix];\n    }\n\n    /**\n     * @dev Trigers to get market controller address by deal id\n     * @param _dealId Product deal idenfitier\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\n     */\n    function getControllerContractByDealId(bytes32 _dealId)\n        public\n        view\n        override\n        returns (address)\n    {\n        bytes4 prefix = DealId.getPrefix(_dealId);\n        return _controllerContracts[prefix];\n    }\n\n    /**\n     * @dev Triggers to verify if a specific product is supported by short prefix.\n     * @param _prefix Bytes4 prefix for product type\n     */\n    function isSupportedProduct(bytes4 _prefix)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return _productContracts[_prefix] != address(0);\n    }\n\n    /**\n     * @dev Triggers to verify if a specific product is supported by deal id.\n     * @param _dealId Product deal idenfitier\n     */\n    function isSupportedProductByDealId(bytes32 _dealId)\n        public\n        view\n        override\n        returns (bool)\n    {\n        bytes4 prefix = DealId.getPrefix(_dealId);\n        return _productContracts[prefix] != address(0);\n    }\n}\n"
    },
    "contracts/libraries/DealId.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nlibrary DealId {\n    /**\n     * @dev Generates a deal id using a product prefix and deal number\n     * @param prefix Product type prefix in bytes4\n     * @param counter Number of deal to be generated\n     * @return id in bytes32 with prefix on the left and counter on the right side\n     */\n    function generate(bytes32 prefix, uint256 counter)\n        public\n        pure\n        returns (bytes32 id)\n    {\n        uint224 num = toUint224(counter);\n        bytes4 r;\n        bytes32 zero = 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000;\n        assembly {\n            r := and(prefix, zero)\n            id := add(r, num)\n        }\n    }\n\n    /**\n     * @dev Returns product based prefix from deal id\n     * @param id Deal unique identification string\n     * @return prefix in bytes4\n     */\n    function getPrefix(bytes32 id) public pure returns (bytes4 prefix) {\n        assembly {\n            prefix := shl(0, id)\n        }\n    }\n\n    /**\n     * @dev Returns converted number from uint256 to uint224\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"NUMBER_OVERFLOW\");\n        return uint224(value);\n    }\n}\n"
    },
    "contracts/test/ProductAddressResolverTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../ProductAddressResolver.sol\";\n\ncontract ProductAddressResolverTest is ProductAddressResolver {\n    function getGasCostOfGetProductContract(bytes4 _prefix)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        getProductContract(_prefix);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetControllerContract(bytes4 _prefix)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        getControllerContract(_prefix);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetProductContractWithTypeConversion(bytes32 _dealID)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        bytes4 _prefix;\n\n        assembly {\n            _prefix := shl(0, _dealID)\n        }\n\n        getProductContract(_prefix);\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfGetControllerContractWithTypeConversion(\n        bytes32 _dealID\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        bytes4 _prefix;\n        assembly {\n            _prefix := shr(0, _dealID)\n        }\n\n        getControllerContract(_prefix);\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/test/DealIdTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\n\nimport \"../libraries/DealId.sol\";\n\ncontract DealIdTest {\n    bytes4 sample_prefix = 0x21aaa47b;\n\n    function generate(uint256 number) external view returns (bytes32 id) {\n        id = DealId.generate(sample_prefix, number);\n    }\n\n    function getGasCostOfGenerate(uint256 number)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        DealId.generate(sample_prefix, number);\n\n        return gasBefore - gasleft();\n    }\n\n    function getPrefix(bytes32 id) external pure returns (bytes4 prefix) {\n        prefix = DealId.getPrefix(id);\n    }\n\n    function getGasCostOfGetPrefix(bytes32 id) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        DealId.getPrefix(id);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/LoanV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/ICollateralAggregatorV2.sol\";\nimport \"./ProtocolTypes.sol\";\nimport \"./interfaces/ILendingMarketController.sol\";\nimport \"./interfaces/IPaymentAggregator.sol\";\nimport \"./interfaces/IProductWithOneLeg.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./libraries/DealId.sol\";\nimport \"./libraries/DiscountFactor.sol\";\nimport \"./libraries/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"./interfaces/ITermStructureGetter.sol\";\nimport \"./interfaces/ILiquidations.sol\";\n\n/**\n * @title LoanV2 contract is used to store Lending deals in Secured Finance\n * protocol. This contract handle the PV updates on lending market rate changes\n * also allowing parties to mutually terminate their lending deals\n *\n * Contract linked to Lending Market contracts, LendingMarketController and Collateral contract.\n */\ncontract LoanV2 is ProtocolTypes, IProductWithOneLeg {\n    using SafeMath for uint256;\n\n    uint256 constant NOTICE = 2 weeks;\n    uint256 constant SETTLE = 2 days;\n    uint256 constant MAXPAYNUM = 6;\n    bytes4 constant prefix = 0x21aaa47b;\n    uint16 private constant VERSION = 1;\n    uint256 public settlementWindow = 2;\n    uint8 public paymentFrequency = uint8(PaymentFrequency.ANNUAL);\n\n    struct LoanDeal {\n        address lender;\n        address borrower;\n        bytes32 ccy;\n        uint256 term;\n        uint256 notional;\n        uint256 rate;\n        uint256 start;\n        uint256 end;\n        uint256 pv;\n        bytes32 startTxHash;\n    }\n\n    struct Termination {\n        address terminationAsker;\n        uint256 terminationDate;\n    }\n\n    /**\n     * @dev Mapping for all storing LoanDeals per loanIDs.\n     */\n    mapping(bytes32 => LoanDeal) private loans;\n    mapping(bytes32 => Termination) private terminations;\n    mapping(bytes32 => bool) private isSettled;\n\n    address public owner;\n    bool public isTransferable;\n    uint256 public last_loan_id = 0;\n\n    // Contracts\n    ICollateralAggregator collateralAggregator;\n    ILendingMarketController lendingController;\n    IPaymentAggregator paymentAggregator;\n    ITermStructureGetter termStructure;\n    ILiquidations liquidations;\n\n    mapping(bytes32 => mapping(uint256 => address)) public lendingMarkets;\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if LendingMarket contract linked with this contract\n     * @param _ccy LendingMarket currency\n     * @param _term LendingMarket term\n     */\n    modifier lendingMarketExists(bytes32 _ccy, uint256 _term) {\n        require(lendingMarkets[_ccy][_term] == msg.sender);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the loan deal is active.\n     * @param loanId Loan deal ID\n     */\n    modifier workingLoan(bytes32 loanId) {\n        require(isSettled[loanId], \"loan is not working\");\n        _;\n    }\n\n    modifier onlyLiquidationContract() {\n        require(msg.sender == address(liquidations), \"INVALID_ACCESS\");\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     *\n     * @notice sets contract deployer as owner of this contract\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Triggers to link with LendingMarketController contract.\n     * @param addr LendingMarketController contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function setLendingControllerAddr(address addr) public onlyOwner {\n        lendingController = ILendingMarketController(addr);\n    }\n\n    /**\n     * @dev Triggers to link with Collateral contract.\n     * @param addr Collateral contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function setCollateralAddr(address addr) public onlyOwner {\n        collateralAggregator = ICollateralAggregator(addr);\n    }\n\n    /**\n     * @dev Triggers to link with PaymentAggregator contract.\n     * @param addr Payment Aggregator contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function setPaymentAggregator(address addr) public onlyOwner {\n        paymentAggregator = IPaymentAggregator(addr);\n    }\n\n    /**\n     * @dev Triggers to link with TermStructure contract.\n     * @param addr TermStructure contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function setTermStructure(address addr) public onlyOwner {\n        termStructure = ITermStructureGetter(addr);\n    }\n\n    /**\n     * @dev Triggers to link with Liquidations contract.\n     * @param addr Liquidations contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function setLiquidations(address addr) public onlyOwner {\n        liquidations = ILiquidations(addr);\n    }\n\n    /**\n     * @dev Triggers to change ability to transfer loan ownership by lenders.\n     * @param isAccepted Boolean to\n     *\n     * @notice Executed only by contract owner\n     */\n    function setIsTransferable(bool isAccepted) public onlyOwner {\n        isTransferable = isAccepted;\n    }\n\n    /**\n     * @dev Triggers to link with existing LendingMarket.\n     * @param _ccy LendingMarket main currency\n     * @param _term LendingMarket term\n     * @param addr LendingMarket contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function addLendingMarket(\n        bytes32 _ccy,\n        uint256 _term,\n        address addr\n    ) public onlyOwner {\n        require(\n            lendingMarkets[_ccy][_term] == address(0),\n            \"Couldn't rewrite existing market\"\n        );\n        lendingMarkets[_ccy][_term] = addr;\n    }\n\n    /**\n     * @dev Internal function to generate deal id based on product prefix and deals counter\n     */\n    function _generateDealId() internal returns (bytes32 id) {\n        last_loan_id += 1;\n        id = DealId.generate(prefix, last_loan_id);\n    }\n\n    /**\n     * @dev Triggered to register new loan deal, also locks borrowers collateral.\n     * @param maker LendingMarket order market maker\n     * @param taker LendingMarket order market taker\n     * @param side MarketOrder side\n     * @param ccy Loan deal main currency\n     * @param term Loan deal term\n     * @param notional Notional amount of funds to lend/borrow\n     * @param rate Loan deal annual interest rate\n     *\n     * @notice Callable only by LendingMarket after matching orders\n     */\n    function register(\n        address maker,\n        address taker,\n        uint8 side,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate\n    ) public override lendingMarketExists(ccy, term) returns (bytes32 loanId) {\n        require(maker != taker, \"Same person deal is not allowed\");\n        address lender;\n        address borrower;\n\n        if (Side(side) == Side.LEND) {\n            lender = maker;\n            borrower = taker;\n        } else if (Side(side) == Side.BORROW) {\n            lender = taker;\n            borrower = maker;\n        }\n\n        collateralAggregator.releaseUnsettledCollateral(\n            lender,\n            ccy,\n            notional.mul(MKTMAKELEVEL).div(PCT)\n        );\n        collateralAggregator.useCollateral(\n            lender,\n            borrower,\n            ccy,\n            notional.mul(MKTMAKELEVEL).div(PCT),\n            notional,\n            false\n        );\n\n        LoanDeal memory deal;\n        deal.lender = lender;\n        deal.borrower = borrower;\n        deal.ccy = ccy;\n        deal.term = term;\n        deal.notional = notional;\n        deal.rate = rate;\n        deal.start = block.timestamp;\n        deal.end = block.timestamp.add(deal.term.mul(86400));\n\n        loanId = _generateDealId();\n        loans[loanId] = deal;\n\n        _registerPaymentSchedule(loanId, deal);\n        // liquidations.addDealToLiquidationQueue(lender, borrower, loanId);\n\n        emit Register(lender, borrower, ccy, term, notional, rate, loanId);\n    }\n\n    /**\n     * @dev Triggers to get settlement status of loan deal.\n     * @param loanId Loan deal ID\n     */\n    function getDealSettlementStatus(bytes32 loanId)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return isSettled[loanId];\n    }\n\n    // /**\n    // * @dev Triggers to get the state of the deal by `dealId`.\n    // * @param loanId Loan deal ID\n    // */\n    // function getDealState(bytes32 loanId) public view override returns (uint8) {\n    //     return 0;\n    // }\n\n    /**\n     * @dev Triggers to get main currency the deal by `dealId`.\n     * @param loanId Loan deal ID\n     */\n    function getDealCurrency(bytes32 loanId)\n        public\n        view\n        override\n        returns (bytes32)\n    {\n        return loans[loanId].ccy;\n    }\n\n    /**\n     * @dev Triggers to get current information about Loan deal.\n     * @param loanId Loan deal ID\n     */\n    function getLoanDeal(bytes32 loanId) public view returns (LoanDeal memory) {\n        return loans[loanId];\n    }\n\n    /**\n     * @dev Triggers to get termination state for loan with `loanId`.\n     * @param loanId Loan deal ID\n     */\n    function getTerminationState(bytes32 loanId)\n        public\n        view\n        returns (Termination memory)\n    {\n        return terminations[loanId];\n    }\n\n    /**\n     * @dev Returns the payment schedule for a deal by `loanId`\n     * @param loanId Loan deal ID\n     */\n    function getPaymentSchedule(bytes32 loanId)\n        public\n        view\n        override\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            bool[] memory\n        )\n    {\n        LoanDeal memory deal = loans[loanId];\n\n        return _constructSchedule(deal, true);\n    }\n\n    /**\n     * @dev Returns the timestamp of the last settled payment in payment schedule\n     * @param loanId Loan deal ID\n     */\n    function getLastSettledPayment(bytes32 loanId)\n        external\n        view\n        returns (uint256 settlementTime)\n    {\n        LoanDeal memory deal = loans[loanId];\n\n        uint256 payNums = termStructure.getNumPayments(\n            deal.term,\n            paymentFrequency\n        );\n        uint256[] memory daysArr = termStructure.getTermSchedule(\n            deal.term,\n            paymentFrequency\n        );\n\n        for (uint256 i = payNums; i > 0; i--) {\n            uint256 time = _timeShift(deal.start, daysArr[i - 1]);\n            bool status = paymentAggregator.isSettled(\n                deal.lender,\n                deal.borrower,\n                deal.ccy,\n                time\n            );\n\n            if (status) {\n                settlementTime = time;\n            }\n        }\n    }\n\n    /**\n     * @dev Triggers to get stored present value of loan deal.\n     * @param loanId Loan ID to update PV for\n     */\n    function getDealLastPV(\n        address party0,\n        address party1,\n        bytes32 loanId\n    ) public view override returns (uint256, uint256) {\n        LoanDeal memory deal = loans[loanId];\n\n        if (deal.pv == 0) {\n            deal.pv = getDealPV(loanId);\n        }\n\n        if (party0 == deal.lender && party1 == deal.borrower) {\n            return (0, deal.pv);\n        } else if (party0 == deal.borrower && party1 == deal.lender) {\n            return (deal.pv, 0);\n        }\n\n        return (0, 0);\n    }\n\n    // =========== EARLY TERMINATION SECTION ===========\n\n    /**\n     * @dev Triggers to request early termination of the loan.\n     * @param loanId Loan deal ID\n     *\n     * @notice Executed only for working loan deal\n     */\n    function requestTermination(bytes32 loanId) public override {\n        Termination storage termination = terminations[loanId];\n        LoanDeal memory deal = loans[loanId];\n        require(\n            msg.sender == deal.lender || msg.sender == deal.borrower,\n            \"parties must request\"\n        );\n        require(updateLoanPV(loanId), \"failed MtM\");\n\n        termination.terminationAsker = msg.sender;\n\n        emit RequestTermination(loanId, msg.sender);\n    }\n\n    /**\n     * @dev Triggers to accept early termination of the loan.\n     * @param loanId Loan deal ID\n     *\n     * @notice Executed only for working loan deal\n     */\n    function acceptTermination(bytes32 loanId) public override {\n        Termination storage termination = terminations[loanId];\n        require(\n            termination.terminationAsker != address(0),\n            \"no termination request\"\n        );\n\n        LoanDeal memory deal = loans[loanId];\n\n        if (termination.terminationAsker == deal.lender) {\n            require(msg.sender == deal.borrower, \"borrower must accept\");\n        } else {\n            require(msg.sender == deal.lender, \"lender must accept\");\n        }\n\n        require(updateLoanPV(loanId), \"failed MtM\");\n\n        if (isSettled[loanId]) {\n            (\n                uint256[] memory payments,\n                ,\n                bool[] memory settlements\n            ) = _constructSchedule(deal, true);\n\n            uint256 i;\n            for (i = 0; i < settlements.length; i++) {\n                if (settlements[i] == false) break;\n            }\n\n            uint256 deltaDays;\n\n            if (i == 0) {\n                deltaDays = BokkyPooBahsDateTimeLibrary.diffDays(\n                    deal.start,\n                    block.timestamp\n                );\n            } else {\n                deltaDays = BokkyPooBahsDateTimeLibrary.diffDays(\n                    payments[i - 1],\n                    block.timestamp\n                );\n            }\n\n            uint256 interestRatePerDay = deal.rate.mul(1e18).div(36500);\n            uint256 accuredInterestRate = interestRatePerDay.mul(deltaDays);\n            uint256 accuredInterest = deal\n                .notional\n                .mul(accuredInterestRate)\n                .div(1e20);\n            uint256 totalPayment = accuredInterest.add(deal.pv);\n            collateralAggregator.liquidate(\n                deal.borrower,\n                deal.lender,\n                deal.ccy,\n                totalPayment,\n                deal.pv,\n                true\n            );\n            // collateralAggregator.releaseCollateral(deal.lender, deal.borrower, deal.ccy, 0, deal.pv, true);\n\n            emit EarlyTermination(loanId, msg.sender, totalPayment);\n        } else {\n            // collateralAggregator.releaseCollateral(deal.lender, deal.borrower, deal.ccy, deal.notional.mul(MKTMAKELEVEL).div(PCT), deal.notional, false);\n            emit EarlyTermination(loanId, msg.sender, 0);\n        }\n\n        _liquidateLoan(loanId);\n    }\n\n    /**\n     * @dev Triggers to reject early termination of the loan.\n     * @param loanId Loan deal ID\n     *\n     * @notice Executed only for working loan deal\n     */\n    function rejectTermination(bytes32 loanId) public override {\n        Termination memory termination = terminations[loanId];\n        require(\n            termination.terminationAsker != address(0),\n            \"no termination request\"\n        );\n\n        LoanDeal memory deal = loans[loanId];\n        require(\n            msg.sender == deal.lender || msg.sender == deal.borrower,\n            \"parties must reject\"\n        );\n        require(updateLoanPV(loanId), \"failed MtM\");\n\n        delete terminations[loanId];\n\n        emit RejectTermination(loanId, msg.sender);\n    }\n\n    /**\n     * @dev Triggers to transfer loan ownership.\n     * @param loanId Loan deal ID\n     * @param newOwner Address of new owner (lender)\n     *\n     * @notice Executed only by original lender\n     */\n    function novation(bytes32 loanId, address newOwner)\n        public\n        override\n        workingLoan(loanId)\n    {\n        LoanDeal storage deal = loans[loanId];\n        require(isTransferable, \"transfers not allowed\");\n\n        address prevLender = deal.lender;\n        require(msg.sender == prevLender, \"lender must trasfer\");\n\n        _removePaymentSchedule(loanId, deal);\n        collateralAggregator.releaseCollateral(\n            prevLender,\n            deal.borrower,\n            deal.ccy,\n            0,\n            deal.pv,\n            true\n        );\n\n        deal.lender = newOwner;\n\n        _registerPaymentSchedule(loanId, deal);\n        collateralAggregator.useCollateral(\n            newOwner,\n            deal.borrower,\n            deal.ccy,\n            0,\n            deal.pv,\n            true\n        );\n\n        emit Novation(loanId, newOwner);\n    }\n\n    function liquidate(bytes32 loanId) external override {\n        _liquidateLoan(loanId);\n    }\n\n    // =========== MARK-TO-MARKET SECTION ===========\n\n    /**\n     * @dev Main function for mark-to-market: updates present value,\n     * loan state and liquidates loan deal if collateral coverage <125%\n     * for every liquidation msg.sender get rewarded ~5% of loan deal PV.\n     * @param loanId Loan ID to update PV for\n     */\n    function markToMarket(bytes32 loanId) external override returns (bool) {\n        _verifyNotionalExchange(loanId);\n        require(updateLoanPV(loanId), \"failed update PV\");\n        // updateState(loanId);\n\n        return true;\n    }\n\n    /**\n     * @dev Triggers to update present value of loan.\n     * @param loanId Loan ID to update PV for\n     *\n     * @notice Calculates discount factors based on lending markets rates,\n     * and updates the state of the loan. Can be triggered to liquidate loan deal\n     * if borrower's collateral not enough.\n     */\n    function updateLoanPV(bytes32 loanId) internal returns (bool) {\n        uint256 pv = getDealPV(loanId);\n\n        if (pv != 0) {\n            LoanDeal storage deal = loans[loanId];\n            if (!isSettled[loanId]) return true;\n\n            uint256 oldPV = deal.pv == 0 ? deal.notional : deal.pv;\n            deal.pv = pv;\n\n            collateralAggregator.updatePV(\n                deal.lender,\n                deal.borrower,\n                deal.ccy,\n                0,\n                oldPV,\n                0,\n                deal.pv\n            );\n\n            emit MarkToMarket(loanId, oldPV, pv);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Triggers to recalculate present value of loan deal.\n     * @param loanId Loan ID to update PV for\n     */\n    function getDealPV(bytes32 loanId)\n        public\n        view\n        override\n        returns (uint256 pv)\n    {\n        LoanDeal memory deal = loans[loanId];\n        if (!isSettled[loanId]) return deal.notional;\n\n        (uint256[] memory dfs, uint256[] memory terms) = lendingController\n            .getDiscountFactorsForCcy(deal.ccy);\n\n        (\n            uint256[] memory payments,\n            uint256[] memory amounts,\n\n        ) = _constructSchedule(deal, false);\n\n        for (uint256 i = 0; i < payments.length; i++) {\n            if (payments[i] < block.timestamp) continue;\n            uint256 d = DiscountFactor.interpolateDF(dfs, terms, payments[i]);\n\n            pv = pv.add((amounts[i].mul(d)));\n        }\n\n        return pv.div(BP);\n    }\n\n    /**\n     * @dev Internal function to liquidate loan deal and remove all payments in timeslots\n     * @param loanId Loan deal ID\n     */\n    function _liquidateLoan(bytes32 loanId) internal {\n        LoanDeal memory deal = loans[loanId];\n        _removePaymentSchedule(loanId, deal);\n        // collateralAggregator.releaseCollateral(deal.lender, deal.borrower, deal.ccy, 0, deal.pv, true);\n\n        emit Liquidate(loanId);\n        delete loans[loanId];\n    }\n\n    /**\n     * @dev Internal function to get TimeSlot position after adding days\n     * @param timestamp Timestamp to add days\n     * @param numDays number of days to add\n     * @return Updated timestamp and TimeSlot position\n     */\n    function _timeShift(uint256 timestamp, uint256 numDays)\n        internal\n        pure\n        returns (uint256)\n    {\n        timestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, numDays);\n\n        return timestamp;\n    }\n\n    /**\n     * @dev Internal function for registering payment schedule while registering new loan\n     * @param loanId Loan deal ID\n     * @param deal LoanDeal structure\n     */\n    function _registerPaymentSchedule(bytes32 loanId, LoanDeal memory deal)\n        internal\n    {\n        (\n            uint256[] memory payments,\n            uint256[] memory amounts,\n\n        ) = _constructSchedule(deal, false);\n\n        uint256[] memory lenderLeg = new uint256[](payments.length);\n        lenderLeg[0] = deal.notional;\n\n        paymentAggregator.registerPayments(\n            deal.lender,\n            deal.borrower,\n            deal.ccy,\n            loanId,\n            payments,\n            lenderLeg,\n            amounts\n        );\n    }\n\n    /**\n     * @dev Internal function for registering payment schedule while registering new loan\n     * @param loanId Loan deal ID\n     * @param deal LoanDeal structure\n     */\n    function _removePaymentSchedule(bytes32 loanId, LoanDeal memory deal)\n        internal\n    {\n        (\n            uint256[] memory payments,\n            uint256[] memory amounts,\n\n        ) = _constructSchedule(deal, false);\n\n        uint256[] memory lenderLeg = new uint256[](payments.length);\n        if (!isSettled[loanId]) {\n            lenderLeg[0] = deal.notional;\n        }\n\n        paymentAggregator.removePayments(\n            deal.lender,\n            deal.borrower,\n            deal.ccy,\n            loanId,\n            payments,\n            lenderLeg,\n            amounts\n        );\n    }\n\n    struct ScheduleConstructionLocalVars {\n        uint256 payNums;\n        uint256[] daysArr;\n        uint256 dfFrac;\n        uint256 coupon;\n        uint256 time;\n        bool status;\n    }\n\n    /**\n     * @dev Internal function to construct payment schedule using deal parameters\n     * @param deal Loan deal structure\n     * @param settlementStatus Boolean wether settlement status should be returned\n     * @return Payment schedule structure\n     */\n    function _constructSchedule(LoanDeal memory deal, bool settlementStatus)\n        internal\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            bool[] memory\n        )\n    {\n        ScheduleConstructionLocalVars memory vars;\n\n        vars.payNums = termStructure.getNumPayments(\n            deal.term,\n            paymentFrequency\n        );\n        vars.daysArr = termStructure.getTermSchedule(\n            deal.term,\n            paymentFrequency\n        );\n        vars.dfFrac = termStructure.getDfFrac(deal.term);\n\n        vars.coupon = (deal.notional.mul(deal.rate).mul(vars.dfFrac))\n            .div(BP)\n            .div(BP);\n\n        uint256 len = vars.payNums.add(1);\n        uint256[] memory payments = new uint256[](len);\n        uint256[] memory amounts = new uint256[](len);\n        bool[] memory settlements = new bool[](len);\n\n        for (uint256 i = 1; i <= vars.payNums; i++) {\n            uint256 time = _timeShift(deal.start, vars.daysArr[i - 1]);\n\n            payments[i] = time;\n            if (i == vars.payNums) {\n                amounts[i] = deal.notional.add(vars.coupon);\n            } else {\n                amounts[i] = vars.coupon;\n            }\n\n            if (settlementStatus) {\n                vars.status = paymentAggregator.isSettled(\n                    deal.lender,\n                    deal.borrower,\n                    deal.ccy,\n                    vars.time\n                );\n                settlements[i] = vars.status;\n            }\n        }\n\n        uint256 settlement = _timeShift(deal.start, 2);\n        payments[0] = settlement;\n\n        return (payments, amounts, settlements);\n    }\n\n    /**\n     * @dev Internal function to verify the settlement of notional exchange\n     * @param loanId Loan deal id\n     */\n    function _verifyNotionalExchange(bytes32 loanId) internal {\n        if (!isSettled[loanId]) {\n            LoanDeal memory deal = loans[loanId];\n            uint256 time = _timeShift(deal.start, 2);\n            bool status = paymentAggregator.isSettled(\n                deal.lender,\n                deal.borrower,\n                deal.ccy,\n                time\n            );\n\n            if (status) {\n                isSettled[loanId] = true;\n                collateralAggregator.releaseCollateral(\n                    deal.lender,\n                    deal.borrower,\n                    deal.ccy,\n                    deal.notional.mul(MKTMAKELEVEL).div(PCT),\n                    0,\n                    false\n                );\n                collateralAggregator.settleCollateral(\n                    deal.lender,\n                    deal.borrower,\n                    deal.ccy,\n                    0,\n                    deal.notional\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Triggers to return loan product implementation version\n     * @return implementation version\n     */\n    function getVersion() public view override returns (uint16) {\n        return VERSION;\n    }\n}\n"
    },
    "contracts/interfaces/IProductWithOneLeg.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./IProduct.sol\";\n\n/**\n * @title IProductWithOneLeg is an extention over IProduct interface for\n * products with one leg of cashflows\n */\ninterface IProductWithOneLeg is IProduct {\n    struct Schedule {\n        uint256[] payments;\n        uint256[] amounts;\n        bool[] isSettled;\n    }\n\n    event Register(\n        address indexed lender,\n        address indexed borrower,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate,\n        bytes32 indexed dealId\n    );\n\n    event Novation(bytes32 indexed dealId, address currLender);\n\n    /**\n     * Triggered to register new deal for this product type\n     *\n     * @param maker Order maker\n     * @param taker orderTaker\n     * @param side Order side\n     * @param ccy Settlement currency\n     * @param term Deal term\n     * @param notional Notional amount of funds\n     * @param rate Annual interest rate\n     * @return dealId bytes32 string.\n     */\n    function register(\n        address maker,\n        address taker,\n        uint8 side,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate\n    ) external returns (bytes32 dealId);\n\n    /**\n     * Triggered to transfer lending obligations from msg.sender ot newOwner\n     * @param dealId Deal unique id in bytes32 word.\n     * @param newOwner ETH address of new product lender\n     */\n    function novation(bytes32 dealId, address newOwner) external;\n\n    /**\n     * Returns the payment schedule of the deal\n     * @param dealId Deal unique id in bytes32 word.\n     *\n     * @return Payment schedule payment timestamps, payment amounts and settlement statuses\n     */\n    function getPaymentSchedule(bytes32 dealId)\n        external\n        view\n        returns (\n            uint256[] memory,\n            uint256[] memory,\n            bool[] memory\n        );\n}\n"
    },
    "contracts/interfaces/ITermStructureGetter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface ITermStructureGetter {\n    function getDfFrac(uint256 _numDays) external view returns (uint256);\n\n    function getNumDays(uint256 _numDays) external view returns (uint256);\n\n    function getNumPayments(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (uint256);\n\n    function getTerm(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function getTermSchedule(uint256 _numDays, uint8 frequency)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isSupportedTerm(\n        uint256 _numDays,\n        bytes4 _product,\n        bytes32 _ccy\n    ) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IProduct.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\n/**\n * @title IProduct is a common interface for various products on secured finance protocol\n */\ninterface IProduct {\n    event Liquidate(bytes32 dealId);\n    event RequestTermination(bytes32 dealId, address indexed requestedBy);\n    event RejectTermination(bytes32 dealId, address indexed rejectedBy);\n    event EarlyTermination(\n        bytes32 dealId,\n        address indexed acceptedBy,\n        uint256 payment\n    );\n    event MarkToMarket(bytes32 dealId, uint256 prevPV, uint256 currPV);\n\n    /**\n     * Triggered to liquidate existing deal of this product type\n     * @param dealId Deal unique id in bytes32 word.\n     */\n    function liquidate(bytes32 dealId) external;\n\n    /**\n     * Triggered to request early termination of this specific deal\n     * @param dealId Deal unique id in bytes32 word.\n     */\n    function requestTermination(bytes32 dealId) external;\n\n    /**\n     * Triggered to reject previously requested early termination of this deal\n     * @param dealId Deal unique id in bytes32 word.\n     */\n    function rejectTermination(bytes32 dealId) external;\n\n    /**\n     * Triggered to accept previously requested early termination of this deal\n     * @param dealId Deal unique id in bytes32 word.\n     */\n    function acceptTermination(bytes32 dealId) external;\n\n    /**\n     * Triggered to update present value of the deal\n     * @param dealId Deal unique id in bytes32 word.\n     */\n    function markToMarket(bytes32 dealId) external returns (bool);\n\n    // /**\n    //  * Returns the state of the deal by `dealId`\n    //  * @param dealId Deal unique id in bytes32 word.\n    //  *\n    //  * @return State identifier\n    //  */\n    // function getDealState(bytes32 dealId) external view returns (uint8);\n\n    /**\n     * Returns the main currency of the deal.\n     * @param dealId Deal unique id in bytes32 word.\n     *\n     * @return Currency short identifier.\n     */\n    function getDealCurrency(bytes32 dealId) external view returns (bytes32);\n\n    /**\n     * Returns previously saved present value of the deal.\n     * @param dealId Deal unique id in bytes32 word.\n     *\n     * @return Present value previously saved during mark-to-market.\n     */\n    function getDealLastPV(\n        address party0,\n        address party1,\n        bytes32 dealId\n    ) external view returns (uint256, uint256);\n\n    /**\n     * Triggers to recalculate and return current present value of the deal.\n     * @param dealId Deal unique id in bytes32 word.\n     *\n     * @return Present value at the time of execution.\n     */\n    function getDealPV(bytes32 dealId) external view returns (uint256);\n\n    /**\n     * Returns settlement status of the deal by `dealId`\n     * @param dealId Deal unique id in bytes32 word.\n     *\n     * @return Settlement bool identifier\n     */\n    function getDealSettlementStatus(bytes32 dealId)\n        external\n        view\n        returns (bool);\n\n    /**\n     * Get the version of the underlying contract.\n     *\n     * @return Version number.\n     */\n    function getVersion() external view returns (uint16);\n}\n"
    },
    "contracts/Liquidations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./libraries/AddressPacking.sol\";\nimport \"./interfaces/IProductAddressResolver.sol\";\nimport \"./interfaces/ICollateralAggregatorV2.sol\";\nimport \"./interfaces/ICurrencyController.sol\";\nimport \"./interfaces/IProduct.sol\";\nimport \"./interfaces/ILiquidations.sol\";\n\ncontract Liquidations is ILiquidations {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    uint256 public override offset;\n    address public owner;\n    EnumerableSet.AddressSet private liquidationAgents;\n    EnumerableSet.AddressSet private linkedContracts;\n\n    // Mapping structure for storing liquidation queue to bilateral position\n    mapping(bytes32 => EnumerableSet.Bytes32Set) private liquidationQueue;\n\n    // Contracts\n    IProductAddressResolver productResolver;\n    ICollateralAggregator collateralAggregator;\n    ICurrencyController currencyController;\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by liquidation agent.\n     */\n    modifier onlyLiquidationAgent() {\n        require(liquidationAgents.contains(msg.sender), \"INVALID ACCESS\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by liquidation agent.\n     */\n    modifier onlyLinkedContract() {\n        require(linkedContracts.contains(msg.sender), \"INVALID ACCESS\");\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     *\n     * @notice sets contract deployer as owner of this contract,\n     * liquidation agent and liquidation offset\n     */\n    constructor(address _liquidationAgent, uint256 _offset) public {\n        owner = msg.sender;\n        liquidationAgents.add(_liquidationAgent);\n        offset = _offset;\n    }\n\n    /**\n     * @dev Triggers to link with ProductAddressResolver contract.\n     * @param addr ProductAddressResolver contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function setProductAddressResolver(address addr) public onlyOwner {\n        productResolver = IProductAddressResolver(addr);\n    }\n\n    /**\n     * @dev Triggers to link with CollateralAggregator contract.\n     * @param addr CollateralAggregator contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function setCollateralAggregator(address addr) public onlyOwner {\n        collateralAggregator = ICollateralAggregator(addr);\n    }\n\n    /**\n     * @dev Triggers to link with CurrencyController contract.\n     * @param addr CurrencyController contract address\n     *\n     * @notice Executed only by contract owner\n     */\n    function setCurrencyController(address addr) public onlyOwner {\n        currencyController = ICurrencyController(addr);\n    }\n\n    /**\n     * @dev Updates offset for maximum number of deals liquidated per one execution.\n     * @param _offset New liquidation offset\n     */\n    function updateLiquidationOffset(uint256 _offset)\n        public\n        override\n        onlyOwner\n    {\n        require(_offset > 0, \"INCORRECT_OFFSET\");\n        emit OffsetUpdated(offset, _offset);\n        offset = _offset;\n    }\n\n    /**\n     * @dev Triggers to link liquidation contract with smart contract with specified `_addr`.\n     * @param _addr Liquidation agent address\n     */\n    function linkContract(address _addr) public override onlyOwner {\n        linkedContracts.add(_addr);\n        emit LinkedContract(_addr);\n    }\n\n    /**\n     * @dev Adds liquidation agent address into the set.\n     * @param _liquidationAgent Liquidation agent address\n     */\n    function addLiquidationAgent(address _liquidationAgent)\n        public\n        override\n        onlyOwner\n    {\n        liquidationAgents.add(_liquidationAgent);\n        emit LiquidationAgentAdded(_liquidationAgent);\n    }\n\n    /**\n     * @dev Removes liquidation agent address from the set.\n     * @param _liquidationAgent Liquidation agent address\n     */\n    function removeLiquidationAgent(address _liquidationAgent)\n        public\n        override\n        onlyOwner\n    {\n        liquidationAgents.remove(_liquidationAgent);\n        emit LiquidationAgentRemoved(_liquidationAgent);\n    }\n\n    /**\n     * @dev Updates owner of the liquidation contract.\n     * @param _owner Address of new owner\n     */\n    function updateOwner(address _owner) public onlyOwner {\n        require(_owner != address(0), \"new owner is the zero address\");\n        emit OwnerUpdated(owner, _owner);\n        owner = _owner;\n    }\n\n    function addDealToLiquidationQueue(\n        address party0,\n        address party1,\n        bytes32 dealId\n    ) public override onlyLinkedContract {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        EnumerableSet.Bytes32Set storage set = liquidationQueue[packedAddrs];\n\n        require(!set.contains(dealId), \"ALREADY EXISTING DEAL\");\n        set.add(dealId);\n\n        DealAddedToLiquidationQueue(party0, party1, dealId);\n    }\n\n    function removeDealFromLiquidationQueue(\n        address party0,\n        address party1,\n        bytes32 dealId\n    ) public override onlyLinkedContract {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        EnumerableSet.Bytes32Set storage set = liquidationQueue[packedAddrs];\n\n        require(set.contains(dealId), \"NON EXISTING DEAL\");\n        set.remove(dealId);\n\n        DealRemovedFromLiquidationQueue(party0, party1, dealId);\n    }\n\n    /**\n     * @dev Triggers to liquidate multiple deals according to the liquidation queue\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     */\n    function liquidateDeals(address party0, address party1)\n        public\n        override\n        onlyLiquidationAgent\n    {\n        (bool coverage0, bool coverage1) = collateralAggregator.isCovered(\n            party0,\n            party1,\n            \"\",\n            0,\n            0,\n            false\n        );\n        if (coverage0 && coverage1) return;\n\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        EnumerableSet.Bytes32Set storage set = liquidationQueue[packedAddrs];\n\n        uint256 numDeals = set.length();\n        uint256 numLiquidations;\n        numDeals > offset\n            ? numLiquidations = offset\n            : numLiquidations = numDeals;\n        bytes32[] memory dealIds = new bytes32[](numLiquidations);\n\n        for (uint256 i = 0; i < numLiquidations; i++) {\n            bytes32 dealId = set.at(i);\n            dealIds[i] = dealId;\n        }\n\n        _liquidateDeals(party0, party1, dealIds);\n    }\n\n    /**\n     * @dev Triggers to liquidate multiple deals with specific `_dealIds`.\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param dealIds Array of Deal ID to liquidate\n     */\n    function liquidateDeals(\n        address party0,\n        address party1,\n        bytes32[] memory dealIds\n    ) public override onlyLiquidationAgent {\n        require(dealIds.length < offset, \"TOO MUCH DEALS\");\n        (bool coverage0, bool coverage1) = collateralAggregator.isCovered(\n            party0,\n            party1,\n            \"\",\n            0,\n            0,\n            false\n        );\n        if (coverage0 && coverage1) return;\n\n        _liquidateDeals(party0, party1, dealIds);\n    }\n\n    struct LiquidationLocalVars {\n        bytes32 dealId;\n        uint256 dealPV0;\n        uint256 dealPV1;\n        uint256 totalLiquidationPVInETH0;\n        uint256 totalLiquidationPVInETH1;\n        uint256 exchangeRate;\n        bytes32 currency;\n        address product;\n    }\n\n    function _liquidateDeals(\n        address party0,\n        address party1,\n        bytes32[] memory dealIds\n    ) internal {\n        LiquidationLocalVars memory vars;\n\n        for (uint256 i = 0; i < dealIds.length; i++) {\n            vars.dealId = dealIds[i];\n            vars.product = productResolver.getProductContractByDealId(\n                vars.dealId\n            );\n\n            vars.currency = IProduct(vars.product).getDealCurrency(vars.dealId);\n\n            (vars.dealPV0, vars.dealPV1) = IProduct(vars.product).getDealLastPV(\n                party0,\n                party1,\n                vars.dealId\n            );\n            vars.exchangeRate = uint256(\n                currencyController.getLastETHPrice(vars.currency)\n            );\n\n            vars.dealPV0 = vars.dealPV0.mul(vars.exchangeRate).div(1e18);\n            vars.dealPV1 = vars.dealPV1.mul(vars.exchangeRate).div(1e18);\n\n            vars.totalLiquidationPVInETH0 = vars.totalLiquidationPVInETH0.add(\n                vars.dealPV0\n            );\n            vars.totalLiquidationPVInETH1 = vars.totalLiquidationPVInETH1.add(\n                vars.dealPV1\n            );\n\n            IProduct(vars.product).liquidate(vars.dealId);\n        }\n\n        if (vars.totalLiquidationPVInETH0 > 0) {\n            collateralAggregator.liquidate(\n                party0,\n                party1,\n                vars.totalLiquidationPVInETH0\n            );\n        }\n\n        if (vars.totalLiquidationPVInETH1 > 0) {\n            collateralAggregator.liquidate(\n                party1,\n                party0,\n                vars.totalLiquidationPVInETH1\n            );\n        }\n    }\n}\n"
    },
    "contracts/MarkToMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./ProtocolTypes.sol\";\nimport \"./interfaces/IMarketController.sol\";\nimport \"./interfaces/IMarkToMarket.sol\";\nimport \"./interfaces/IPaymentAggregator.sol\";\nimport \"./interfaces/IProduct.sol\";\nimport \"./interfaces/IProductAddressResolver.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract MarkToMarket is IMarkToMarket {\n    using SafeMath for uint256;\n\n    uint256 constant NOTICE = 2 weeks;\n    address public owner;\n\n    // Contracts\n    IProductAddressResolver productResolver;\n    IPaymentAggregator paymentAggregator;\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     *\n     * @notice sets contract deployer as owner of this contract and connects to product address resolver contract\n     */\n    constructor(address _productResolver) public {\n        owner = msg.sender;\n        productResolver = IProductAddressResolver(_productResolver);\n    }\n\n    struct PresentValueCalcLocalVars {\n        bytes4 prefix;\n        address controller;\n        IMarketController controllerContract;\n        address product;\n        IProduct productContract;\n    }\n\n    /**\n     * @dev Triggers to update present value for a single deal.\n     * @param dealId Deal ID to update PV for\n     */\n    function updatePV(bytes32 dealId) public override {\n        address product = productResolver.getProductContractByDealId(dealId);\n\n        require(\n            IProduct(product).markToMarket(dealId),\n            \"CAN'T DO MARK-TO-MARKET\"\n        );\n    }\n\n    /**\n     * @dev Triggers to update present value for a multiple deals.\n     * @param dealIds Array of Deal IDs to update PV for\n     */\n    function updatePVs(bytes32[] memory dealIds) public override {\n        PresentValueCalcLocalVars memory vars;\n\n        for (uint256 i = 0; i < dealIds.length; i++) {\n            bytes32 dealId = dealIds[i];\n\n            vars.product = productResolver.getProductContractByDealId(dealId);\n            // vars.controller = productResolver.getControllerContract(vars.prefix);\n\n            require(\n                IProduct(vars.product).markToMarket(dealId),\n                \"CAN'T DO MARK-TO-MARKET\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IMarketController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface IMarketController {\n    function getBorrowRatesForCcy(bytes32 _ccy)\n        external\n        view\n        returns (uint256[] memory rates);\n\n    function getDiscountFactorsForCcy(bytes32 _ccy)\n        external\n        view\n        returns (uint256[] memory, uint256[] memory);\n\n    function getLendRatesForCcy(bytes32 _ccy)\n        external\n        view\n        returns (uint256[] memory rates);\n\n    function getMidRatesForCcy(bytes32 _ccy)\n        external\n        view\n        returns (uint256[] memory rates);\n}\n"
    },
    "contracts/interfaces/IMarkToMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface IMarkToMarket {\n    function updatePV(bytes32 dealId) external;\n\n    function updatePVs(bytes32[] memory dealIds) external;\n}\n"
    },
    "contracts/PaymentAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./ProtocolTypes.sol\";\nimport \"./libraries/TimeSlot.sol\";\nimport \"./libraries/AddressPacking.sol\";\nimport \"./libraries/BokkyPooBahsDateTimeLibrary.sol\";\nimport \"./interfaces/ICloseOutNetting.sol\";\nimport \"./interfaces/IMarkToMarket.sol\";\nimport \"./interfaces/IPaymentAggregator.sol\";\nimport \"./interfaces/ISettlementEngine.sol\";\n\n/**\n * @title Payment Aggregator contract is used to aggregate payments\n * between counterparties in bilateral relationships. Those payments\n * are defined per counterparties addresses (packed into one bytes32),\n * main settlement currency and payment date.\n *\n * Contract linked to all product based contracts like Loan, Swap, etc.\n */\ncontract PaymentAggregator is IPaymentAggregator, ProtocolTypes {\n    using SafeMath for uint256;\n    using Address for address;\n    using TimeSlot for TimeSlot.Slot;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    address public override owner;\n    uint256 public override settlementWindow = 2;\n    uint256 constant MAXPAYNUM = 6;\n\n    // Linked contract addresses\n    EnumerableSet.AddressSet private paymentAggregatorUsers;\n    ICloseOutNetting private closeOutNetting;\n    IMarkToMarket private markToMarket;\n    ISettlementEngine private settlementEngine;\n\n    // Mapping structure for storing TimeSlots\n    mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => TimeSlot.Slot))) _timeSlots;\n    mapping(bytes32 => mapping(bytes32 => mapping(bytes32 => EnumerableSet.Bytes32Set)))\n        private deals;\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if msg.sender is payment aggregator user\n     */\n    modifier acceptedContract() {\n        require(\n            paymentAggregatorUsers.contains(msg.sender),\n            \"not allowed to use payment aggregator\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by passing contract address checks.\n     */\n    modifier onlyContractAddr(address addr) {\n        require(addr != address(0), \"INVALID_ADDRESS\");\n        require(addr.isContract(), \"NOT_CONTRACT\");\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     *\n     * @notice sets contract deployer as owner of this contract\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Trigers to add contract address to payment aggregator users address set\n     * @param _user Payment aggregator user smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function addPaymentAggregatorUser(address _user)\n        public\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(_user != address(0), \"Zero address\");\n        require(_user.isContract(), \"Can't add non-contract address\");\n        require(\n            !paymentAggregatorUsers.contains(_user),\n            \"Can't add existing address\"\n        );\n        return paymentAggregatorUsers.add(_user);\n    }\n\n    /**\n     * @dev Trigers to remove payment aggregator user from address set\n     * @param _user Payment aggregator user smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on removing non-existing payment aggregator user\n     */\n    function removePaymentAggregatorUser(address _user)\n        public\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(\n            paymentAggregatorUsers.contains(_user),\n            \"Can't remove non-existing user\"\n        );\n        return paymentAggregatorUsers.remove(_user);\n    }\n\n    /**\n     * @dev Trigers to check if provided `addr` is a payment aggregator user from address set\n     * @param _user Contract address to check if it's a payment aggregator user\n     *\n     */\n    function isPaymentAggregatorUser(address _user)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return paymentAggregatorUsers.contains(_user);\n    }\n\n    /**\n     * @dev Trigers to set close out netting smart contract\n     * @param _contract CloseOutNetting smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function setCloseOutNetting(address _contract)\n        public\n        onlyOwner\n        onlyContractAddr(_contract)\n    {\n        emit UpdateCloseOutNetting(address(closeOutNetting), _contract);\n        closeOutNetting = ICloseOutNetting(_contract);\n    }\n\n    /**\n     * @dev Trigers to set mark to market smart contract\n     * @param _contract MarkToMarket smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function setMarkToMarket(address _contract)\n        public\n        onlyOwner\n        onlyContractAddr(_contract)\n    {\n        emit UpdateMarkToMarket(address(markToMarket), _contract);\n        markToMarket = IMarkToMarket(_contract);\n    }\n\n    function setSettlementEngine(address _contract)\n        public\n        onlyOwner\n        onlyContractAddr(_contract)\n    {\n        emit UpdateSettlementEngine(address(settlementEngine), _contract);\n        settlementEngine = ISettlementEngine(_contract);\n    }\n\n    struct TimeSlotPaymentsLocalVars {\n        bytes32 packedAddrs;\n        bool flipped;\n        uint256 totalPayment0;\n        uint256 totalPayment1;\n        bytes32 slotPosition;\n        uint256 year;\n        uint256 month;\n        uint256 day;\n    }\n\n    /**\n     * @dev Triggered to add new payments for a deal\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main settlement currency in a deal\n     * @param dealId Deal unique ID with prefix\n     * @param timestamps Array of timestamps for timeslot identification\n     * @param payments0 Array of cashflows owed by the first party\n     * @param payments1 Array of cashflows owed by the second party\n     */\n    function registerPayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] memory timestamps,\n        uint256[] memory payments0,\n        uint256[] memory payments1\n    ) external override acceptedContract {\n        TimeSlotPaymentsLocalVars memory vars;\n        (vars.packedAddrs, ) = AddressPacking.pack(party0, party1);\n\n        for (uint256 i = 0; i < timestamps.length; i++) {\n            if (timestamps[i] == 0) continue;\n\n            (vars.year, vars.month, vars.day) = BokkyPooBahsDateTimeLibrary\n                .timestampToDate(timestamps[i]);\n            vars.slotPosition = TimeSlot.position(\n                vars.year,\n                vars.month,\n                vars.day\n            );\n            deals[vars.packedAddrs][ccy][vars.slotPosition].add(dealId);\n\n            if (payments0[i] > 0) {\n                vars.totalPayment0 = vars.totalPayment0.add(payments0[i]);\n            }\n\n            if (payments1[i] > 0) {\n                vars.totalPayment1 = vars.totalPayment1.add(payments1[i]);\n            }\n\n            TimeSlot.addPayment(\n                _timeSlots,\n                party0,\n                party1,\n                ccy,\n                vars.slotPosition,\n                payments0[i],\n                payments1[i]\n            );\n\n            emit RegisterPayment(\n                party0,\n                party1,\n                ccy,\n                vars.slotPosition,\n                vars.year,\n                vars.month,\n                vars.day,\n                payments0[i],\n                payments1[i]\n            );\n        }\n\n        closeOutNetting.addPayments(\n            party0,\n            party1,\n            ccy,\n            vars.totalPayment0,\n            vars.totalPayment1\n        );\n    }\n\n    struct PaymentSettlementLocalVars {\n        bytes32 slotPosition;\n        uint256 payment;\n        address verifier;\n        address counterparty;\n        bytes32 ccy;\n        bytes32 settlementId;\n        uint256 year;\n        uint256 month;\n        uint256 day;\n        uint256 totalPayment0;\n        uint256 totalPayment1;\n        bool isSettled;\n    }\n\n    /**\n     * @dev External function to verify payment by msg.sender, uses timestamp to identify TimeSlot.\n     * @param verifier Payment verifier address\n     * @param counterparty Counterparty address\n     * @param ccy Main payment settlement currency\n     * @param timestamp Main timestamp for TimeSlot\n     * @param payment Main payment settlement currency\n     * @param settlementId Main payment settlement id\n     */\n    function verifyPayment(\n        address verifier,\n        address counterparty,\n        bytes32 ccy,\n        uint256 timestamp,\n        uint256 payment,\n        bytes32 settlementId\n    ) external override {\n        require(_onlySettlementEngine(), \"NOT_SETTLEMENT_ENGINE\");\n        require(checkSettlementWindow(timestamp), \"OUT_OF_SETTLEMENT_WINDOW\");\n        PaymentSettlementLocalVars memory vars;\n\n        vars.payment = payment;\n        vars.settlementId = settlementId;\n        vars.verifier = verifier;\n        vars.counterparty = counterparty;\n        vars.ccy = ccy;\n\n        (vars.year, vars.month, vars.day) = BokkyPooBahsDateTimeLibrary\n            .timestampToDate(timestamp);\n        vars.slotPosition = TimeSlot.position(vars.year, vars.month, vars.day);\n\n        TimeSlot.verifyPayment(\n            _timeSlots,\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.slotPosition,\n            vars.payment,\n            vars.settlementId\n        );\n\n        emit VerifyPayment(\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.slotPosition,\n            vars.year,\n            vars.month,\n            vars.day,\n            vars.payment,\n            vars.settlementId\n        );\n\n        vars.isSettled = TimeSlot.isSettled(\n            _timeSlots,\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.slotPosition\n        );\n\n        if (vars.isSettled) {\n            _settlePayment(vars);\n        }\n    }\n\n    /**\n     * @dev Internal function to settle payment using payment settlement local variables.\n     * @param vars Local variables used in verifyPayment function\n     */\n    function _settlePayment(PaymentSettlementLocalVars memory vars) internal {\n        // TODO: Rework the settlement workflow to reduce gas consumption\n        (vars.totalPayment0, vars.totalPayment1, , , , ) = TimeSlot.get(\n            _timeSlots,\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.year,\n            vars.month,\n            vars.day\n        );\n\n        bytes32[] memory dealIds = getDealsFromSlot(\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.slotPosition\n        );\n        markToMarket.updatePVs(dealIds);\n\n        closeOutNetting.removePayments(\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.totalPayment0,\n            vars.totalPayment1\n        );\n\n        emit SettlePayment(\n            vars.verifier,\n            vars.counterparty,\n            vars.ccy,\n            vars.slotPosition,\n            vars.year,\n            vars.month,\n            vars.day,\n            vars.settlementId\n        );\n    }\n\n    /**\n     * @dev Triggered to remove existing payments for a deal\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main settlement currency in a deal\n     * @param dealId Deal unique ID with prefix\n     * @param timestamps Array of timestamps for timeslot identification\n     * @param payments0 Array of cashflows owed by the first party\n     * @param payments1 Array of cashflows owed by the second party\n     */\n    function removePayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] calldata timestamps,\n        uint256[] calldata payments0,\n        uint256[] calldata payments1\n    ) external override acceptedContract {\n        TimeSlotPaymentsLocalVars memory vars;\n        (vars.packedAddrs, ) = AddressPacking.pack(party0, party1);\n\n        for (uint256 i = 0; i < timestamps.length; i++) {\n            if (timestamps[i] == 0) continue;\n\n            (vars.year, vars.month, vars.day) = BokkyPooBahsDateTimeLibrary\n                .timestampToDate(timestamps[i]);\n            vars.slotPosition = TimeSlot.position(\n                vars.year,\n                vars.month,\n                vars.day\n            );\n\n            require(\n                deals[vars.packedAddrs][ccy][vars.slotPosition].remove(dealId),\n                \"NON_REGISTERED_DEAL\"\n            );\n\n            vars.totalPayment0 = vars.totalPayment0.add(payments0[i]);\n            vars.totalPayment1 = vars.totalPayment1.add(payments1[i]);\n\n            TimeSlot.removePayment(\n                _timeSlots,\n                party0,\n                party1,\n                ccy,\n                vars.slotPosition,\n                payments0[i],\n                payments1[i]\n            );\n\n            emit RemovePayment(\n                party0,\n                party1,\n                ccy,\n                vars.slotPosition,\n                vars.year,\n                vars.month,\n                vars.day,\n                payments0[i],\n                payments1[i]\n            );\n        }\n\n        closeOutNetting.removePayments(\n            party0,\n            party1,\n            ccy,\n            vars.totalPayment0,\n            vars.totalPayment1\n        );\n    }\n\n    /**\n     * @dev Returns the time slot between parties using slot id.\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     */\n    function getTimeSlotByDate(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 year,\n        uint256 month,\n        uint256 day\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        )\n    {\n        return TimeSlot.get(_timeSlots, party0, party1, ccy, year, month, day);\n    }\n\n    /**\n     * @dev Returns the time slot between parties using slot id.\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     * @param slot TimeSlot position\n     */\n    function getTimeSlotBySlotId(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot\n    )\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool,\n            bool\n        )\n    {\n        return TimeSlot.getBySlotId(_timeSlots, party0, party1, ccy, slot);\n    }\n\n    /**\n     * @dev Returns the time slot between parties using slot id.\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     * @param year Calendar year of the settlement\n     * @param month Calendar month of the settlement\n     * @param day Calendar day of the settlement\n     * @param settlementId Settlement payment confirmation identifier\n     */\n    function getTimeSlotPaymentConfirmation(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        bytes32 settlementId\n    ) public view returns (address, uint256) {\n        return\n            TimeSlot.getPaymentConfirmation(\n                _timeSlots,\n                party0,\n                party1,\n                ccy,\n                year,\n                month,\n                day,\n                settlementId\n            );\n    }\n\n    /**\n     * @dev Returns the time slot between parties using slot id.\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     * @param slot TimeSlot position\n     * @param settlementId Settlement payment confirmation identifier\n     */\n    function getTimeSlotPaymentConfirmationById(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slot,\n        bytes32 settlementId\n    ) public view returns (address, uint256) {\n        return\n            TimeSlot.getPaymentConfirmationById(\n                _timeSlots,\n                party0,\n                party1,\n                ccy,\n                slot,\n                settlementId\n            );\n    }\n\n    /**\n     * @dev Internal function to get TimeSlot position after adding days\n     * @param timestamp Timestamp to add days\n     * @param numSeconds number of seconds to add\n     * @return Updated timestamp and TimeSlot position\n     */\n    function _slotPositionPlusDays(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (bytes32, uint256)\n    {\n        uint256 numDays = numSeconds.div(86400);\n        timestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, numDays);\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary\n            .timestampToDate(timestamp);\n        bytes32 slotPosition = TimeSlot.position(year, month, day);\n\n        return (slotPosition, timestamp);\n    }\n\n    /**\n     * @dev Internal function to get TimeSlot position\n     * @param timestamp Timestamp for conversion\n     * @return TimeSlot position\n     */\n    function _slotPosition(uint256 timestamp) internal pure returns (bytes32) {\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary\n            .timestampToDate(timestamp);\n        bytes32 slotPosition = TimeSlot.position(year, month, day);\n\n        return slotPosition;\n    }\n\n    /**\n     * @dev Triggers settlement status of the time slot\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Main payment settlement currency\n     * @param timestamp TimeSlot timestamp\n     * @return status Boolean if slot was settled\n     */\n    function isSettled(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 timestamp\n    ) external view override returns (bool status) {\n        (uint256 year, uint256 month, uint256 day) = BokkyPooBahsDateTimeLibrary\n            .timestampToDate(timestamp);\n        bytes32 slotPosition = TimeSlot.position(year, month, day);\n\n        status = TimeSlot.isSettled(\n            _timeSlots,\n            party0,\n            party1,\n            ccy,\n            slotPosition\n        );\n    }\n\n    /**\n     * @dev Internal function to check if settlement payment is within available timeline\n     * @param targetTime target time for settlement of time slot\n     * @return Boolean if slot within the settlement window\n     */\n    function checkSettlementWindow(uint256 targetTime)\n        public\n        view\n        override\n        returns (bool)\n    {\n        uint256 time = block.timestamp;\n        uint256 delta = BokkyPooBahsDateTimeLibrary.diffDays(time, targetTime);\n\n        return !(delta > settlementWindow);\n    }\n\n    function getDealsFromSlot(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 slotPosition\n    ) public view override returns (bytes32[] memory) {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        EnumerableSet.Bytes32Set storage set = deals[packedAddrs][ccy][\n            slotPosition\n        ];\n\n        uint256 numDeals = set.length();\n        bytes32[] memory dealIds = new bytes32[](numDeals);\n\n        for (uint256 i = 0; i < numDeals; i++) {\n            bytes32 deal = set.at(i);\n            dealIds[i] = deal;\n        }\n\n        return dealIds;\n    }\n\n    function _onlySettlementEngine() internal view returns (bool) {\n        return msg.sender == address(settlementEngine);\n    }\n}\n"
    },
    "contracts/interfaces/ICloseOutNetting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\ninterface ICloseOutNetting {\n    event AddCloseOutPayments(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    );\n    event RemoveCloseOutPayments(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    );\n    event SettleCloseOut(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 netPayment,\n        bytes32 txHash\n    );\n    event UpdateCollateralAggregator(\n        address indexed prevAddr,\n        address indexed addr\n    );\n    event UpdatePaymentAggregator(\n        address indexed prevAddr,\n        address indexed addr\n    );\n    event VerifyCloseOut(\n        address indexed party0,\n        address indexed party1,\n        bytes32 ccy,\n        uint256 netPayment,\n        bytes32 txHash\n    );\n\n    function addPayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) external;\n\n    function checkDefault(address _party) external view returns (bool);\n\n    function owner() external view returns (address);\n\n    function removePayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 payment0,\n        uint256 payment1\n    ) external;\n\n    function updateCollateralAggregator(address addr) external;\n\n    function updatePaymentAggregator(address addr) external;\n}\n"
    },
    "contracts/mocks/WETH9Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../interfaces/IWETH9.sol\";\n\ncontract WETH9Mock is IWETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable override {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public override {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public override returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public override returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public override returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/CollateralVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./interfaces/ICollateralAggregatorV2.sol\";\nimport \"./interfaces/ICurrencyController.sol\";\nimport \"./interfaces/ICollateralVault.sol\";\nimport \"./libraries/SafeTransfer.sol\";\nimport \"./libraries/CollateralPosition.sol\";\n\n/**\n * @title CollateralVault is the main implementation contract for storing and keeping user's collateral\n *\n * This contract allows users to deposit and withdraw their funds to fulfill\n * their collateral obligations against different trades.\n *\n * CollateralVault is working with ETH or ERC20 token with specified on deployment `tokenAddress`.\n *\n * CollateralAggregator uses independent Collateral vaults for rebalancing collateral\n * between global books and bilateral positions, and liquidating collateral while performing\n * single or multi-deal liquidation.\n *\n */\ncontract CollateralVault is ICollateralVault, SafeTransfer {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using CollateralPosition for CollateralPosition.Position;\n\n    struct Book {\n        uint256 independentAmount;\n        uint256 lockedCollateral;\n    }\n\n    // Linked contract addresses\n    ICollateralAggregator public collateralAggregator;\n    ICurrencyController public currencyController;\n\n    address public override owner;\n    address public override tokenAddress;\n    bytes32 public override ccy;\n\n    // Mapping for all deposits of users collateral\n    mapping(address => Book) private books;\n\n    // Mapping for bilateral collateral positions between 2 counterparties.\n    mapping(bytes32 => CollateralPosition.Position) private _positions;\n\n    /**\n     * @dev Modifier to check if user registered on collateral aggregator\n     */\n    modifier registeredUserOnly() {\n        require(\n            collateralAggregator.checkRegisteredUser(msg.sender),\n            \"NON_REGISTERED_USER\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if msg.sender is a collateral aggregator contract\n     */\n    modifier aggregatorOnly() {\n        require(msg.sender == address(collateralAggregator), \"INVALID_ACCEESS\");\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     *\n     * @notice sets contract deployer as owner of this contract and links\n     * with collateral aggregator and currency controller contracts\n     */\n    constructor(\n        bytes32 _ccy,\n        address _tokenAddress,\n        address _collateralAggregator,\n        address _currencyController,\n        address _WETH9\n    ) public SafeTransfer(_WETH9) {\n        owner = msg.sender;\n        tokenAddress = _tokenAddress;\n        ccy = _ccy;\n\n        collateralAggregator = ICollateralAggregator(_collateralAggregator);\n        currencyController = ICurrencyController(_currencyController);\n\n        require(\n            currencyController.isCollateral(_ccy),\n            \"COLLATERAL_ASSET_NOT_SUPPORTED\"\n        );\n    }\n\n    /**\n     * @dev Trigers to deposit funds by the msg.sender into collateral book\n     * @param _amount Number of funds to deposit\n     */\n    function deposit(uint256 _amount)\n        public\n        payable\n        override\n        registeredUserOnly\n    {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        _depositAssets(tokenAddress, msg.sender, address(this), _amount);\n\n        Book storage book = books[msg.sender];\n        book.independentAmount = book.independentAmount.add(_amount);\n\n        _afterTransfer();\n\n        emit Deposit(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Deposit collateral funds into bilateral position against counterparty\n     * @param _counterparty Counterparty address in bilateral position\n     * @notice payable function increases locked collateral by msg.value\n     */\n    function deposit(address _counterparty, uint256 _amount)\n        public\n        override\n        registeredUserOnly\n    {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        _depositAssets(tokenAddress, msg.sender, address(this), _amount);\n\n        CollateralPosition.deposit(\n            _positions,\n            msg.sender,\n            _counterparty,\n            _amount\n        );\n\n        Book storage book = books[msg.sender];\n        book.lockedCollateral = book.lockedCollateral.add(_amount);\n\n        _afterTransfer(_counterparty);\n\n        emit PositionDeposit(msg.sender, _counterparty, _amount);\n    }\n\n    struct RebalanceLocalVars {\n        int256 exchangeRate;\n        uint256 target;\n        uint256 rebalanceAmount;\n        uint256 left;\n    }\n\n    /**\n     * @dev Rebalances collateral from user's book to bilateral position,\n     * as it's executed by collateral aggregator function returns the\n     * amount of ETH left to rebalance for other collateral vaults\n     *\n     * @param _user Main user address to rebalance collateral from\n     * @param _counterparty Counterparty address in bilateral position\n     * @param _amountETH Amount of funds in ETH required to rebalance\n     *\n     * @return Amount of funds in ETH left to rebalance for other vault\n     */\n    function rebalanceTo(\n        address _user,\n        address _counterparty,\n        uint256 _amountETH\n    ) external override aggregatorOnly returns (uint256) {\n        RebalanceLocalVars memory vars;\n        vars.exchangeRate = currencyController.getLastETHPrice(ccy);\n        vars.target = _amountETH.mul(1e18).div(uint256(vars.exchangeRate));\n\n        Book storage book = books[_user];\n        vars.rebalanceAmount = book.independentAmount >= vars.target\n            ? vars.target\n            : book.independentAmount;\n\n        if (vars.rebalanceAmount > 0) {\n            book.independentAmount = book.independentAmount.sub(\n                vars.rebalanceAmount\n            );\n            book.lockedCollateral = book.lockedCollateral.add(\n                vars.rebalanceAmount\n            );\n\n            CollateralPosition.deposit(\n                _positions,\n                _user,\n                _counterparty,\n                vars.rebalanceAmount\n            );\n            _afterTransfer(_user, _counterparty);\n\n            emit RebalanceTo(_user, _counterparty, vars.rebalanceAmount);\n        }\n\n        vars.left = vars.target.sub(vars.rebalanceAmount);\n\n        return vars.left.mul(uint256(vars.exchangeRate)).div(1e18);\n    }\n\n    /**\n     * @dev Rebalances collateral from bilateral position to user's book,\n     * as it's executed by collateral aggregator function returns the\n     * amount of ETH left to rebalance for other collateral vaults\n     *\n     * @param _user Main user address to rebalance collateral from\n     * @param _counterparty Counterparty address in bilateral position\n     * @param _amountETH Amount of funds in ETH required to rebalance\n     *\n     * @return Amount of funds in ETH left to rebalance for other vault\n     */\n    function rebalanceFrom(\n        address _user,\n        address _counterparty,\n        uint256 _amountETH\n    ) external override aggregatorOnly returns (uint256) {\n        RebalanceLocalVars memory vars;\n\n        vars.exchangeRate = currencyController.getLastETHPrice(ccy);\n        vars.target = _amountETH.mul(1e18).div(uint256(vars.exchangeRate));\n        vars.rebalanceAmount = CollateralPosition.withdraw(\n            _positions,\n            _user,\n            _counterparty,\n            vars.target\n        );\n\n        if (vars.rebalanceAmount > 0) {\n            Book storage book = books[_user];\n            book.lockedCollateral = book.lockedCollateral.sub(\n                vars.rebalanceAmount\n            );\n            book.independentAmount = book.independentAmount.add(\n                vars.rebalanceAmount\n            );\n\n            _afterTransfer(_user, _counterparty);\n\n            emit RebalanceFrom(_user, _counterparty, vars.rebalanceAmount);\n        }\n\n        vars.left = vars.target.sub(vars.rebalanceAmount);\n\n        return vars.left.mul(uint256(vars.exchangeRate)).div(1e18);\n    }\n\n    /**\n     * @dev Rebalances collateral between 2 different bilateral positions,\n     * as it's executed by collateral aggregator function returns the\n     * amount of ETH left to rebalance for other collateral vaults\n     *\n     * @param _user Main user address to rebalance collateral from\n     * @param _fromParty Counterparty address to rebalance from\n     * @param _toParty Counterparty address to rebalance to\n     * @param _amountETH Amount of funds in ETH required to rebalance\n     *\n     * @return Amount of funds in ETH left to rebalance for other vault\n     */\n    function rebalanceBetween(\n        address _user,\n        address _fromParty,\n        address _toParty,\n        uint256 _amountETH\n    ) external override aggregatorOnly returns (uint256) {\n        RebalanceLocalVars memory vars;\n\n        vars.exchangeRate = currencyController.getLastETHPrice(ccy);\n        vars.target = _amountETH.mul(1e18).div(uint256(vars.exchangeRate));\n        vars.rebalanceAmount = CollateralPosition.rebalance(\n            _positions,\n            _user,\n            _fromParty,\n            _toParty,\n            vars.target\n        );\n        vars.left = vars.target.sub(vars.rebalanceAmount);\n\n        _afterTransfer(_user, _fromParty);\n        _afterTransfer(_user, _toParty);\n\n        emit RebalanceBetween(\n            _user,\n            _fromParty,\n            _toParty,\n            vars.rebalanceAmount\n        );\n\n        return vars.left.mul(uint256(vars.exchangeRate)).div(1e18);\n    }\n\n    /**\n     * @dev Liquidates collateral from bilateral position between parties\n     * returns the amount of ETH to be liquidated in other vault\n     * if all available funds have been liquidated here\n     *\n     * @param _from Address for liquidating collateral from\n     * @param _to Address for sending collateral to\n     * @param _amountETH Liquidation amount in ETH\n     *\n     * @notice Trigers only be Loan contract\n     */\n    function liquidate(\n        address _from,\n        address _to,\n        uint256 _amountETH\n    ) external override aggregatorOnly returns (uint256 liquidationLeftETH) {\n        int256 exchangeRate = currencyController.getLastETHPrice(ccy);\n        uint256 liquidationTarget = _amountETH.mul(1e18).div(\n            uint256(exchangeRate)\n        );\n        uint256 liquidated = CollateralPosition.liquidate(\n            _positions,\n            _from,\n            _to,\n            liquidationTarget\n        );\n\n        Book storage book = books[_from];\n        book.lockedCollateral = book.lockedCollateral.sub(liquidated);\n\n        book = books[_to];\n        book.lockedCollateral = book.lockedCollateral.add(liquidated);\n\n        if (liquidated > 0) {\n            _afterTransfer(_from, _to);\n            emit Liquidate(_from, _to, liquidated);\n        }\n\n        uint256 liquidationLeft = liquidationTarget.sub(liquidated);\n\n        if (liquidationLeft > 0) {\n            uint256 independentLiquidation = _tryLiquidateIndependentCollateral(\n                _from,\n                _to,\n                liquidationLeft\n            );\n            liquidationLeft = liquidationLeft.sub(independentLiquidation);\n        }\n\n        liquidationLeftETH = liquidationLeft.mul(uint256(exchangeRate)).div(\n            1e18\n        );\n    }\n\n    function _tryLiquidateIndependentCollateral(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal returns (uint256 liquidated) {\n        uint256 maxWidthdrawETH = collateralAggregator\n            .getMaxCollateralBookWidthdraw(_from);\n        uint256 maxLiquidation = currencyController.convertFromETH(\n            ccy,\n            maxWidthdrawETH\n        );\n\n        liquidated = _amount > maxLiquidation ? maxLiquidation : _amount;\n\n        Book storage book = books[_from];\n        book.independentAmount = book.independentAmount.sub(liquidated);\n\n        book = books[_to];\n        book.lockedCollateral = book.lockedCollateral.add(liquidated);\n\n        CollateralPosition.deposit(_positions, _to, _from, liquidated);\n\n        emit LiquidateIndependent(_from, _to, liquidated);\n    }\n\n    /**\n     * @notice Trigers to withdraw funds by the msg.sender from non-locked funds\n     * @param _amount Number of funds to withdraw.\n     */\n    function withdraw(uint256 _amount) public override registeredUserOnly {\n        // fix according to collateral aggregator\n        require(_amount > 0, \"INVALID_AMOUNT\");\n\n        address user = msg.sender;\n        uint256 maxWidthdrawETH = collateralAggregator\n            .getMaxCollateralBookWidthdraw(user);\n        uint256 maxWidthdraw = currencyController.convertFromETH(\n            ccy,\n            maxWidthdrawETH\n        );\n        uint256 withdrawAmt = _amount > maxWidthdraw ? maxWidthdraw : _amount;\n\n        Book storage book = books[user];\n        book.independentAmount = book.independentAmount.sub(withdrawAmt);\n\n        _withdrawAssets(tokenAddress, msg.sender, withdrawAmt);\n        _afterTransfer();\n\n        emit Withdraw(msg.sender, withdrawAmt);\n    }\n\n    /**\n     * @notice Trigers to withdraw funds from bilateral position between\n     * msg.sender and _counterparty\n     *\n     * @param _counterparty Counterparty address.\n     * @param _amount Number of funds to withdraw.\n     */\n    function withdrawFrom(address _counterparty, uint256 _amount)\n        public\n        override\n        registeredUserOnly\n    {\n        require(_amount > 0, \"INVALID_AMOUNT\");\n        address user = msg.sender;\n\n        (uint256 maxWidthdrawETH, ) = collateralAggregator\n            .getMaxCollateralWidthdraw(user, _counterparty);\n        uint256 maxWidthdraw = currencyController.convertFromETH(\n            ccy,\n            maxWidthdrawETH\n        );\n\n        uint256 targetWithdraw = _amount > maxWidthdraw\n            ? maxWidthdraw\n            : _amount;\n        uint256 withdrawn = CollateralPosition.withdraw(\n            _positions,\n            user,\n            _counterparty,\n            targetWithdraw\n        );\n\n        Book storage book = books[user];\n        book.lockedCollateral = book.lockedCollateral.sub(withdrawn);\n\n        _withdrawAssets(tokenAddress, msg.sender, withdrawn);\n        _afterTransfer(_counterparty);\n\n        emit PositionWithdraw(user, _counterparty, withdrawn);\n    }\n\n    /**\n     * @notice Returns independent collateral from `_user` collateral book\n     *\n     * @param _user Address of collateral user\n     */\n    function getIndependentCollateral(address _user)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return books[_user].independentAmount;\n    }\n\n    /**\n     * @notice Returns independent collateral from `_user` collateral book converted to ETH\n     *\n     * @param _user Address of collateral user\n     */\n    function getIndependentCollateralInETH(address _user)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 amount = books[_user].independentAmount;\n\n        return currencyController.convertToETH(ccy, amount);\n    }\n\n    /**\n     * @notice Returns locked collateral by `_user` in collateral book\n     *\n     * @param _user Address of collateral user\n     */\n    function getLockedCollateral(address _user)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return books[_user].lockedCollateral;\n    }\n\n    /**\n     * @notice Returns locked collateral by `_user` in collateral book converted to ETH\n     *\n     * @param _user Address of collateral user\n     */\n    function getLockedCollateralInETH(address _user)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        uint256 amount = books[_user].lockedCollateral;\n\n        return currencyController.convertToETH(ccy, amount);\n    }\n\n    /**\n     * @notice Returns locked collateral by counterparties\n     * in a bilateral position in native `ccy`\n     *\n     * @param _partyA First counterparty address\n     * @param _partyB Second counterparty address.\n     */\n    function getLockedCollateral(address _partyA, address _partyB)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        return CollateralPosition.get(_positions, _partyA, _partyB);\n    }\n\n    /**\n     * @notice Returns locked collateral by counterparties\n     * in a bilateral position converted to ETH\n     *\n     * @param _partyA First counterparty address\n     * @param _partyB Second counterparty address.\n     */\n    function getLockedCollateralInETH(address _partyA, address _partyB)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        (uint256 lockedA, uint256 lockedB) = CollateralPosition.get(\n            _positions,\n            _partyA,\n            _partyB\n        );\n\n        uint256[] memory ethAmounts = new uint256[](2);\n        ethAmounts[0] = lockedA;\n        ethAmounts[1] = lockedB;\n\n        ethAmounts = currencyController.convertBulkToETH(ccy, ethAmounts);\n\n        return (ethAmounts[0], ethAmounts[1]);\n    }\n\n    function _afterTransfer() internal {\n        if (\n            books[msg.sender].independentAmount > 0 ||\n            books[msg.sender].lockedCollateral > 0\n        ) {\n            collateralAggregator.enterVault(msg.sender);\n        } else {\n            collateralAggregator.exitVault(msg.sender);\n        }\n    }\n\n    function _afterTransfer(address _counterparty) internal {\n        _afterTransfer(msg.sender, _counterparty);\n    }\n\n    function _afterTransfer(address _user, address _counterparty) internal {\n        (uint256 locked0, uint256 locked1) = CollateralPosition.get(\n            _positions,\n            _user,\n            _counterparty\n        );\n\n        if (locked0 > 0) {\n            collateralAggregator.enterVault(_user);\n        }\n\n        if (locked1 > 0) {\n            collateralAggregator.enterVault(_counterparty);\n        }\n\n        if (locked0 > 0 || locked1 > 0) {\n            collateralAggregator.enterVault(_user, _counterparty);\n        } else {\n            collateralAggregator.exitVault(_user, _counterparty);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/ICollateralVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface ICollateralVault {\n    event Deposit(address user, uint256 amount);\n    event PositionDeposit(address user, address counterparty, uint256 amount);\n    event RebalanceBetween(\n        address user,\n        address fromCounterparty,\n        address toCounterparty,\n        uint256 amount\n    );\n    event RebalanceFrom(address user, address counterparty, uint256 amount);\n    event RebalanceTo(address user, address counterparty, uint256 amount);\n    event Withdraw(address from, uint256 amount);\n    event PositionWithdraw(address from, address counterparty, uint256 amount);\n    event Liquidate(address from, address to, uint256 amount);\n    event LiquidateIndependent(address from, address to, uint256 amount);\n\n    function ccy() external view returns (bytes32);\n\n    function tokenAddress() external view returns (address);\n\n    function deposit(address _counterparty, uint256 _amount) external;\n\n    function deposit(uint256 _amount) external payable;\n\n    function getIndependentCollateral(address _user)\n        external\n        view\n        returns (uint256);\n\n    function getIndependentCollateralInETH(address _user)\n        external\n        view\n        returns (uint256);\n\n    function getLockedCollateral(address _partyA, address _partyB)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getLockedCollateral(address _user) external view returns (uint256);\n\n    function getLockedCollateralInETH(address _partyA, address _partyB)\n        external\n        view\n        returns (uint256, uint256);\n\n    function getLockedCollateralInETH(address _user)\n        external\n        view\n        returns (uint256);\n\n    function liquidate(\n        address _from,\n        address _to,\n        uint256 _amountETH\n    ) external returns (uint256 liquidationLeftETH);\n\n    function owner() external view returns (address);\n\n    function rebalanceBetween(\n        address _user,\n        address _fromParty,\n        address _toParty,\n        uint256 _amountETH\n    ) external returns (uint256);\n\n    function rebalanceFrom(\n        address _user,\n        address _counterparty,\n        uint256 _amountETH\n    ) external returns (uint256);\n\n    function rebalanceTo(\n        address _user,\n        address _counterparty,\n        uint256 _amountETH\n    ) external returns (uint256);\n\n    function withdraw(uint256 _amount) external;\n\n    function withdrawFrom(address _counterparty, uint256 _amount) external;\n}\n"
    },
    "contracts/libraries/CollateralPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./AddressPacking.sol\";\n\nlibrary CollateralPosition {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Position structure used for keeping track of collateral\n     * amounts locked by counterparties in bilateral relations\n     */\n    struct Position {\n        uint256 lockedCollateralA;\n        uint256 lockedCollateralB;\n    }\n\n    function _handleFlippedCase(\n        CollateralPosition.Position memory position,\n        bool flipped\n    ) internal pure returns (CollateralPosition.Position memory) {\n        if (flipped) {\n            uint256 locked = position.lockedCollateralA;\n\n            position.lockedCollateralA = position.lockedCollateralB;\n            position.lockedCollateralB = locked;\n        }\n\n        return position;\n    }\n\n    /**\n     * @dev Returns the bilateral collateral position between 2 counterparties\n     * @param self The mapping with all bilateral collateral positions\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     */\n    function get(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address party0,\n        address party1\n    ) internal view returns (uint256, uint256) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            party0,\n            party1\n        );\n        CollateralPosition.Position memory position = self[packedAddrs];\n        position = _handleFlippedCase(position, flipped);\n\n        return (position.lockedCollateralA, position.lockedCollateralB);\n    }\n\n    /**\n     * @dev Adds deposited amount into bilateral position from one party\n     * @param self The mapping with all bilateral collateral positions\n     * @param depositor Address of user depositing funds\n     * @param counterparty Counterparty address\n     * @param amount Number of funds deposited by user\n     */\n    function deposit(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address depositor,\n        address counterparty,\n        uint256 amount\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            depositor,\n            counterparty\n        );\n        CollateralPosition.Position storage position = self[packedAddrs];\n\n        if (!flipped) {\n            position.lockedCollateralA = position.lockedCollateralA.add(amount);\n        } else {\n            position.lockedCollateralB = position.lockedCollateralB.add(amount);\n        }\n    }\n\n    // /**\n    // * @dev Adds deposited amounts into bilateral position,\n    // * helpful during rebalancing from books of both parties\n    // * @param self The mapping with all bilateral collateral positions\n    // * @param party0 First counterparty address\n    // * @param party1 Second counterparty address\n    // * @param amount0 Number of funds deposited by first counterparty\n    // * @param amount1 Number of funds deposited by second counterparty\n    // */\n    // function deposit(\n    //     mapping(bytes32 => CollateralPosition.Position) storage self,\n    //     address party0,\n    //     address party1,\n    //     uint256 amount0,\n    //     uint256 amount1\n    // ) internal {\n    //     (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n    //     CollateralPosition.Position storage position = self[packedAddrs];\n\n    //     position.lockedCollateralA = flipped ? position.lockedCollateralA.add(amount1) : position.lockedCollateralA.add(amount0);\n    //     position.lockedCollateralB = flipped ? position.lockedCollateralB.add(amount0) : position.lockedCollateralB.add(amount1);\n    // }\n\n    /**\n     * @dev Removes withdrawn amounts from bilateral position for one party\n     * @param self The mapping with all bilateral collateral positions\n     * @param user Address of user withdrawing funds\n     * @param counterparty Counterparty address\n     * @param amount Number of funds withdrawn by user\n     * @notice Returns the number of funds withdrawn by user\n     */\n    function withdraw(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address user,\n        address counterparty,\n        uint256 amount\n    ) internal returns (uint256 maxWithdraw) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            user,\n            counterparty\n        );\n        CollateralPosition.Position storage position = self[packedAddrs];\n\n        if (!flipped) {\n            maxWithdraw = position.lockedCollateralA >= amount\n                ? amount\n                : position.lockedCollateralA;\n            position.lockedCollateralA = position.lockedCollateralA.sub(\n                maxWithdraw\n            );\n        } else {\n            maxWithdraw = position.lockedCollateralB >= amount\n                ? amount\n                : position.lockedCollateralB;\n            position.lockedCollateralB = position.lockedCollateralB.sub(\n                maxWithdraw\n            );\n        }\n    }\n\n    // /**\n    // * @dev Removes withdrawn amounts from bilateral position for both parties\n    // * @param self The mapping with all bilateral collateral positions\n    // * @param party0 First counterparty address\n    // * @param party1 Second counterparty address\n    // * @param amount0 Number of funds withdrawn by first counterparty\n    // * @param amount1 Number of funds withdrawn by second counterparty\n    // */\n    // function withdraw(\n    //     mapping(bytes32 => CollateralPosition.Position) storage self,\n    //     address party0,\n    //     address party1,\n    //     uint256 amount0,\n    //     uint256 amount1\n    // ) internal {\n    //     (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(party0, party1);\n    //     CollateralPosition.Position storage position = self[packedAddrs];\n\n    //     position.lockedCollateralA = flipped ? position.lockedCollateralA.sub(amount1) : position.lockedCollateralA.sub(amount0);\n    //     position.lockedCollateralB = flipped ? position.lockedCollateralB.sub(amount0) : position.lockedCollateralB.sub(amount1);\n    // }\n\n    /**\n     * @dev Liquidates required amount from one party to another inside position\n     * @param self The mapping with all bilateral collateral positions\n     * @param from Address for liquidating collateral from\n     * @param to Address for sending collateral to\n     * @param amount Number of funds to liquidate\n     */\n    function liquidate(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (uint256 liquidated) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(from, to);\n        CollateralPosition.Position storage position = self[packedAddrs];\n\n        if (!flipped) {\n            liquidated = position.lockedCollateralA >= amount\n                ? amount\n                : position.lockedCollateralA;\n            position.lockedCollateralA = position.lockedCollateralA.sub(\n                liquidated\n            );\n            position.lockedCollateralB = position.lockedCollateralB.add(\n                liquidated\n            );\n        } else {\n            liquidated = position.lockedCollateralB >= amount\n                ? amount\n                : position.lockedCollateralB;\n            position.lockedCollateralB = position.lockedCollateralB.sub(\n                liquidated\n            );\n            position.lockedCollateralA = position.lockedCollateralA.add(\n                liquidated\n            );\n        }\n    }\n\n    /**\n     * @dev Rebalances required amount between 2 bilateral positions\n     * @param self The mapping with all bilateral collateral positions\n     * @param user Address of main party to rebalance funds between counterparties for\n     * @param fromParty Counterparty address for rebalancing collateral from\n     * @param toParty Counterparty address for rebalancing collateral to\n     * @param amount Number of funds to rebalance\n     */\n    function rebalance(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address user,\n        address fromParty,\n        address toParty,\n        uint256 amount\n    ) internal returns (uint256 rebalanced) {\n        // max checks\n        (bytes32 packedAddr, bool flipped) = AddressPacking.pack(\n            user,\n            fromParty\n        );\n        CollateralPosition.Position storage position = self[packedAddr];\n\n        if (!flipped) {\n            rebalanced = position.lockedCollateralA >= amount\n                ? amount\n                : position.lockedCollateralA;\n            position.lockedCollateralA = position.lockedCollateralA.sub(\n                rebalanced\n            );\n        } else {\n            rebalanced = position.lockedCollateralB >= amount\n                ? amount\n                : position.lockedCollateralB;\n            position.lockedCollateralB = position.lockedCollateralB.sub(\n                rebalanced\n            );\n        }\n\n        (packedAddr, flipped) = AddressPacking.pack(user, toParty);\n        position = self[packedAddr];\n\n        if (!flipped) {\n            position.lockedCollateralA = position.lockedCollateralA.add(\n                rebalanced\n            );\n        } else {\n            position.lockedCollateralB = position.lockedCollateralB.add(\n                rebalanced\n            );\n        }\n    }\n\n    /**\n     * @dev Clears the state of bilateral position\n     * @param self The mapping with all bilateral collateral positions\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     */\n    function clear(\n        mapping(bytes32 => CollateralPosition.Position) storage self,\n        address party0,\n        address party1\n    ) internal {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        delete self[packedAddrs];\n    }\n}\n"
    },
    "contracts/test/CollateralPositionTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../libraries/CollateralPosition.sol\";\n\ncontract CollateralPositionTest {\n    using SafeMath for uint256;\n\n    mapping(bytes32 => CollateralPosition.Position) private _positions;\n\n    function get(address party0, address party1)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        return CollateralPosition.get(_positions, party0, party1);\n    }\n\n    function getGasCostOfGet(address party0, address party1)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        CollateralPosition.get(_positions, party0, party1);\n\n        return gasBefore - gasleft();\n    }\n\n    function deposit(\n        address depositor,\n        address counterparty,\n        uint256 amount\n    ) public {\n        (uint256 lockedCollateralBeforeDepositor, ) = get(\n            depositor,\n            counterparty\n        );\n\n        CollateralPosition.deposit(_positions, depositor, counterparty, amount);\n\n        (uint256 lockedCollateralAfterDepositor, ) = get(\n            depositor,\n            counterparty\n        );\n\n        require(\n            lockedCollateralAfterDepositor ==\n                lockedCollateralBeforeDepositor.add(amount),\n            \"INCORRECT_DEPOSIT_ADDITION\"\n        );\n    }\n\n    function withdraw(\n        address user,\n        address counterparty,\n        uint256 amount\n    ) public {\n        (uint256 lockedCollateralBeforeUser, ) = get(user, counterparty);\n\n        CollateralPosition.withdraw(_positions, user, counterparty, amount);\n\n        (uint256 lockedCollateralAfterUser, ) = get(user, counterparty);\n\n        uint256 withdrawn = lockedCollateralBeforeUser >= amount\n            ? amount\n            : lockedCollateralBeforeUser;\n        require(\n            lockedCollateralAfterUser ==\n                lockedCollateralBeforeUser.sub(withdrawn),\n            \"INCORRECT_WITHDRAW_SUBSTRACTION\"\n        );\n    }\n\n    function liquidate(\n        address from,\n        address to,\n        uint256 amount\n    ) public {\n        (\n            uint256 lockedCollateralBeforeFrom,\n            uint256 lockedCollateralBeforeTo\n        ) = get(from, to);\n\n        CollateralPosition.liquidate(_positions, from, to, amount);\n\n        (\n            uint256 lockedCollateralAfterFrom,\n            uint256 lockedCollateralAfterTo\n        ) = get(from, to);\n\n        uint256 liquidated = lockedCollateralBeforeFrom >= amount\n            ? amount\n            : lockedCollateralBeforeFrom;\n\n        require(\n            lockedCollateralAfterFrom ==\n                lockedCollateralBeforeFrom.sub(liquidated),\n            \"INCORRECT_LIQUIDATION_SUBSTRACTION\"\n        );\n        require(\n            lockedCollateralAfterTo == lockedCollateralBeforeTo.add(liquidated),\n            \"INCORRECT_LIQUIDATION_ADDITION\"\n        );\n    }\n\n    function rebalance(\n        address user,\n        address fromParty,\n        address toParty,\n        uint256 amount\n    ) public {\n        (uint256 lockedCollateralBeforeUser0, ) = get(user, fromParty);\n        (uint256 lockedCollateralBeforeUser1, ) = get(user, toParty);\n\n        CollateralPosition.rebalance(\n            _positions,\n            user,\n            fromParty,\n            toParty,\n            amount\n        );\n\n        (uint256 lockedCollateralAfterUser0, ) = get(user, fromParty);\n        (uint256 lockedCollateralAfterUser1, ) = get(user, toParty);\n\n        uint256 rebalanced = lockedCollateralBeforeUser0 >= amount\n            ? amount\n            : lockedCollateralBeforeUser0;\n\n        require(\n            lockedCollateralAfterUser0 ==\n                lockedCollateralBeforeUser0.sub(rebalanced),\n            \"INCORRECT_REBALANCE_SUBSTRACTION\"\n        );\n\n        require(\n            lockedCollateralAfterUser1 ==\n                lockedCollateralBeforeUser1.add(rebalanced),\n            \"INCORRECT_REBALANCE_ADDITION\"\n        );\n    }\n\n    function clear(address party0, address party1) public {\n        CollateralPosition.clear(_positions, party0, party1);\n\n        (uint256 lockedCollateralA, uint256 lockedCollateralB) = get(\n            party0,\n            party1\n        );\n\n        require(\n            lockedCollateralA == 0 && lockedCollateralB == 0,\n            \"INCORRECT_POSITION_CLEAR\"\n        );\n    }\n}\n"
    },
    "contracts/mocks/CollateralAggregatorMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../libraries/AddressPacking.sol\";\nimport \"../interfaces/ICollateralVault.sol\";\nimport \"../CollateralAggregatorV2.sol\";\n\ncontract CollateralAggregatorMock is CollateralAggregatorV2 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) _maxWithdrawals;\n    mapping(bytes32 => PositionWithdrawal) _maxPositionWithdrawals;\n\n    struct PositionWithdrawal {\n        uint256 withdraw0;\n        uint256 withdraw1;\n    }\n\n    function getMaxCollateralBookWidthdraw(address user)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _maxWithdrawals[user];\n    }\n\n    function getMaxCollateralWidthdraw(address party0, address party1)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        (bytes32 addrPack, bool flipped) = AddressPacking.pack(party0, party1);\n        PositionWithdrawal memory withdrawal = _maxPositionWithdrawals[\n            addrPack\n        ];\n        withdrawal = _handleFlippedCase(withdrawal, flipped);\n\n        return (withdrawal.withdraw0, withdrawal.withdraw1);\n    }\n\n    function setMaxCollateralBookWidthdraw(address user, uint256 amount)\n        public\n    {\n        _maxWithdrawals[user] = amount;\n    }\n\n    function setMaxCollateralWidthdraw(\n        address party0,\n        address party1,\n        uint256 amount0,\n        uint256 amount1\n    ) public {\n        (bytes32 addrPack, bool flipped) = AddressPacking.pack(party0, party1);\n        PositionWithdrawal memory withdrawal;\n\n        withdrawal.withdraw0 = amount0;\n        withdrawal.withdraw1 = amount1;\n\n        withdrawal = _handleFlippedCase(withdrawal, flipped);\n        _maxPositionWithdrawals[addrPack] = withdrawal;\n    }\n\n    function _handleFlippedCase(\n        PositionWithdrawal memory withdrawal,\n        bool flipped\n    ) internal pure returns (PositionWithdrawal memory) {\n        if (flipped) {\n            uint256 withdraw = withdrawal.withdraw0;\n\n            withdrawal.withdraw0 = withdrawal.withdraw1;\n            withdrawal.withdraw1 = withdraw;\n        }\n\n        return withdrawal;\n    }\n\n    function rebalanceTo(\n        address _user,\n        address _counterparty,\n        uint256 _amountETH,\n        address _vault\n    ) external returns (uint256) {\n        return\n            ICollateralVault(_vault).rebalanceTo(\n                _user,\n                _counterparty,\n                _amountETH\n            );\n    }\n\n    function rebalanceFrom(\n        address _user,\n        address _counterparty,\n        uint256 _amountETH,\n        address _vault\n    ) external returns (uint256) {\n        return\n            ICollateralVault(_vault).rebalanceFrom(\n                _user,\n                _counterparty,\n                _amountETH\n            );\n    }\n\n    function rebalanceBetween(\n        address _user,\n        address _fromParty,\n        address _toParty,\n        uint256 _amountETH,\n        address _vault\n    ) external returns (uint256) {\n        return\n            ICollateralVault(_vault).rebalanceBetween(\n                _user,\n                _fromParty,\n                _toParty,\n                _amountETH\n            );\n    }\n\n    function liquidate(\n        address _from,\n        address _to,\n        uint256 _amountETH,\n        address _vault\n    ) external returns (uint256) {\n        return ICollateralVault(_vault).liquidate(_from, _to, _amountETH);\n    }\n}\n"
    },
    "contracts/CollateralAggregatorV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./interfaces/ICollateralAggregatorV2.sol\";\nimport \"./libraries/AddressPacking.sol\";\nimport \"./libraries/NetPV.sol\";\nimport \"./ProtocolTypes.sol\";\nimport \"./CollateralManagement.sol\";\nimport \"hardhat/console.sol\";\n\n/**\n * @title Collateral Aggregator contract is used to manage Secured Finance\n * protocol collateral obligations and movements of collateral across collateral vaults.\n *\n * This contract handle the calculations of aggregated collateral obligations between users\n * in a bilateral relations, calculations of required rebalancing to stabilize\n * the bilateral position, liquidations using FX rates for all protocol currency pairs to ETH\n *\n * Liquidations and rebalancing operations are handled across all collateral vaults where\n * users have deposited their funds in FIFO order.\n *\n * Contract linked to Product based contracts (like Loan, Swap, etc),\n * LendingMarkets, CurrencyController contracts and Liquidation Engine.\n */\ncontract CollateralAggregatorV2 is\n    ICollateralAggregator,\n    ProtocolTypes,\n    CollateralManagement\n{\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using NetPV for NetPV.CcyNetting;\n\n    // Mapping for total amount of collateral locked against independent collateral from all books.\n    mapping(address => mapping(bytes32 => uint256)) public unsettledCollateral;\n\n    // Mapping for used currencies in unsettled exposures.\n    mapping(address => EnumerableSet.Bytes32Set)\n        private exposedUnsettledCurrencies;\n\n    // Mapping for all registered users.\n    mapping(address => bool) private isRegistered;\n\n    // Mapping for used currencies set in bilateral position.\n    mapping(bytes32 => EnumerableSet.Bytes32Set) private exposedCurrencies;\n\n    // Mapping for used collateral vaults in bilateral position.\n    mapping(bytes32 => EnumerableSet.AddressSet) private usedVaultsInPosition;\n\n    // Mapping for used collateral vaults per user.\n    mapping(address => EnumerableSet.AddressSet) private usedVaults;\n\n    // Mapping for exposures per currency in bilateral position.\n    mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting))\n        private ccyNettings;\n\n    /**\n     * @dev Modifier to check if user registered already\n     */\n    modifier registeredUser(address _user) {\n        require(isRegistered[_user], \"NOT_REGISTERED\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if user hasn't been registered yet\n     */\n    modifier nonRegisteredUser(address _user) {\n        require(!isRegistered[_user], \"REGISTERED_ALREADY\");\n        _;\n    }\n\n    // =========== COLLATERAL BOOK SECTION ===========\n\n    /**\n     * @dev Register user and store collateral book\n     */\n    function register() public override nonRegisteredUser(msg.sender) {\n        string[] memory _addresses = new string[](0);\n        uint256[] memory _chainIds = new uint256[](0);\n\n        _register(_addresses, _chainIds);\n    }\n\n    /**\n     * @dev Register user and store collateral book\n     * @param _addresses Array of other blockchain addresses\n     * @param _chainIds Array of chain ids for other blockchains\n     */\n    function register(string[] memory _addresses, uint256[] memory _chainIds)\n        public\n        override\n        nonRegisteredUser(msg.sender)\n    {\n        _register(_addresses, _chainIds);\n    }\n\n    // TODO: Rebalance from position to book once position coverage more than 150%\n\n    /**\n     * @dev Triggers to lock unsettled collateral on a global book for selected currency.\n     * @param user User's address\n     * @param ccy Specified currency of the deal\n     * @param amount Amount of funds to be locked in Ccy for user\n     *\n     * @notice Callable only by Loan and linked LendingMarket\n     */\n    function useUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external override acceptedContract {\n        exposedUnsettledCurrencies[user].add(ccy);\n        require(isCoveredUnsettled(user, ccy, amount), \"Not enough collateral\");\n\n        unsettledCollateral[user][ccy] = unsettledCollateral[user][ccy].add(\n            amount\n        );\n\n        emit UseUnsettledCollateral(user, ccy, amount);\n    }\n\n    /**\n     * @dev Triggers to lock collateral using ETH rate for selected currency.\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be locked in Ccy for counterparty A\n     * @param amount1 Amount of funds to be locked in Ccy for counterparty B\n     *\n     * @notice Callable only by Loan and linked LendingMarket\n     */\n    function useCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external override acceptedContract {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(partyA, partyB);\n        exposedCurrencies[packedAddrs].add(ccy);\n\n        NetPV.use(\n            ccyNettings,\n            partyA,\n            partyB,\n            ccy,\n            amount0,\n            amount1,\n            isSettled\n        );\n        _rebalanceIfRequired(partyA, partyB, true);\n\n        emit UseCollateral(partyA, partyB, ccy, amount0, amount1, isSettled);\n    }\n\n    /**\n     * @dev Triggers to lock collateral using ETH rate for selected currency.\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be locked in Ccy for counterparty A\n     * @param amount1 Amount of funds to be locked in Ccy for counterparty B\n     *\n     * @notice Callable only by Loan and linked LendingMarket\n     */\n    function settleCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    ) external override acceptedContract {\n        NetPV.settle(ccyNettings, partyA, partyB, ccy, amount0, amount1);\n        _rebalanceIfRequired(partyA, partyB, true);\n\n        emit SettleCollateral(partyA, partyB, ccy, amount0, amount1);\n    }\n\n    /**\n     * @dev Triggers to calculate total unsettled exposure across all currencies\n     * @param _user User's address\n     */\n    function getTotalUnsettledExp(address _user)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return _netTotalUnsettledAndHypotheticalPV(_user, \"\", 0);\n    }\n\n    /**\n     * @dev Triggers to calculate netted exposures across all currencies with applied haircuts\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     */\n    function getNetAndTotalPV(address _party0, address _party1)\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return _netTotalAndHypotheticalPV(_party0, _party1, \"\", 0, 0, false);\n    }\n\n    /**\n     * @dev Triggers to check if unsettled collateral exposure covered more that 150% from a global collateral book of `_user`.\n     * @param _user User's ethereum address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _unsettledExp Additional exposure to lock into unsettled exposure\n     */\n    function isCoveredUnsettled(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) public view override returns (bool) {\n        (uint256 coverage, ) = _calculateUnsettledCoverageAndTotalExposure(\n            _user,\n            _ccy,\n            _unsettledExp\n        );\n        return coverage >= MARGINLEVEL;\n    }\n\n    /**\n     * @dev Triggers to check if collateral covered more that 150%.\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _party0PV Counterparty A additional present value\n     * @param _party1PV Counterparty B additional present value\n     */\n    function isCovered(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) public view override returns (bool, bool) {\n        (uint256 cover0, uint256 cover1) = _calculateCoverage(\n            _party0,\n            _party1,\n            _ccy,\n            _party0PV,\n            _party1PV,\n            _isSettled\n        );\n\n        return (cover0 >= MARGINLEVEL, cover1 >= MARGINLEVEL);\n    }\n\n    /**\n     * @dev Triggers to get maximum amount of ETH available to widthdraw from `_user` collateral book.\n     * @param _user User's address\n     */\n    function getMaxCollateralBookWidthdraw(address _user)\n        public\n        view\n        virtual\n        override\n        returns (uint256 maxWithdraw)\n    {\n        (maxWithdraw, ) = _calcMaxCollateralWidthdrawFromBook(_user);\n    }\n\n    /**\n     * @dev Triggers to get maximum amount of ETH available to\n     * widthdraw from bilateral position between `party0` and `_party1`.\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     */\n    function getMaxCollateralWidthdraw(address _party0, address _party1)\n        public\n        view\n        virtual\n        override\n        returns (uint256, uint256)\n    {\n        uint256 colAdjustment0;\n        bool isWithdraw0;\n        uint256 colAdjustment1;\n        bool isWithdraw1;\n\n        (\n            colAdjustment0,\n            isWithdraw0,\n            colAdjustment1,\n            isWithdraw1\n        ) = _calcCollateralAdjustment(_party0, _party1, \"\", 0, 0, false, true);\n\n        return (\n            isWithdraw0 ? colAdjustment0 : 0,\n            isWithdraw1 ? colAdjustment1 : 0\n        );\n    }\n\n    /**\n     * @dev Triggers to get coverage of the global collateral book against all unsettled exposure.\n     * @param _user User's address\n     */\n    function getUnsettledCoverage(address _user)\n        public\n        view\n        override\n        returns (uint256 coverage)\n    {\n        (coverage, ) = _calculateUnsettledCoverageAndTotalExposure(\n            _user,\n            \"\",\n            0\n        );\n    }\n\n    /**\n     * @dev Triggers to get coverage of the global collateral book against all unsettled exposure.\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     */\n    function getRebalanceCollateralAmounts(address _party0, address _party1)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        uint256 colAdjustment0;\n        bool isWithdraw0;\n        uint256 colAdjustment1;\n        bool isWithdraw1;\n\n        (\n            colAdjustment0,\n            isWithdraw0,\n            colAdjustment1,\n            isWithdraw1\n        ) = _calcCollateralAdjustment(_party0, _party1, \"\", 0, 0, false, true);\n\n        return (\n            isWithdraw0 ? 0 : colAdjustment0,\n            isWithdraw1 ? 0 : colAdjustment1\n        );\n    }\n\n    /**\n     * @dev Triggers to get bilateral position collateral coverage.\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     */\n    function getCoverage(address _party0, address _party1)\n        public\n        view\n        override\n        returns (uint256, uint256)\n    {\n        return _calculateCoverage(_party0, _party1, \"\", 0, 0, false);\n    }\n\n    /**\n     * @dev Triggers to reduce the amount of unsettled exposure in specific `ccy` from a global collateral book of `user`\n     * @param user User's ETH address\n     * @param ccy Specified currency of the deal\n     * @param amount Amount of funds to be unlocked from unsettled exposure in specified ccy\n     *\n     * @notice Callable only by smart contracts allowed to use collateral\n     */\n    function releaseUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external override acceptedContract {\n        unsettledCollateral[user][ccy] = unsettledCollateral[user][ccy].sub(\n            amount\n        );\n\n        if (unsettledCollateral[user][ccy] == 0) {\n            exposedUnsettledCurrencies[user].remove(ccy);\n        }\n\n        emit ReleaseUnsettled(user, ccy, amount);\n    }\n\n    /**\n     * @dev Triggers to reduce PV for specific `ccy` in bilateral position between `partyA` and `partyB`\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be removed in CcyNetting for counterparty A\n     * @param amount1 Amount of funds to be removed in CcyNetting for counterparty B\n     *\n     * @notice Callable only by smart contracts allowed to use collateral\n     */\n    function releaseCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external override acceptedContract {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(partyA, partyB);\n        require(exposedCurrencies[packedAddrs].contains(ccy), \"non-used ccy\");\n\n        NetPV.release(\n            ccyNettings,\n            partyA,\n            partyB,\n            ccy,\n            amount0,\n            amount1,\n            isSettled\n        );\n        _rebalanceIfRequired(partyA, partyB, true);\n\n        emit Release(partyA, partyB, ccy, amount0, amount1, isSettled);\n    }\n\n    /**\n     * @dev Triggers to update PV value in currency for bilateral position\n     * changes present value in native currency, without exchange rate conversion\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param prevPV0 Previous present value to be substracted from total exposure for counterparty A\n     * @param prevPV1 Previous present value to be substracted from total exposure for counterparty B\n     * @param currentPV0 Current present value to be added to total exposure for counterparty A\n     * @param currentPV1 Current present value to be added to total exposure for counterparty B\n     *\n     * @notice Trigers only be Loan contract\n     */\n    function updatePV(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) external override acceptedContract {\n        NetPV.update(\n            ccyNettings,\n            party0,\n            party1,\n            ccy,\n            prevPV0,\n            prevPV1,\n            currentPV0,\n            currentPV1\n        );\n\n        _rebalanceIfRequired(party0, party1, true);\n\n        emit UpdatePV(\n            party0,\n            party1,\n            ccy,\n            prevPV0,\n            prevPV1,\n            currentPV0,\n            currentPV1\n        );\n    }\n\n    /**\n     * @dev Triggers to liquidate collateral between `from` and `to` parties\n     * works with aggregated liquidation amount in ETH\n     *\n     * @param from Address for liquidating collateral from\n     * @param to Address for sending collateral to\n     * @param liquidationInETH Liquidation amount in Ccy\n     *\n     * @notice Trigers only be LiquidationEngine\n     */\n    function liquidate(\n        address from,\n        address to,\n        uint256 liquidationInETH\n    ) external override onlyLiquidationEngine {\n        require(\n            _liquidateCollateralAcrossVaults(from, to, liquidationInETH),\n            \"INCORRECT_LIQUIDATION_ACROSS_VAULTS\"\n        );\n    }\n\n    /**\n     * @dev Triggers to liquidate collateral between `from` and `to` parties\n     * works liquidation amount in native `ccy`\n     *\n     * @param from Address for liquidating collateral from\n     * @param to Address for sending collateral to\n     * @param ccy Short identifier of currency used to liquidate\n     * @param liquidationAmount Liquidation amount in Ccy\n     * @param isSettled Identifier wether collateral obligations for release is settled\n     *\n     * @notice Trigers only be LiquidationEngine\n     */\n    function liquidate(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 liquidationAmount,\n        uint256 pv,\n        bool isSettled\n    ) external override onlyLiquidationEngineOrCollateralUser {\n        uint256 liquidationTarget = liquidationAmount.mul(LQLEVEL).div(BP);\n        uint256 liqudationInETH = currencyController.convertToETH(\n            ccy,\n            liquidationTarget\n        );\n\n        require(\n            _liquidateCollateralAcrossVaults(from, to, liqudationInETH),\n            \"INCORRECT_LIQUIDATION_ACROSS_VAULTS\"\n        );\n\n        emit Liquidate(from, to, ccy, liquidationAmount);\n\n        NetPV.release(ccyNettings, from, to, ccy, pv, 0, isSettled);\n\n        emit Release(from, to, ccy, pv, 0, isSettled);\n\n        _rebalanceIfRequired(from, to, true);\n    }\n\n    function checkRegisteredUser(address addr)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return isRegistered[addr];\n    }\n\n    function getCcyExposures(\n        address partyA,\n        address partyB,\n        bytes32 ccy\n    )\n        public\n        view\n        override\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(partyA, partyB);\n        require(exposedCurrencies[packedAddrs].contains(ccy), \"non-used ccy\");\n        NetPV.CcyNetting memory netting = NetPV.get(\n            ccyNettings,\n            partyA,\n            partyB,\n            ccy\n        );\n\n        return (\n            netting.unsettled0PV,\n            netting.unsettled1PV,\n            netting.party0PV,\n            netting.party1PV\n        );\n    }\n\n    function getExposedCurrencies(address partyA, address partyB)\n        public\n        view\n        override\n        returns (bytes32[] memory)\n    {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(partyA, partyB);\n        EnumerableSet.Bytes32Set storage expCcy = exposedCurrencies[\n            packedAddrs\n        ];\n\n        uint256 numCcy = expCcy.length();\n        bytes32[] memory currencies = new bytes32[](numCcy);\n\n        for (uint256 i = 0; i < numCcy; i++) {\n            bytes32 ccy = expCcy.at(i);\n            currencies[i] = ccy;\n        }\n\n        return currencies;\n    }\n\n    function getUsedVaults(address party0, address party1)\n        public\n        view\n        override\n        returns (address[] memory)\n    {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        EnumerableSet.AddressSet storage vaultsSet = usedVaultsInPosition[\n            packedAddrs\n        ];\n\n        uint256 numVaults = vaultsSet.length();\n        address[] memory vaults = new address[](numVaults);\n\n        for (uint256 i = 0; i < numVaults; i++) {\n            address vault = vaultsSet.at(i);\n            vaults[i] = vault;\n        }\n\n        return vaults;\n    }\n\n    function getUsedVaults(address user)\n        public\n        view\n        override\n        returns (address[] memory)\n    {\n        EnumerableSet.AddressSet storage vaultsSet = usedVaults[user];\n\n        uint256 numVaults = vaultsSet.length();\n        address[] memory vaults = new address[](numVaults);\n\n        for (uint256 i = 0; i < numVaults; i++) {\n            address vault = vaultsSet.at(i);\n            vaults[i] = vault;\n        }\n\n        return vaults;\n    }\n\n    // =========== INTERNAL FUNCTIONS ===========\n\n    /**\n     * @dev Triggers internaly to store new collateral book\n     */\n    function _register(string[] memory _addresses, uint256[] memory _chainIds)\n        internal\n    {\n        isRegistered[msg.sender] = true;\n        // perform onboarding steps here\n\n        crosschainAddressResolver.updateAddresses(\n            msg.sender,\n            _chainIds,\n            _addresses\n        );\n\n        emit Register(msg.sender);\n    }\n\n    struct NetAndTotalPVLocalVars {\n        bytes32 packedAddrs;\n        bytes32 ccy;\n        NetPV.CcyNetting netting;\n        uint256 exchangeRate;\n        uint256 totalUnsettledPV0inETH;\n        uint256 totalUnsettledPV1inETH;\n        uint256 totalPV0inETH;\n        uint256 totalPV1inETH;\n        uint256 totalCombinedPV0inETH;\n        uint256 totalCombinedPV1inETH;\n        uint256 totalHaircutPV0;\n        uint256 totalHaircutPV1;\n        uint256 haircutRatio;\n        uint256 pvDiff0;\n        uint256 pvDiff1;\n        uint256 netPV0;\n        uint256 netPV1;\n        uint256 maxCcy;\n    }\n\n    /**\n     * @dev Triggers to calculate netted exposures across all currencies with applied haircuts.\n     * Also used to calculate hypothetical Net PV with additional exposure in specific `_ccy`\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _party0PV Counterparty A additional present value\n     * @param _party1PV Counterparty B additional present value\n     */\n    function _netTotalAndHypotheticalPV(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool isSettled\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        NetAndTotalPVLocalVars memory vars;\n        (vars.packedAddrs, ) = AddressPacking.pack(_party0, _party1);\n        EnumerableSet.Bytes32Set storage expCcy = exposedCurrencies[\n            vars.packedAddrs\n        ];\n\n        vars.maxCcy = expCcy.length();\n\n        for (uint256 i = 0; i < vars.maxCcy; i++) {\n            vars.ccy = expCcy.at(i);\n\n            if (_ccy == vars.ccy) {\n                vars.netting = NetPV.get(\n                    ccyNettings,\n                    _party0,\n                    _party1,\n                    vars.ccy,\n                    _party0PV,\n                    _party1PV,\n                    isSettled\n                );\n            } else {\n                vars.netting = NetPV.get(\n                    ccyNettings,\n                    _party0,\n                    _party1,\n                    vars.ccy\n                );\n            }\n\n            vars.exchangeRate = uint256(\n                currencyController.getLastETHPrice(vars.ccy)\n            );\n            vars.netting = _convertPositionToETH(\n                vars.netting,\n                vars.exchangeRate\n            );\n\n            vars.totalUnsettledPV0inETH = vars.totalUnsettledPV0inETH.add(\n                vars.netting.unsettled0PV\n            );\n            vars.totalUnsettledPV1inETH = vars.totalUnsettledPV1inETH.add(\n                vars.netting.unsettled1PV\n            );\n\n            vars.haircutRatio = currencyController.getHaircut(vars.ccy);\n\n            vars.totalPV0inETH = vars.totalPV0inETH.add(vars.netting.party0PV);\n            vars.totalPV1inETH = vars.totalPV1inETH.add(vars.netting.party1PV);\n            vars.totalHaircutPV0 = vars.totalHaircutPV0.add(\n                vars.netting.party0PV.mul(vars.haircutRatio).div(BP)\n            );\n            vars.totalHaircutPV1 = vars.totalHaircutPV1.add(\n                vars.netting.party1PV.mul(vars.haircutRatio).div(BP)\n            );\n        }\n\n        vars.pvDiff0 = vars.totalPV0inETH >= vars.totalHaircutPV1\n            ? vars.totalPV0inETH.sub(vars.totalHaircutPV1)\n            : 0;\n        vars.pvDiff1 = vars.totalPV1inETH >= vars.totalHaircutPV0\n            ? vars.totalPV1inETH.sub(vars.totalHaircutPV0)\n            : 0;\n\n        (vars.netPV0, vars.netPV1) = vars.pvDiff0 > vars.pvDiff1\n            ? (\n                vars.pvDiff0.sub(vars.pvDiff1).add(vars.totalUnsettledPV0inETH),\n                vars.totalUnsettledPV1inETH\n            )\n            : (\n                vars.totalUnsettledPV0inETH,\n                vars.pvDiff1.sub(vars.pvDiff0).add(vars.totalUnsettledPV1inETH)\n            );\n\n        vars.totalCombinedPV0inETH = vars.totalUnsettledPV0inETH.add(\n            vars.totalPV0inETH\n        );\n        vars.totalCombinedPV1inETH = vars.totalUnsettledPV1inETH.add(\n            vars.totalPV1inETH\n        );\n\n        return (\n            vars.netPV0,\n            vars.netPV1,\n            vars.totalCombinedPV0inETH,\n            vars.totalCombinedPV1inETH\n        );\n    }\n\n    function _convertPositionToETH(\n        NetPV.CcyNetting memory netting,\n        uint256 exchangeRate\n    ) internal pure returns (NetPV.CcyNetting memory) {\n        if (netting.unsettled0PV > 0) {\n            netting.unsettled0PV = netting.unsettled0PV.mul(exchangeRate).div(\n                1e18\n            );\n        }\n\n        if (netting.unsettled1PV > 0) {\n            netting.unsettled1PV = netting.unsettled1PV.mul(exchangeRate).div(\n                1e18\n            );\n        }\n\n        if (netting.party0PV > 0) {\n            netting.party0PV = netting.party0PV.mul(exchangeRate).div(1e18);\n        }\n\n        if (netting.party1PV > 0) {\n            netting.party1PV = netting.party1PV.mul(exchangeRate).div(1e18);\n        }\n\n        return netting;\n    }\n\n    struct CollateralReqLocalVars {\n        uint256 net0;\n        uint256 net1;\n        uint256 total0;\n        uint256 total1;\n        uint256 minMarginReq0;\n        uint256 minMarginReq1;\n        uint256 req0;\n        uint256 req1;\n    }\n\n    /**\n     * @dev Triggers to calculate collateral coverage for bilateral position with/without additional PV\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `cover0`, `cover1` uint256 coverage percentages in basis point per counterparty\n     */\n    // TODO: NOW\n    function _calculateCollateralRequirements(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) internal view returns (uint256, uint256) {\n        CollateralReqLocalVars memory vars;\n\n        (\n            vars.net0,\n            vars.net1,\n            vars.total0,\n            vars.total1\n        ) = _netTotalAndHypotheticalPV(\n            _party0,\n            _party1,\n            _ccy,\n            _party0PV,\n            _party1PV,\n            _isSettled\n        );\n\n        vars.minMarginReq0 = vars.total0.mul(MIN_COLLATERAL_RATIO).div(BP);\n        vars.minMarginReq1 = vars.total1.mul(MIN_COLLATERAL_RATIO).div(BP);\n\n        if (vars.net0 > 0) {\n            vars.req0 = vars.minMarginReq0 >\n                (vars.net0.mul(MARGINLEVEL)).div(BP)\n                ? vars.minMarginReq0\n                : vars.net0;\n        } else {\n            vars.req0 = vars.minMarginReq0;\n        }\n\n        if (vars.net1 > 0) {\n            vars.req1 = vars.minMarginReq1 >\n                (vars.net1.mul(MARGINLEVEL)).div(BP)\n                ? vars.minMarginReq1\n                : vars.net1;\n        } else {\n            vars.req1 = vars.minMarginReq1;\n        }\n\n        return (vars.req0, vars.req1);\n    }\n\n    struct CoverageCalcLocalVars {\n        uint256 req0;\n        uint256 req1;\n        uint256 cover0;\n        uint256 cover1;\n        uint256 lockedCollateral0;\n        uint256 lockedCollateral1;\n    }\n\n    /**\n     * @dev Triggers to calculate collateral coverage for bilateral position with/without additional PV\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `cover0`, `cover1` uint256 coverage percentages in basis point per counterparty\n     */\n    // TODO: NOW\n    function _calculateCoverage(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) internal view returns (uint256, uint256) {\n        CoverageCalcLocalVars memory vars;\n\n        (vars.req0, vars.req1) = _calculateCollateralRequirements(\n            _party0,\n            _party1,\n            _ccy,\n            _party0PV,\n            _party1PV,\n            _isSettled\n        );\n\n        (\n            vars.lockedCollateral0,\n            vars.lockedCollateral1\n        ) = _totalLockedCollateralInPosition(_party0, _party1);\n\n        if (vars.req0 > 0) {\n            vars.cover0 = (PCT.mul(vars.lockedCollateral0)).div(vars.req0);\n        }\n\n        if (vars.req1 > 0) {\n            vars.cover1 = (PCT.mul(vars.lockedCollateral1)).div(vars.req1);\n        }\n\n        return (vars.cover0, vars.cover1);\n    }\n\n    struct RequiredCollateralAdjustmentLocalVars {\n        uint256 targetReq0;\n        uint256 targetReq1;\n        uint256 colAdjustment0;\n        bool isWithdraw0;\n        uint256 colAdjustment1;\n        bool isWithdraw1;\n        uint256 lockedCollateral0;\n        uint256 lockedCollateral1;\n    }\n\n    function _calcCollateralAdjustment(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _amount0,\n        uint256 _amount1,\n        bool _isSettled,\n        bool _safeRebalance\n    )\n        internal\n        view\n        returns (\n            uint256,\n            bool,\n            uint256,\n            bool\n        )\n    {\n        RequiredCollateralAdjustmentLocalVars memory vars;\n\n        (vars.targetReq0, vars.targetReq1) = _calculateCollateralRequirements(\n            _party0,\n            _party1,\n            _ccy,\n            _amount0,\n            _amount1,\n            _isSettled\n        );\n\n        if (_safeRebalance) {\n            vars.targetReq0 = vars.targetReq0.mul(MARGINLEVEL).div(BP);\n            vars.targetReq1 = vars.targetReq1.mul(MARGINLEVEL).div(BP);\n        }\n\n        (\n            vars.lockedCollateral0,\n            vars.lockedCollateral1\n        ) = _totalLockedCollateralInPosition(_party0, _party1);\n\n        (\n            vars.colAdjustment0,\n            vars.isWithdraw0\n        ) = _determineCollateralAdjustment(\n            vars.lockedCollateral0,\n            vars.targetReq0\n        );\n        (\n            vars.colAdjustment1,\n            vars.isWithdraw1\n        ) = _determineCollateralAdjustment(\n            vars.lockedCollateral1,\n            vars.targetReq1\n        );\n\n        return (\n            vars.colAdjustment0,\n            vars.isWithdraw0,\n            vars.colAdjustment1,\n            vars.isWithdraw1\n        );\n    }\n\n    function _determineCollateralAdjustment(\n        uint256 _lockedCollateral,\n        uint256 _targetReq\n    ) internal pure returns (uint256 amount, bool isWithdraw) {\n        if (_lockedCollateral > 0 && _targetReq > 0) {\n            if (_lockedCollateral > _targetReq) {\n                amount = _lockedCollateral.sub(_targetReq);\n                isWithdraw = true;\n            } else {\n                amount = _targetReq.sub(_lockedCollateral);\n                isWithdraw = false;\n            }\n        } else if (_lockedCollateral > 0 && _targetReq == 0) {\n            amount = _lockedCollateral;\n            isWithdraw = true;\n        } else if (_lockedCollateral == 0 && _targetReq > 0) {\n            amount = _targetReq;\n            isWithdraw = false;\n        }\n\n        return (amount, isWithdraw);\n    }\n\n    struct NetUnsettledExpLocalVars {\n        uint256 totalExp;\n        uint256 ccyExp;\n        uint256 ccyExpInETH;\n        uint256 maxCcy;\n    }\n\n    /**\n     * @dev Triggers to calculate total unsettled exposure across all currencies against all global collateral books.\n     * Also used to calculate hypothetical Net PV with additional exposure in specific `_ccy`\n     * @param _user User's ethereum address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _unsettledExp Additional exposure to lock into unsettled exposure\n     */\n    function _netTotalUnsettledAndHypotheticalPV(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) internal view returns (uint256) {\n        EnumerableSet.Bytes32Set storage expCcy = exposedUnsettledCurrencies[\n            _user\n        ];\n\n        NetUnsettledExpLocalVars memory vars;\n\n        vars.maxCcy = expCcy.length();\n\n        for (uint256 i = 0; i < vars.maxCcy; i++) {\n            bytes32 ccy = expCcy.at(i);\n            vars.ccyExp = unsettledCollateral[_user][ccy];\n\n            if (_ccy == ccy) {\n                vars.ccyExp = vars.ccyExp.add(_unsettledExp);\n            }\n\n            vars.ccyExpInETH = currencyController.convertToETH(\n                ccy,\n                vars.ccyExp\n            );\n            vars.totalExp = vars.totalExp.add(vars.ccyExpInETH);\n        }\n\n        return vars.totalExp;\n    }\n\n    struct UnsettledCoverageLocalVars {\n        uint256 totalExpInETH;\n        uint256 coverage;\n        uint256 independentAmount;\n    }\n\n    function _calculateUnsettledCoverageAndTotalExposure(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) internal view returns (uint256, uint256) {\n        UnsettledCoverageLocalVars memory vars;\n\n        vars.totalExpInETH = _netTotalUnsettledAndHypotheticalPV(\n            _user,\n            _ccy,\n            _unsettledExp\n        );\n        vars.independentAmount = _totalIndependentCollateralInETH(_user);\n\n        if (vars.totalExpInETH > 0) {\n            vars.coverage = (PCT.mul(vars.independentAmount)).div(\n                vars.totalExpInETH\n            );\n        } else {\n            return (0, vars.totalExpInETH);\n        }\n\n        return (vars.coverage, vars.totalExpInETH);\n    }\n\n    struct MaxCollateralBookWidthdrawLocalVars {\n        uint256 totalExpInETH;\n        uint256 coverage;\n        uint256 delta;\n        uint256 maxWidthdraw;\n        uint256 independentAmount;\n    }\n\n    /**\n     * @dev Triggers to calculate maximum amount of ETH available to widthdraw from `_user` collateral book\n     * @param _user User's ethereum address\n     *\n     * @return `maxWidthdraw` max widthdrawable amount of ETH\n     */\n    function _calcMaxCollateralWidthdrawFromBook(address _user)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        MaxCollateralBookWidthdrawLocalVars memory vars;\n\n        (\n            vars.coverage,\n            vars.totalExpInETH\n        ) = _calculateUnsettledCoverageAndTotalExposure(_user, \"\", 0);\n        vars.independentAmount = _totalIndependentCollateralInETH(_user);\n\n        if (vars.coverage > MARGINLEVEL) {\n            // TODO: discuss if it makes sense to decrease to 100%\n            vars.delta = vars.coverage.sub(MARGINLEVEL);\n\n            vars.maxWidthdraw = vars.independentAmount.mul(vars.delta).div(\n                vars.coverage\n            );\n        } else if (vars.totalExpInETH == 0) {\n            return (vars.independentAmount, vars.totalExpInETH);\n        } else {\n            return (0, vars.totalExpInETH);\n        }\n\n        return (vars.maxWidthdraw, vars.totalExpInETH);\n    }\n\n    struct TotalLockedCollateralLocalVars {\n        uint256 len;\n        uint256 lockedCollateral0;\n        uint256 lockedCollateral1;\n        uint256 totalCollateral0;\n        uint256 totalCollateral1;\n    }\n\n    function _totalLockedCollateralInPosition(address _party0, address _party1)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(_party0, _party1);\n        EnumerableSet.AddressSet storage vaults = usedVaultsInPosition[\n            packedAddrs\n        ];\n\n        TotalLockedCollateralLocalVars memory vars;\n        vars.len = vaults.length();\n\n        for (uint256 i = 0; i < vars.len; i++) {\n            address vaultAddr = vaults.at(i);\n\n            (vars.lockedCollateral0, vars.lockedCollateral1) = ICollateralVault(\n                vaultAddr\n            ).getLockedCollateralInETH(_party0, _party1);\n\n            vars.totalCollateral0 = vars.totalCollateral0.add(\n                vars.lockedCollateral0\n            );\n            vars.totalCollateral1 = vars.totalCollateral1.add(\n                vars.lockedCollateral1\n            );\n        }\n\n        return (vars.totalCollateral0, vars.totalCollateral1);\n    }\n\n    function _totalIndependentCollateralInETH(address _party)\n        internal\n        view\n        returns (uint256)\n    {\n        EnumerableSet.AddressSet storage vaults = usedVaults[_party];\n        uint256 lockedCollateral;\n        uint256 totalCollateral;\n\n        uint256 len = vaults.length();\n\n        for (uint256 i = 0; i < len; i++) {\n            address vaultAddr = vaults.at(i);\n            lockedCollateral = ICollateralVault(vaultAddr)\n                .getIndependentCollateralInETH(_party);\n\n            totalCollateral = totalCollateral.add(lockedCollateral);\n        }\n\n        return totalCollateral;\n    }\n\n    function _liquidateCollateralAcrossVaults(\n        address _from,\n        address _to,\n        uint256 _liquidationTarget\n    ) internal returns (bool) {\n        EnumerableSet.AddressSet storage vaults = usedVaults[_from];\n        uint256 len = vaults.length();\n        uint256 i = 0;\n\n        while (_liquidationTarget != 0 && i < len) {\n            address vaultAddr = vaults.at(i);\n            _liquidationTarget = ICollateralVault(vaultAddr).liquidate(\n                _from,\n                _to,\n                _liquidationTarget\n            );\n\n            i += 1;\n        }\n\n        if (_liquidationTarget > 0) return false;\n\n        return true;\n    }\n\n    function _rebalanceCollateralAcrossVaults(\n        address _party0,\n        address _party1,\n        uint256 _rebalanceTarget,\n        bool isRebalanceFrom\n    ) internal returns (bool) {\n        EnumerableSet.AddressSet storage vaults = usedVaults[_party0];\n        uint256 len = vaults.length();\n        uint256 i = 0;\n\n        while (_rebalanceTarget != 0 && i < len) {\n            address vaultAddr = vaults.at(i);\n\n            if (isRebalanceFrom) {\n                _rebalanceTarget = ICollateralVault(vaultAddr).rebalanceFrom(\n                    _party0,\n                    _party1,\n                    _rebalanceTarget\n                );\n            } else {\n                _rebalanceTarget = ICollateralVault(vaultAddr).rebalanceTo(\n                    _party0,\n                    _party1,\n                    _rebalanceTarget\n                );\n            }\n\n            i += 1;\n        }\n\n        if (_rebalanceTarget > 0) return false;\n\n        return true;\n    }\n\n    function _rebalanceIfRequired(\n        address _party0,\n        address _party1,\n        bool _safeRebalance\n    ) internal {\n        (\n            uint256 rebalance0,\n            bool isRebalanceFrom0,\n            uint256 rebalance1,\n            bool isRebalanceFrom1\n        ) = _calcCollateralAdjustment(\n                _party0,\n                _party1,\n                \"\",\n                0,\n                0,\n                false,\n                _safeRebalance\n            );\n\n        if (rebalance0 > 0) {\n            require(\n                _rebalanceCollateralAcrossVaults(\n                    _party0,\n                    _party1,\n                    rebalance0,\n                    isRebalanceFrom0\n                ),\n                \"NON_ENOUGH_FUNDS_FOR_REBALANCE\"\n            );\n        }\n\n        if (rebalance1 > 0) {\n            require(\n                _rebalanceCollateralAcrossVaults(\n                    _party1,\n                    _party0,\n                    rebalance1,\n                    isRebalanceFrom1\n                ),\n                \"NON_ENOUGH_FUNDS_FOR_REBALANCE\"\n            );\n        }\n    }\n\n    function enterVault(address _user) external override onlyCollateralVault {\n        usedVaults[_user].add(msg.sender);\n    }\n\n    function exitVault(address _user) external override onlyCollateralVault {\n        usedVaults[_user].remove(msg.sender);\n    }\n\n    function enterVault(address _party0, address _party1)\n        external\n        override\n        onlyCollateralVault\n    {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(_party0, _party1);\n        usedVaultsInPosition[packedAddrs].add(msg.sender);\n    }\n\n    function exitVault(address _party0, address _party1)\n        external\n        override\n        onlyCollateralVault\n    {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(_party0, _party1);\n        usedVaultsInPosition[packedAddrs].remove(msg.sender);\n    }\n}\n"
    },
    "contracts/libraries/NetPV.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./AddressPacking.sol\";\n\nlibrary NetPV {\n    using SafeMath for uint256;\n\n    /**\n     * @dev CcyNetting keeps track of total amount of obligations owed\n     * by two counterparties per currency, used to calculate the\n     * total amount of collateral coverage in bilateral position\n     */\n    struct CcyNetting {\n        uint256 unsettled0PV;\n        uint256 unsettled1PV;\n        uint256 party0PV;\n        uint256 party1PV;\n    }\n\n    /**\n     * @dev Helper to return CcyNetting structure in correct order acccording\n     * to in which order counterparty addresses are passed\n     */\n    function _handleFlippedCase(NetPV.CcyNetting memory netting, bool flipped)\n        internal\n        pure\n        returns (NetPV.CcyNetting memory)\n    {\n        if (flipped) {\n            uint256 unsettledPV = netting.unsettled0PV;\n            uint256 partyPV = netting.party0PV;\n\n            netting.unsettled0PV = netting.unsettled1PV;\n            netting.unsettled1PV = unsettledPV;\n            netting.party0PV = netting.party1PV;\n            netting.party1PV = partyPV;\n        }\n\n        return netting;\n    }\n\n    /**\n     * @dev Returns the present value netting between 2 counterparties\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     */\n    function get(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) internal view returns (NetPV.CcyNetting memory netting) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            party0,\n            party1\n        );\n        netting = self[packedAddrs][ccy];\n        netting = _handleFlippedCase(netting, flipped);\n    }\n\n    /**\n     * @dev Returns the present value netting between 2 counterparties\n     * including hypothetical present value\n     *\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     * @param additionalPV0 Hypothetical PV for first party\n     * @param additionalPV1 Hypothetical PV for second party\n     * @param isSettled Boolean wether hypothetical PV settled or not\n     */\n    function get(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 additionalPV0,\n        uint256 additionalPV1,\n        bool isSettled\n    ) internal view returns (NetPV.CcyNetting memory netting) {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            party0,\n            party1\n        );\n        netting = self[packedAddrs][ccy];\n        netting = _handleFlippedCase(netting, flipped);\n\n        if (isSettled) {\n            netting.party0PV = netting.party0PV.add(additionalPV0);\n            netting.party1PV = netting.party1PV.add(additionalPV1);\n        } else {\n            netting.unsettled0PV = netting.unsettled0PV.add(additionalPV0);\n            netting.unsettled1PV = netting.unsettled1PV.add(additionalPV1);\n        }\n    }\n\n    /**\n     * @dev Triggers to increase the amount of obligations in PV netting\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     * @param amount0 Amount of funds to be added for first counterparty\n     * @param amount1 Amount of funds to be added for second counterparty\n     * @param isSettled Boolean statement if obligations are settled already\n     */\n    function use(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            party0,\n            party1\n        );\n        NetPV.CcyNetting storage netting = self[packedAddrs][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                isSettled\n                    ? netting.party0PV = netting.party0PV.add(amount0)\n                    : netting.unsettled0PV = netting.unsettled0PV.add(amount0);\n            }\n            if (amount1 > 0) {\n                isSettled\n                    ? netting.party1PV = netting.party1PV.add(amount1)\n                    : netting.unsettled1PV = netting.unsettled1PV.add(amount1);\n            }\n        } else {\n            if (amount0 > 0) {\n                isSettled\n                    ? netting.party1PV = netting.party1PV.add(amount0)\n                    : netting.unsettled1PV = netting.unsettled1PV.add(amount0);\n            }\n            if (amount1 > 0) {\n                isSettled\n                    ? netting.party0PV = netting.party0PV.add(amount1)\n                    : netting.unsettled0PV = netting.unsettled0PV.add(amount1);\n            }\n        }\n    }\n\n    /**\n     * @dev Triggers to settle previously added obligations in PV netting\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     * @param amount0 Amount of funds to be settled for first counterparty\n     * @param amount1 Amount of funds to be settled for second counterparty\n     */\n    function settle(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            party0,\n            party1\n        );\n        NetPV.CcyNetting storage netting = self[packedAddrs][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                netting.unsettled0PV = netting.unsettled0PV.sub(amount0);\n                netting.party0PV = netting.party0PV.add(amount0);\n            }\n            if (amount1 > 0) {\n                netting.unsettled1PV = netting.unsettled1PV.sub(amount1);\n                netting.party1PV = netting.party1PV.add(amount1);\n            }\n        } else {\n            if (amount0 > 0) {\n                netting.unsettled1PV = netting.unsettled1PV.sub(amount0);\n                netting.party1PV = netting.party1PV.add(amount0);\n            }\n            if (amount1 > 0) {\n                netting.unsettled0PV = netting.unsettled0PV.sub(amount1);\n                netting.party0PV = netting.party0PV.add(amount1);\n            }\n        }\n    }\n\n    /**\n     * @dev Triggers to release PV obligations from netting\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     * @param amount0 Amount of funds to be removed for first counterparty\n     * @param amount1 Amount of funds to be removed for second counterparty\n     */\n    function release(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            party0,\n            party1\n        );\n        NetPV.CcyNetting storage netting = self[packedAddrs][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                isSettled\n                    ? netting.party0PV = netting.party0PV.sub(amount0)\n                    : netting.unsettled0PV = netting.unsettled0PV.sub(amount0);\n            }\n            if (amount1 > 0) {\n                isSettled\n                    ? netting.party1PV = netting.party1PV.sub(amount1)\n                    : netting.unsettled1PV = netting.unsettled1PV.sub(amount1);\n            }\n        } else {\n            if (amount0 > 0) {\n                isSettled\n                    ? netting.party1PV = netting.party1PV.sub(amount0)\n                    : netting.unsettled1PV = netting.unsettled1PV.sub(amount0);\n            }\n            if (amount1 > 0) {\n                isSettled\n                    ? netting.party0PV = netting.party0PV.sub(amount1)\n                    : netting.unsettled0PV = netting.unsettled0PV.sub(amount1);\n            }\n        }\n    }\n\n    /**\n     * @dev Triggers to update PV in bilateral netting during mark-to-market\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     * @param prevPV0 Previous present value to be substracted from total exposure for counterparty A\n     * @param prevPV1 Previous present value to be substracted from total exposure for counterparty B\n     * @param currentPV0 Current present value to be added to total exposure for counterparty A\n     * @param currentPV1 Current present value to be added to total exposure for counterparty B\n     */\n    function update(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) internal {\n        (bytes32 packedAddrs, bool flipped) = AddressPacking.pack(\n            party0,\n            party1\n        );\n        NetPV.CcyNetting storage netting = self[packedAddrs][ccy];\n\n        if (!flipped) {\n            if (currentPV0 > 0) {\n                netting.party0PV = netting.party0PV.sub(prevPV0).add(\n                    currentPV0\n                );\n            }\n            if (currentPV1 > 0) {\n                netting.party1PV = netting.party1PV.sub(prevPV1).add(\n                    currentPV1\n                );\n            }\n        } else {\n            if (currentPV0 > 0) {\n                netting.party1PV = netting.party1PV.sub(prevPV0).add(\n                    currentPV0\n                );\n            }\n            if (currentPV1 > 0) {\n                netting.party0PV = netting.party0PV.sub(prevPV1).add(\n                    currentPV1\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Clears the state of PV netting\n     * @param self The mapping with all present value nettings per currency\n     * @param party0 First counterparty address\n     * @param party1 Second counterparty address\n     * @param ccy Present value currency\n     */\n    function clear(\n        mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting)) storage self,\n        address party0,\n        address party1,\n        bytes32 ccy\n    ) internal {\n        (bytes32 packedAddrs, ) = AddressPacking.pack(party0, party1);\n        delete self[packedAddrs][ccy];\n    }\n}\n"
    },
    "contracts/CollateralManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./interfaces/ICollateralManagement.sol\";\nimport \"./interfaces/ICurrencyController.sol\";\nimport \"./interfaces/ICollateralVault.sol\";\nimport \"./interfaces/ILiquidations.sol\";\nimport \"./interfaces/ICrosschainAddressResolver.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\n/**\n * @title CollateralManagement is an internal component of CollateralAggregator contract\n *\n * This contract allows Secured Finance manage the collateral system such as:\n *\n * 1. Update CurrencyController and LiquidationEngine addresses\n * 2. Add different products implementation contracts as collateral users\n * 3. Link deployed collateral vaults\n * 4. Update main collateral parameters like Margin Call ratio,\n *    Auto-Liquidation level, Liquidation price, and Minimal collateral ratio\n *\n */\ncontract CollateralManagement is ICollateralManagement {\n    using Address for address;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public override LQLEVEL; // 120% for liquidation price\n    uint256 public override MARGINLEVEL; // 150% margin call threshold\n    uint256 public override AUTOLQLEVEL; // 125% auto liquidation\n    uint256 public override MIN_COLLATERAL_RATIO; // 25% minimal collateral ratio\n\n    address public override owner;\n\n    // Linked contract addresses\n    ICurrencyController public currencyController;\n    ILiquidations public liquidationEngine;\n    ICrosschainAddressResolver public crosschainAddressResolver;\n    EnumerableSet.AddressSet private collateralUsers;\n    EnumerableSet.AddressSet private collateralVaults;\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"INVALID_ACCESS\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if msg.sender is collateral user\n     */\n    modifier acceptedContract() {\n        require(collateralUsers.contains(msg.sender), \"NON_COLLATERAL_USER\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if msg.sender is a CollateralVault\n     */\n    modifier onlyCollateralVault() {\n        require(collateralVaults.contains(msg.sender), \"NON_COLLATERAL_VAULT\");\n        _;\n    }\n\n    modifier onlyLiquidationEngine() {\n        require(\n            msg.sender == address(liquidationEngine),\n            \"NON_LIQUIDATION_ENGINE\"\n        );\n        _;\n    }\n\n    modifier onlyLiquidationEngineOrCollateralUser() {\n        require(\n            msg.sender == address(liquidationEngine) ||\n                collateralUsers.contains(msg.sender),\n            \"NOR_LIQUIDATION_ENGINE_COLLATERAL_USER\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     *\n     * @notice sets contract deployer as owner of this contract\n     */\n    constructor() public {\n        owner = msg.sender;\n\n        LQLEVEL = 12000; // 120% for liquidation price\n        MARGINLEVEL = 15000; // 150% margin call threshold\n        AUTOLQLEVEL = 12500; // 125% auto liquidatio\n        MIN_COLLATERAL_RATIO = 2500; // 25% min collateral ratio\n    }\n\n    // =========== LINKED CONTRACT MANAGEMENT SECTION ===========\n\n    /**\n     * @dev Trigers to add contract address to collateral users address set\n     * @param _user Collateral user smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function addCollateralUser(address _user)\n        public\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(_user != address(0), \"Zero address\");\n        require(_user.isContract(), \"Can't add non-contract address\");\n        require(!collateralUsers.contains(_user), \"Can't add existing address\");\n\n        emit CollateralUserAdded(_user);\n\n        return collateralUsers.add(_user);\n    }\n\n    /**\n     * @dev Trigers to link CollateralVault with aggregator\n     * @param _vault CollateralVault smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function linkCollateralVault(address _vault)\n        public\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(_vault != address(0), \"Zero address\");\n        require(_vault.isContract(), \"Can't add non-contract address\");\n        require(\n            !collateralVaults.contains(_vault),\n            \"Can't add existing address\"\n        );\n\n        ICollateralVault vaultContract = ICollateralVault(_vault);\n\n        bytes32 ccy = vaultContract.ccy();\n        address tokenAddress = vaultContract.tokenAddress();\n\n        emit CollateralVaultLinked(_vault, ccy, tokenAddress);\n        return collateralVaults.add(_vault);\n    }\n\n    /**\n     * @dev Trigers to remove collateral user from address set\n     * @param _user Collateral user smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on removing non-existing collateral user\n     */\n    function removeCollateralUser(address _user)\n        public\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(\n            collateralUsers.contains(_user),\n            \"Can't remove non-existing user\"\n        );\n\n        emit CollateralUserRemoved(_user);\n        return collateralUsers.remove(_user);\n    }\n\n    /**\n     * @dev Trigers to remove CollateralVault from address set\n     * @param _vault CollateralVault smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on removing non-existing collateral vault\n     */\n    function removeCollateralVault(address _vault)\n        public\n        override\n        onlyOwner\n        returns (bool)\n    {\n        require(\n            collateralVaults.contains(_vault),\n            \"Can't remove non-existing user\"\n        );\n\n        ICollateralVault vaultContract = ICollateralVault(_vault);\n\n        bytes32 ccy = vaultContract.ccy();\n        address tokenAddress = vaultContract.tokenAddress();\n\n        emit CollateralVaultRemoved(_vault, ccy, tokenAddress);\n\n        return collateralVaults.remove(_vault);\n    }\n\n    /**\n     * @dev Trigers to check if provided `addr` is a collateral user from address set\n     * @param _user Contract address to check if it's a collateral user\n     */\n    function isCollateralUser(address _user)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return collateralUsers.contains(_user);\n    }\n\n    /**\n     * @dev Trigers to check if provided address is valid CollateralVault\n     * @param _vault Contract address to check if it's a CollateralVault\n     */\n    function isCollateralVault(address _vault)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return collateralVaults.contains(_vault);\n    }\n\n    /**\n     * @dev Trigers to add currency controller contract address\n     * @param _addr Currency Controller smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function setCurrencyController(address _addr) public override onlyOwner {\n        require(_addr != address(0), \"Zero address\");\n        require(_addr.isContract(), \"Can't add non-contract address\");\n\n        currencyController = ICurrencyController(_addr);\n\n        emit CurrencyControllerUpdated(_addr);\n    }\n\n    /**\n     * @dev Trigers to set liquidation engine contract address\n     * @param _addr LiquidationEngine smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function setLiquidationEngine(address _addr) public override onlyOwner {\n        require(_addr != address(0), \"Zero address\");\n        require(_addr.isContract(), \"Can't add non-contract address\");\n\n        liquidationEngine = ILiquidations(_addr);\n\n        emit LiquidationEngineUpdated(_addr);\n    }\n\n    /**\n     * @dev Trigers to set cros-chain address resolver contract address\n     * @param _addr CrosschainAddressResolver smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function setCrosschainAddressResolver(address _addr)\n        public\n        override\n        onlyOwner\n    {\n        require(_addr != address(0), \"Zero address\");\n        require(_addr.isContract(), \"Can't add non-contract address\");\n\n        crosschainAddressResolver = ICrosschainAddressResolver(_addr);\n\n        emit CrosschainAddressResolverUpdated(_addr);\n    }\n\n    /**\n     * @dev Trigers to safely update main collateral parameters this function\n     * solves the issue of frontrunning during parameters tuning\n     *\n     * @param _marginCallRatio Margin call ratio\n     * @param _autoLiquidationThreshold Auto Liquidation level ratio\n     * @param _liquidationPrice Liquidation price in basis point\n     * @notice Trigers only be contract owner\n     */\n    function updateMainParameters(\n        uint256 _marginCallRatio,\n        uint256 _autoLiquidationThreshold,\n        uint256 _liquidationPrice\n    ) public override onlyOwner {\n        if (_marginCallRatio != MARGINLEVEL) {\n            updateMarginCallThreshold(_marginCallRatio);\n        }\n\n        if (_autoLiquidationThreshold != AUTOLQLEVEL) {\n            updateAutoLiquidationThreshold(_autoLiquidationThreshold);\n        }\n\n        if (_liquidationPrice != LQLEVEL) {\n            updateLiquidationPrice(_liquidationPrice);\n        }\n    }\n\n    /**\n     * @dev Trigers to update liquidation level ratio\n     * @param _ratio Auto Liquidation level ratio\n     * @notice Trigers only be contract owner\n     */\n    function updateAutoLiquidationThreshold(uint256 _ratio)\n        public\n        override\n        onlyOwner\n    {\n        require(_ratio > 0, \"INCORRECT_RATIO\");\n        require(_ratio < MARGINLEVEL, \"AUTO_LIQUIDATION_RATIO_OVERFLOW\");\n\n        emit AutoLiquidationThresholdUpdated(AUTOLQLEVEL, _ratio);\n        AUTOLQLEVEL = _ratio;\n    }\n\n    /**\n     * @dev Trigers to update margin call level\n     * @param _ratio Margin call ratio\n     * @notice Trigers only be contract owner\n     */\n    function updateMarginCallThreshold(uint256 _ratio)\n        public\n        override\n        onlyOwner\n    {\n        require(_ratio > 0, \"INCORRECT_RATIO\");\n\n        emit MarginCallThresholdUpdated(MARGINLEVEL, _ratio);\n        MARGINLEVEL = _ratio;\n    }\n\n    /**\n     * @dev Trigers to update liquidation price\n     * @param _price Liquidation price in basis point\n     * @notice Trigers only be contract owner\n     */\n    function updateLiquidationPrice(uint256 _price) public override onlyOwner {\n        require(_price > 0, \"INCORRECT_PRICE\");\n        require(_price < AUTOLQLEVEL, \"LIQUIDATION_PRICE_OVERFLOW\");\n\n        emit LiquidationPriceUpdated(LQLEVEL, _price);\n        LQLEVEL = _price;\n    }\n\n    /**\n     * @dev Trigers to update minimal collateral ratio\n     * @param _ratio Minimal collateral ratio in basis points\n     * @notice Trigers only be contract owner\n     */\n    function updateMinCollateralRatio(uint256 _ratio)\n        public\n        override\n        onlyOwner\n    {\n        require(_ratio > 0, \"INCORRECT_RATIO\");\n        require(_ratio < AUTOLQLEVEL, \"MIN_COLLATERAL_RATIO_OVERFLOW\");\n\n        emit MinCollateralRatioUpdated(MIN_COLLATERAL_RATIO, _ratio);\n        MIN_COLLATERAL_RATIO = _ratio;\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/interfaces/ICollateralManagement.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\ninterface ICollateralManagement {\n    event CollateralUserAdded(address indexed user);\n    event CollateralUserRemoved(address indexed user);\n\n    event CollateralVaultLinked(\n        address indexed vault,\n        bytes32 ccy,\n        address tokenAddress\n    );\n    event CollateralVaultRemoved(\n        address indexed vault,\n        bytes32 ccy,\n        address tokenAddress\n    );\n\n    event CurrencyControllerUpdated(address indexed controller);\n    event LiquidationEngineUpdated(address indexed liquidations);\n    event CrosschainAddressResolverUpdated(\n        address indexed crosschainAddressResolver\n    );\n\n    event LiquidationPriceUpdated(uint256 previousPrice, uint256 price);\n    event AutoLiquidationThresholdUpdated(uint256 previousRatio, uint256 ratio);\n    event MarginCallThresholdUpdated(uint256 previousRatio, uint256 ratio);\n    event MinCollateralRatioUpdated(uint256 previousRatio, uint256 price);\n\n    function owner() external view returns (address);\n\n    function AUTOLQLEVEL() external view returns (uint256);\n\n    function LQLEVEL() external view returns (uint256);\n\n    function MARGINLEVEL() external view returns (uint256);\n\n    function MIN_COLLATERAL_RATIO() external view returns (uint256);\n\n    function setCurrencyController(address _addr) external;\n\n    function setLiquidationEngine(address _addr) external;\n\n    function setCrosschainAddressResolver(address _addr) external;\n\n    function addCollateralUser(address _user) external returns (bool);\n\n    function removeCollateralUser(address _user) external returns (bool);\n\n    function isCollateralUser(address _user) external view returns (bool);\n\n    function linkCollateralVault(address _vault) external returns (bool);\n\n    function removeCollateralVault(address _vault) external returns (bool);\n\n    function isCollateralVault(address _vault) external view returns (bool);\n\n    function updateMainParameters(\n        uint256 _marginCallRatio,\n        uint256 _autoLiquidationThreshold,\n        uint256 _liquidationPrice\n    ) external;\n\n    function updateLiquidationPrice(uint256 _price) external;\n\n    function updateAutoLiquidationThreshold(uint256 _ratio) external;\n\n    function updateMarginCallThreshold(uint256 _ratio) external;\n\n    function updateMinCollateralRatio(uint256 _ratio) external;\n}\n"
    },
    "contracts/CollateralAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/ICurrencyController.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./ProtocolTypes.sol\";\n\n/**\n * @title Collateral Aggregator contract is used to collect Secured Finance\n * protocol user's collateral in ETH. This contract also handle the\n * coverage calculation against all present values and liquidations\n * using FX rates for all protocol currency pairs to ETH\n *\n * Contract linked to Product based contracts (like Loan, Swap, etc), LendingMarkets, CurrencyController contracts.\n */\ncontract CollateralAggregator is ProtocolTypes {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n    using Address for address;\n\n    event Register(address indexed addr, uint256 id, uint256 amount);\n\n    event Deposit(address indexed addr, uint256 amount);\n    event PositionDeposit(\n        address indexed partyA,\n        address indexed partyB,\n        uint256 amountA,\n        uint256 amountB\n    );\n\n    event Rebalance(\n        address indexed partyA,\n        address indexed partyB,\n        uint256 amountA,\n        uint256 amountB\n    );\n    event RebalancePositions(\n        address[] fromParties,\n        address[] toParties,\n        uint256[] fromAmounts,\n        uint256[] toAmounts\n    );\n\n    event Withdraw(address indexed addr, uint256 amount);\n    event PositionWithdraw(\n        address indexed partyA,\n        address indexed partyB,\n        uint256 amountA,\n        uint256 amountB\n    );\n\n    event UseCollateral(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    );\n    event UseUnsettledCollateral(\n        address indexed party,\n        bytes32 ccy,\n        uint256 amount\n    );\n\n    event SettleCollateral(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event Release(\n        address indexed partyA,\n        address indexed partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    );\n    event ReleaseUnsettled(address indexed party, bytes32 ccy, uint256 amount);\n\n    event Liquidate(address indexed from, address indexed to, uint256 amount);\n    event LiquidateUnsettled(\n        address indexed from,\n        address indexed to,\n        bytes32 ccy,\n        uint256 amount,\n        uint256 ethAmount\n    );\n\n    event UpdateState(\n        address indexed addr,\n        CollateralState prevState,\n        CollateralState currState\n    );\n    event UpdatePV(\n        address indexed addr,\n        uint256 prevPV,\n        uint256 newPV,\n        Ccy ccy\n    );\n\n    /**\n     * @dev Global collateral book used to track user's total amount\n     * of ETH collateral used across all deals and bilateral positions.\n     */\n    struct Book {\n        uint256 gatewayTokenId; // Civic gateway token ID\n        uint256 independentAmount; // available ETH for rebalancing\n        uint256 lockedCollateral; // total utilized ETH collateral\n    }\n\n    /**\n     * @dev Bilateral collateral position keeps track of collateral\n     * amounts by each counterparty and bilateral position state\n     */\n    struct Position {\n        uint256 lockedCollateralA;\n        uint256 lockedCollateralB;\n        // CollateralState stateA;\n        // CollateralState stateB;\n    }\n\n    /**\n     * @dev CcyNetting keeps track of total amount of obligations owed\n     * by two counterparties per currency, used to calculate the\n     * total amount of collateral coverage in bilateral position\n     */\n    struct CcyNetting {\n        uint256 unsettled0PV;\n        uint256 unsettled1PV;\n        uint256 party0PV;\n        uint256 party1PV;\n    }\n\n    // Mapping for all collateral books.\n    mapping(address => Book) private books;\n\n    // Mapping for total amount of collateral locked in global collateral book by currency code.\n    mapping(address => mapping(bytes32 => uint256)) private unsettledCollateral;\n\n    // Mapping for total amount of collateral locked in global collateral book by currency code.\n    mapping(address => EnumerableSet.Bytes32Set)\n        private exposedUnsettledCurrencies;\n\n    // Mapping for all registered books.\n    mapping(address => bool) private isRegistered;\n\n    // Mapping for bilateral collateral positions between 2 counterparties.\n    mapping(address => mapping(address => Position)) private positions;\n\n    // Mapping for used currencies set in bilateral position.\n    mapping(address => mapping(address => EnumerableSet.Bytes32Set))\n        private exposedCurrencies;\n\n    // Mapping for exposures per currency in bilateral position.\n    mapping(address => mapping(address => mapping(bytes32 => CcyNetting)))\n        private ccyNettings;\n\n    uint256 public LQLEVEL; // 120% for liquidation price\n    uint256 public MARGINLEVEL; // 150% margin call threshold\n    uint256 public AUTOLQLEVEL; // 125% auto liquidation\n\n    address public owner;\n\n    // Linked contract addresses\n    ICurrencyController public currencyController;\n    EnumerableSet.AddressSet private collateralUsers;\n\n    /**\n     * @dev Modifier to make a function callable only by contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if msg.sender is collateral user\n     */\n    modifier acceptedContract() {\n        require(\n            collateralUsers.contains(msg.sender),\n            \"not allowed to use collateral\"\n        );\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if collateral book registered for `_user`\n     */\n    modifier registeredBook(address _user) {\n        require(isRegistered[_user], \"book not found\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to check if collateral book registered for `_user`\n     */\n    modifier nonRegisteredBook(address _user) {\n        require(!isRegistered[_user], \"book registered already\");\n        _;\n    }\n\n    /**\n     * @dev Contract constructor function.\n     *\n     * @notice sets contract deployer as owner of this contract\n     */\n    constructor() public {\n        owner = msg.sender;\n\n        LQLEVEL = 12000; // 120% for liquidation price\n        MARGINLEVEL = 15000; // 150% margin call threshold\n        AUTOLQLEVEL = 12500; // 125% auto liquidatio\n    }\n\n    // =========== LINKED CONTRACT MANAGEMENT SECTION ===========\n\n    /**\n     * @dev Trigers to add contract address to collateral users address set\n     * @param _user Collateral user smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function addCollateralUser(address _user) public onlyOwner returns (bool) {\n        require(_user != address(0), \"Zero address\");\n        require(_user.isContract(), \"Can't add non-contract address\");\n        require(!collateralUsers.contains(_user), \"Can't add existing address\");\n        return collateralUsers.add(_user);\n    }\n\n    /**\n     * @dev Trigers to remove collateral user from address set\n     * @param _user Collateral user smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on removing non-existing collateral user\n     */\n    function removeCollateralUser(address _user)\n        public\n        onlyOwner\n        returns (bool)\n    {\n        require(\n            collateralUsers.contains(_user),\n            \"Can't remove non-existing user\"\n        );\n        return collateralUsers.remove(_user);\n    }\n\n    /**\n     * @dev Trigers to check if provided `addr` is a collateral user from address set\n     * @param _user Contract address to check if it's a collateral user\n     *\n     */\n    function isCollateralUser(address _user) public view returns (bool) {\n        return collateralUsers.contains(_user);\n    }\n\n    /**\n     * @dev Trigers to add currency controller contract address\n     * @param _addr Currency Controller smart contract address\n     *\n     * @notice Trigers only be contract owner\n     * @notice Reverts on saving 0x0 address\n     */\n    function setCurrencyController(address _addr) public onlyOwner {\n        require(_addr != address(0), \"Zero address\");\n        require(_addr.isContract(), \"Can't add non-contract address\");\n\n        currencyController = ICurrencyController(_addr);\n    }\n\n    /**\n     * @dev Trigers to update liquidation level ratio\n     * @param _ratio Liquidation level ratio\n     * @notice Trigers only be contract owner\n     */\n    function updateLiquidationThreshold(uint256 _ratio) public onlyOwner {\n        require(_ratio > 0, \"Incorrect Ratio\");\n        require(_ratio < MARGINLEVEL, \"Liquidation Price Overflow\");\n\n        AUTOLQLEVEL = _ratio;\n    }\n\n    /**\n     * @dev Trigers to update margin call level\n     * @param _ratio Margin call ratio\n     * @notice Trigers only be contract owner\n     */\n    function updateMarginCallThreshold(uint256 _ratio) public onlyOwner {\n        require(_ratio > 0, \"Incorrect Ratio\");\n\n        MARGINLEVEL = _ratio;\n    }\n\n    /**\n     * @dev Trigers to update liquidation price\n     * @param _price Liquidation price in basis point\n     * @notice Trigers only be contract owner\n     */\n    function updateLiquidationPrice(uint256 _price) public onlyOwner {\n        require(_price > 0, \"Incorrect Ratio\");\n        require(_price < AUTOLQLEVEL, \"Liquidation Price Overflow\");\n\n        LQLEVEL = _price;\n    }\n\n    // =========== COLLATERAL BOOK SECTION ===========\n\n    /**\n     * @dev Register user and store collateral book\n     * @param id Gateway token ID for KYC'd addresses\n     *\n     * @notice Payable function, if user sends ETH msg.value adds to independentAmount\n     */\n    function register(uint256 id) public payable nonRegisteredBook(msg.sender) {\n        _register(id);\n    }\n\n    /**\n     * @dev Register user without KYC gateway token\n     *\n     * @notice Payable function, if user sends ETH msg.value adds to independentAmount\n     */\n    function register() public payable nonRegisteredBook(msg.sender) {\n        _register(0);\n    }\n\n    /**\n     * @dev Deposit ETH collateral for msg.sender in collateral book\n     * @notice payable function increases the collateral amount by msg.value\n     */\n    function deposit() public payable registeredBook(msg.sender) {\n        books[msg.sender].independentAmount += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Deposit ETH collateral into bilateral position against counterparty\n     * @param _counterparty Counterparty address in bilateral position\n     * @notice payable function increases locked collateral by msg.value\n     */\n    function deposit(address _counterparty)\n        public\n        payable\n        registeredBook(msg.sender)\n    {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            msg.sender,\n            _counterparty\n        );\n        books[msg.sender].lockedCollateral += msg.value; // save deposited collateral in global book\n\n        Position storage position = positions[_partyA][_partyB];\n\n        if (!flipped) {\n            position.lockedCollateralA += msg.value;\n            emit PositionDeposit(_partyA, _partyB, msg.value, 0);\n        } else {\n            position.lockedCollateralB += msg.value;\n            emit PositionDeposit(_partyA, _partyB, 0, msg.value);\n        }\n    }\n\n    /**\n     * @dev Rebalance collateral from msg.sender collateral book to specific bilateral position\n     *\n     * @notice Triggers by collateral owner\n     */\n    function rebalanceTo(address _counterparty, uint256 _amount)\n        public\n        registeredBook(msg.sender)\n    {\n        _rebalanceFromBook(msg.sender, _counterparty, _amount);\n    }\n\n    /**\n     * @dev Rebalance collateral from `_mainParty` collateral book to specific bilateral position\n     *\n     * @notice Triggers only by contracts accepted to use collateral\n     */\n    function rebalanceTo(\n        address _mainParty,\n        address _counterparty,\n        uint256 _amount\n    ) public acceptedContract {\n        _rebalanceFromBook(_mainParty, _counterparty, _amount);\n    }\n\n    /**\n     * @dev Rebalance collateral from one bilateral position with `_fromParty` counterparty\n     * to another bilateral position with `_toParty` counterparty\n     */\n    function rebalanceFrom(\n        address _fromParty,\n        address _toParty,\n        uint256 _amount\n    ) public registeredBook(msg.sender) {\n        (\n            address _fromPartyA,\n            address _fromPartyB,\n            bool fromFlipped\n        ) = _checkAddresses(msg.sender, _fromParty);\n        (\n            address _toPartyA,\n            address _toPartyB,\n            bool toFlipped\n        ) = _checkAddresses(msg.sender, _toParty);\n\n        (\n            uint256 maxWidthdraw0,\n            uint256 maxWidthdraw1\n        ) = _calcMaxCollateralWidthdraw(_fromPartyA, _fromPartyB);\n\n        if (!fromFlipped) {\n            require(maxWidthdraw0 >= _amount, \"positionFrom uncovered\");\n            positions[_fromPartyA][_fromPartyB].lockedCollateralA -= _amount;\n        } else {\n            require(maxWidthdraw1 >= _amount, \"positionFrom uncovered\");\n            positions[_fromPartyA][_fromPartyB].lockedCollateralB -= _amount;\n        }\n\n        if (!toFlipped) {\n            positions[_toPartyA][_toPartyB].lockedCollateralA += _amount;\n        } else {\n            positions[_toPartyA][_toPartyB].lockedCollateralB += _amount;\n        }\n\n        // updatePositionState(_fromPartyA, _fromPartyB);\n        // updatePositionState(_toPartyA, _toPartyB);\n        // emit RebalancePositions\n    }\n\n    function rebalanceFromPositionToBook(\n        address _mainParty,\n        address _counterparty,\n        uint256 _amount\n    ) public acceptedContract registeredBook(_mainParty) {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            _mainParty,\n            _counterparty\n        );\n        (\n            uint256 maxWidthdraw0,\n            uint256 maxWidthdraw1\n        ) = _calcMaxCollateralWidthdraw(_partyA, _partyB);\n        Book storage book = books[_mainParty];\n\n        if (!flipped) {\n            require(maxWidthdraw0 >= _amount, \"positionFrom uncovered\");\n            positions[_partyA][_partyB].lockedCollateralA -= _amount;\n        } else {\n            require(maxWidthdraw1 >= _amount, \"positionFrom uncovered\");\n            positions[_partyA][_partyB].lockedCollateralB -= _amount;\n        }\n\n        book.lockedCollateral = book.lockedCollateral.sub(_amount);\n        book.independentAmount = book.independentAmount.add(_amount);\n    }\n\n    // TODO: Rebalance from position to book once position coverage more than 150%\n\n    /**\n     * @dev Triggers to lock unsettled collateral on a global book for selected currency.\n     * @param user User's address\n     * @param ccy Specified currency of the deal\n     * @param amount Amount of funds to be locked in Ccy for user\n     *\n     * @notice Callable only by Loan and linked LendingMarket\n     */\n    function useUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external acceptedContract {\n        exposedUnsettledCurrencies[user].add(ccy);\n        require(isCoveredUnsettled(user, ccy, amount), \"Not enough collateral\");\n\n        unsettledCollateral[user][ccy] = unsettledCollateral[user][ccy].add(\n            amount\n        );\n\n        emit UseUnsettledCollateral(user, ccy, amount);\n    }\n\n    /**\n     * @dev Triggers to lock collateral using ETH rate for selected currency.\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be locked in Ccy for counterparty A\n     * @param amount1 Amount of funds to be locked in Ccy for counterparty B\n     *\n     * @notice Callable only by Loan and linked LendingMarket\n     */\n    function useCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external acceptedContract {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            partyA,\n            partyB\n        );\n        exposedCurrencies[_partyA][_partyB].add(ccy);\n\n        if (!flipped) {\n            (uint256 amt0, uint256 amt1) = _calcCollateralForRebalance(\n                partyA,\n                partyB,\n                ccy,\n                amount0,\n                amount1,\n                isSettled\n            );\n\n            if (amt0 > 0) {\n                rebalanceTo(partyA, partyB, amt0);\n            }\n\n            if (amt1 > 0) {\n                rebalanceTo(partyB, partyA, amt1);\n            }\n        } else {\n            (uint256 amt0, uint256 amt1) = _calcCollateralForRebalance(\n                partyB,\n                partyA,\n                ccy,\n                amount1,\n                amount0,\n                isSettled\n            );\n\n            if (amt0 > 0) {\n                rebalanceTo(partyB, partyA, amt0);\n            }\n\n            if (amt1 > 0) {\n                rebalanceTo(partyA, partyB, amt1);\n            }\n        }\n\n        CcyNetting storage netting = ccyNettings[_partyA][_partyB][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                isSettled\n                    ? netting.party0PV = netting.party0PV.add(amount0)\n                    : netting.unsettled0PV = netting.unsettled0PV.add(amount0);\n            }\n            if (amount1 > 0) {\n                isSettled\n                    ? netting.party1PV = netting.party1PV.add(amount1)\n                    : netting.unsettled1PV = netting.unsettled1PV.add(amount1);\n            }\n        } else {\n            if (amount0 > 0) {\n                isSettled\n                    ? netting.party1PV = netting.party1PV.add(amount0)\n                    : netting.unsettled1PV = netting.unsettled1PV.add(amount0);\n            }\n            if (amount1 > 0) {\n                isSettled\n                    ? netting.party0PV = netting.party0PV.add(amount1)\n                    : netting.unsettled0PV = netting.unsettled0PV.add(amount1);\n            }\n        }\n\n        // updatePositionState(_partyA, _partyB);\n        emit UseCollateral(_partyA, _partyB, ccy, amount0, amount1, isSettled);\n    }\n\n    /**\n     * @dev Triggers to lock collateral using ETH rate for selected currency.\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be locked in Ccy for counterparty A\n     * @param amount1 Amount of funds to be locked in Ccy for counterparty B\n     *\n     * @notice Callable only by Loan and linked LendingMarket\n     */\n    function settleCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    ) external acceptedContract {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            partyA,\n            partyB\n        );\n\n        CcyNetting storage netting = ccyNettings[_partyA][_partyB][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                netting.unsettled0PV = netting.unsettled0PV.sub(amount0);\n                netting.party0PV = netting.party0PV.add(amount0);\n            }\n            if (amount1 > 0) {\n                netting.unsettled1PV = netting.unsettled1PV.sub(amount1);\n                netting.party1PV = netting.party1PV.add(amount1);\n            }\n        } else {\n            if (amount0 > 0) {\n                netting.unsettled1PV = netting.unsettled1PV.sub(amount0);\n                netting.party1PV = netting.party1PV.add(amount0);\n            }\n            if (amount1 > 0) {\n                netting.unsettled0PV = netting.unsettled0PV.sub(amount1);\n                netting.party0PV = netting.party0PV.add(amount1);\n            }\n        }\n\n        // updatePositionState(_partyA, _partyB);\n        emit SettleCollateral(_partyA, _partyB, ccy, amount0, amount1);\n    }\n\n    /**\n     * @dev Triggers to calculate total unsettled exposure across all currencies\n     * @param _user User's address\n     */\n    function getTotalUnsettledExp(address _user) public view returns (uint256) {\n        uint256 totalExpInETH = _netTotalUnsettledAndHypotheticalPV(\n            _user,\n            \"\",\n            0\n        );\n\n        return totalExpInETH;\n    }\n\n    /**\n     * @dev Triggers to calculate netted exposures across all currencies with applied haircuts\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     */\n    function getNetAndTotalPV(address party0, address party1)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        (address _party0, address _party1, ) = _checkAddresses(party0, party1);\n        (\n            uint256 net0,\n            uint256 net1,\n            uint256 total0,\n            uint256 total1\n        ) = _netTotalAndHypotheticalPV(_party0, _party1, \"\", 0, 0, false);\n\n        return (net0, net1, total0, total1);\n    }\n\n    /**\n     * @dev Triggers to check if unsettled collateral exposure covered more that 150% from a global collateral book of `_user`.\n     * @param _user User's ethereum address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _unsettledExp Additional exposure to lock into unsettled exposure\n     */\n    function isCoveredUnsettled(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) public view returns (bool) {\n        (uint256 coverage, ) = _calculateUnsettledCoverageAndTotalExposure(\n            _user,\n            _ccy,\n            _unsettledExp\n        );\n        return coverage >= MARGINLEVEL;\n    }\n\n    /**\n     * @dev Triggers to check if collateral covered more that 150%.\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _party0PV Counterparty A additional present value\n     * @param _party1PV Counterparty B additional present value\n     */\n    function isCovered(\n        address party0,\n        address party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) public view returns (bool, bool) {\n        (address _party0, address _party1, bool flipped) = _checkAddresses(\n            party0,\n            party1\n        );\n\n        if (!flipped) {\n            (uint256 cover0, uint256 cover1) = _calculateCoverage(\n                _party0,\n                _party1,\n                _ccy,\n                _party0PV,\n                _party1PV,\n                _isSettled\n            );\n            return (cover0 >= MARGINLEVEL, cover1 >= MARGINLEVEL);\n        } else {\n            (uint256 cover0, uint256 cover1) = _calculateCoverage(\n                _party1,\n                party0,\n                _ccy,\n                _party1PV,\n                _party0PV,\n                _isSettled\n            );\n            return (cover1 >= MARGINLEVEL, cover0 >= MARGINLEVEL);\n        }\n    }\n\n    /**\n     * @dev Triggers to get maximum amount of ETH available to widthdraw from `_user` collateral book.\n     * @param _user User's address\n     */\n    function getMaxCollateralBookWidthdraw(address _user)\n        public\n        view\n        returns (uint256)\n    {\n        (uint256 maxWidthdraw, ) = _calcMaxCollateralWidthdrawFromBook(_user);\n\n        return maxWidthdraw;\n    }\n\n    /**\n     * @dev Triggers to get maximum amount of ETH available to\n     * widthdraw from bilateral position between `party0` and `_party1`.\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     */\n    function getMaxCollateralWidthdraw(address _party0, address _party1)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        (address _partyA, address _partyB, ) = _checkAddresses(\n            _party0,\n            _party1\n        );\n        (\n            uint256 maxWidthdraw0,\n            uint256 maxWidthdraw1\n        ) = _calcMaxCollateralWidthdraw(_partyA, _partyB);\n\n        return (maxWidthdraw0, maxWidthdraw1);\n    }\n\n    /**\n     * @dev Triggers to get coverage of the global collateral book against all unsettled exposure.\n     * @param _user User's address\n     */\n    function getUnsettledCoverage(address _user) public view returns (uint256) {\n        (uint256 coverage, ) = _calculateUnsettledCoverageAndTotalExposure(\n            _user,\n            \"\",\n            0\n        );\n        return coverage;\n    }\n\n    /**\n     * @dev Triggers to get coverage of the global collateral book against all unsettled exposure.\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     */\n    function getRebalanceCollateralAmounts(address party0, address party1)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        (, , bool flipped) = _checkAddresses(party0, party1);\n\n        if (!flipped) {\n            (uint256 amt0, uint256 amt1) = _calcCollateralForRebalance(\n                party0,\n                party1,\n                \"\",\n                0,\n                0,\n                false\n            );\n            return (amt0, amt1);\n        } else {\n            (uint256 amt0, uint256 amt1) = _calcCollateralForRebalance(\n                party1,\n                party0,\n                \"\",\n                0,\n                0,\n                false\n            );\n            return (amt1, amt0);\n        }\n    }\n\n    /**\n     * @dev Triggers to get bilateral position collateral coverage.\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     */\n    function getCoverage(address party0, address party1)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        (address _party0, address _party1, bool flipped) = _checkAddresses(\n            party0,\n            party1\n        );\n\n        if (!flipped) {\n            (uint256 cover0, uint256 cover1) = _calculateCoverage(\n                _party0,\n                _party1,\n                \"\",\n                0,\n                0,\n                false\n            );\n            return (cover0, cover1);\n        } else {\n            (uint256 cover0, uint256 cover1) = _calculateCoverage(\n                _party0,\n                _party1,\n                \"\",\n                0,\n                0,\n                false\n            );\n            return (cover1, cover0);\n        }\n    }\n\n    /**\n     * @dev Triggers to reduce the amount of unsettled exposure in specific `ccy` from a global collateral book of `user`\n     * @param user User's ETH address\n     * @param ccy Specified currency of the deal\n     * @param amount Amount of funds to be unlocked from unsettled exposure in specified ccy\n     *\n     * @notice Callable only by smart contracts allowed to use collateral\n     */\n    function releaseUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) external acceptedContract {\n        unsettledCollateral[user][ccy] = unsettledCollateral[user][ccy].sub(\n            amount\n        );\n\n        if (unsettledCollateral[user][ccy] == 0) {\n            exposedUnsettledCurrencies[user].remove(ccy);\n        }\n\n        emit ReleaseUnsettled(user, ccy, amount);\n    }\n\n    /**\n     * @dev Triggers to reduce PV for specific `ccy` in bilateral position between `partyA` and `partyB`\n     * @param partyA Counterparty A address\n     * @param partyB Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param amount0 Amount of funds to be removed in CcyNetting for counterparty A\n     * @param amount1 Amount of funds to be removed in CcyNetting for counterparty B\n     *\n     * @notice Callable only by smart contracts allowed to use collateral\n     */\n    function releaseCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) external acceptedContract {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            partyA,\n            partyB\n        );\n        require(\n            exposedCurrencies[_partyA][_partyB].contains(ccy),\n            \"non-used ccy\"\n        );\n        CcyNetting storage netting = ccyNettings[_partyA][_partyB][ccy];\n\n        if (!flipped) {\n            if (amount0 > 0) {\n                isSettled\n                    ? netting.party0PV = netting.party0PV.sub(amount0)\n                    : netting.unsettled0PV = netting.unsettled0PV.sub(amount0);\n            }\n            if (amount1 > 0) {\n                isSettled\n                    ? netting.party1PV = netting.party1PV.sub(amount1)\n                    : netting.unsettled1PV = netting.unsettled1PV.sub(amount1);\n            }\n        } else {\n            if (amount0 > 0) {\n                isSettled\n                    ? netting.party1PV = netting.party1PV.sub(amount0)\n                    : netting.unsettled1PV = netting.unsettled1PV.sub(amount0);\n            }\n            if (amount1 > 0) {\n                isSettled\n                    ? netting.party0PV = netting.party0PV.sub(amount1)\n                    : netting.unsettled0PV = netting.unsettled0PV.sub(amount1);\n            }\n        }\n\n        // updatePositionState(_partyA, _partyB);\n        emit Release(_partyA, _partyB, ccy, amount0, amount1);\n    }\n\n    /**\n     * @dev Triggers to withdraw collateral from independent collateral amount in user's book\n     * @param _amt Amount of collateral to withdraw\n     *\n     * @notice If requested more that independent amount withdraw all available collateral not used\n     */\n    function withdraw(uint256 _amt) public registeredBook(msg.sender) {\n        Book storage book = books[msg.sender];\n        (uint256 maxWidthdraw, ) = _calcMaxCollateralWidthdrawFromBook(\n            msg.sender\n        );\n\n        // if (totalUnsettledExp == 0) {\n        //     maxWidthdraw = book.independentAmount;\n        // }\n\n        if (_amt > maxWidthdraw) {\n            book.independentAmount = book.independentAmount.sub(maxWidthdraw);\n            msg.sender.transfer(maxWidthdraw);\n            emit Withdraw(msg.sender, maxWidthdraw);\n        } else {\n            book.independentAmount = book.independentAmount.sub(_amt);\n            msg.sender.transfer(_amt);\n            emit Withdraw(msg.sender, _amt);\n        }\n    }\n\n    /**\n     * @dev Triggers to withdraw collateral from bilateral position between `msg.sender` and `_counterparty`\n     * @param _counterparty Counterparty address in bilateral position\n     * @param _amt Amount of collateral to withdraw\n     *\n     * @notice If requested more that independent amount withdraw all available collateral not used\n     */\n    function withdrawFrom(address _counterparty, uint256 _amt)\n        public\n        registeredBook(msg.sender)\n    {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            msg.sender,\n            _counterparty\n        );\n        (\n            uint256 maxWidthdraw0,\n            uint256 maxWidthdraw1\n        ) = _calcMaxCollateralWidthdraw(_partyA, _partyB);\n\n        Position storage position = positions[_partyA][_partyB];\n        uint256 withdrawAmt;\n\n        if (!flipped) {\n            withdrawAmt = maxWidthdraw0 > _amt ? _amt : maxWidthdraw0;\n            position.lockedCollateralA -= withdrawAmt;\n            emit PositionWithdraw(_partyA, _partyB, withdrawAmt, 0);\n        } else {\n            withdrawAmt = maxWidthdraw1 > _amt ? _amt : maxWidthdraw1;\n            position.lockedCollateralB -= withdrawAmt;\n            emit PositionWithdraw(_partyA, _partyB, 0, withdrawAmt);\n        }\n\n        books[msg.sender].lockedCollateral -= withdrawAmt; // save deposited collateral in global book\n        msg.sender.transfer(withdrawAmt);\n    }\n\n    /**\n     * @dev Triggers to update PV value in currency for bilateral position\n     * changes present value in native currency, without exchange rate conversion\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     * @param ccy Specified currency of the deal\n     * @param prevPV0 Previous present value to be substracted from total exposure for counterparty A\n     * @param prevPV1 Previous present value to be substracted from total exposure for counterparty B\n     * @param currentPV0 Current present value to be added to total exposure for counterparty A\n     * @param currentPV1 Current present value to be added to total exposure for counterparty B\n     *\n     * @notice Trigers only be Loan contract\n     */\n    function updatePV(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) external acceptedContract {\n        (address _party0, address _party1, bool flipped) = _checkAddresses(\n            party0,\n            party1\n        );\n\n        CcyNetting storage netting = ccyNettings[_party0][_party1][ccy];\n\n        if (!flipped) {\n            if (currentPV0 > 0) {\n                netting.party0PV = netting.party0PV.sub(prevPV0).add(\n                    currentPV0\n                );\n            }\n            if (currentPV1 > 0) {\n                netting.party1PV = netting.party1PV.sub(prevPV1).add(\n                    currentPV1\n                );\n            }\n        } else {\n            if (currentPV0 > 0) {\n                netting.party1PV = netting.party1PV.sub(prevPV0).add(\n                    currentPV0\n                );\n            }\n            if (currentPV1 > 0) {\n                netting.party0PV = netting.party0PV.sub(prevPV1).add(\n                    currentPV1\n                );\n            }\n        }\n        // updatePositionState(_party0, _party1);\n\n        // emit UpdatePV(_party0, _party1, ccy, prevPV0, prevPV1, currentPV0, currentPV1);\n    }\n\n    /**\n     * @dev Triggers to liquidate unsettled collateral from borrower's global collateral book to lender's collateral book\n     * @param from Address for liquidating collateral from\n     * @param to Address for sending collateral to\n     * @param ccy Currency to use rate to ETH for\n     * @param amount Liquidation amount in Ccy\n     *\n     * @notice Trigers only be Loan contract\n     */\n    function liquidateUnsettled(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 amount\n    ) external {\n        require(collateralUsers.contains(msg.sender), \"incorrect liquidator\");\n        uint256 amt = currencyController.convertToETH(ccy, amount);\n\n        unsettledCollateral[from][ccy].sub(amount);\n\n        books[from].independentAmount -= amt; // save deposited collateral in global book\n        books[to].independentAmount += amt; // save deposited collateral in global book\n\n        emit LiquidateUnsettled(from, to, ccy, amount, amt);\n    }\n\n    /**\n     * @dev Triggers to liquidate collateral from borrower to lender\n     * @param from Address for liquidating collateral from\n     * @param to Address for sending collateral to\n     * @param ccy Currency to use rate to ETH for\n     * @param amount Liquidation amount in Ccy\n     *\n     * @notice Trigers only be Loan contract\n     */\n    function liquidate(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 amount\n    ) external {\n        require(collateralUsers.contains(msg.sender), \"incorrect liquidator\");\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            from,\n            to\n        );\n        uint256 amt = currencyController.convertToETH(ccy, amount);\n        // TODO: rebalance required amount of collateral, transfer excess into global book\n        Position storage position = positions[_partyA][_partyB];\n\n        if (!flipped) {\n            require(\n                position.lockedCollateralA >= amt,\n                \"Liquidation amount not enough\"\n            );\n            position.lockedCollateralA -= amt;\n            position.lockedCollateralB += amt;\n        } else {\n            require(\n                position.lockedCollateralB >= amt,\n                \"Liquidation amount not enough\"\n            );\n            position.lockedCollateralB -= amt;\n            position.lockedCollateralA += amt;\n        }\n\n        books[from].lockedCollateral -= amt; // save deposited collateral in global book\n        books[to].lockedCollateral += amt; // save deposited collateral in global book\n\n        emit Liquidate(from, to, amt);\n    }\n\n    function getCollateralBook(address addr) public view returns (Book memory) {\n        return books[addr];\n    }\n\n    function checkRegisteredBook(address addr) public view returns (bool) {\n        return isRegistered[addr];\n    }\n\n    struct BilateralPositionLocalVars {\n        address partyA;\n        address partyB;\n        uint256 lockedCollateralA;\n        uint256 lockedCollateralB;\n        uint256 maxCcy;\n        bytes32[] currencies;\n        uint256[] unsettled0PVs;\n        uint256[] unsettled1PVs;\n        uint256[] party0PVs;\n        uint256[] party1PVs;\n        uint256[] netPayments;\n    }\n\n    function getBilateralPosition(address partyA, address partyB)\n        public\n        view\n        returns (Position memory)\n    {\n        (address _partyA, address _partyB, ) = _checkAddresses(partyA, partyB);\n        Position memory position = positions[_partyA][_partyB];\n\n        return position;\n    }\n\n    function getCcyExposures(\n        address partyA,\n        address partyB,\n        bytes32 ccy\n    ) public view returns (CcyNetting memory) {\n        (address _partyA, address _partyB, ) = _checkAddresses(partyA, partyB);\n\n        require(\n            exposedCurrencies[_partyA][_partyB].contains(ccy),\n            \"non-used ccy\"\n        );\n\n        CcyNetting memory netting = ccyNettings[_partyA][_partyB][ccy];\n\n        return netting;\n    }\n\n    function getExposedCurrencies(address partyA, address partyB)\n        public\n        view\n        returns (bytes32[] memory)\n    {\n        (address _partyA, address _partyB, ) = _checkAddresses(partyA, partyB);\n        EnumerableSet.Bytes32Set storage expCcy = exposedCurrencies[_partyA][\n            _partyB\n        ];\n\n        uint256 numCcy = expCcy.length();\n        bytes32[] memory currencies = new bytes32[](numCcy);\n\n        for (uint256 i = 0; i < numCcy; i++) {\n            bytes32 ccy = expCcy.at(i);\n            currencies[i] = ccy;\n        }\n\n        return currencies;\n    }\n\n    // =========== INTERNAL FUNCTIONS ===========\n\n    /**\n     * @dev Triggers internaly to store new collateral book\n     * @param id Gateway token ID for KYC'd addresses\n     */\n    function _register(uint256 id) internal {\n        Book memory book;\n\n        if (id != 0) {\n            book.gatewayTokenId = id;\n        }\n\n        if (msg.value > 0) {\n            book.independentAmount = msg.value;\n        }\n\n        isRegistered[msg.sender] = true;\n        books[msg.sender] = book;\n\n        emit Register(msg.sender, id, msg.value);\n    }\n\n    /**\n     * @dev Triggers internally to check if counterparty addresses are correct, modifies the order if needed.\n     * @param party0 Counterparty A address\n     * @param party1 Counterparty B address\n     */\n    function _checkAddresses(address party0, address party1)\n        internal\n        pure\n        returns (\n            address,\n            address,\n            bool\n        )\n    {\n        require(party0 != party1, \"Identical addresses\");\n        (address _party0, address _party1) = party0 < party1\n            ? (party0, party1)\n            : (party1, party0);\n        require(_party0 != address(0), \"Invalid address\");\n        require(_party1 != address(0), \"Invalid counterparty\");\n\n        if (_party0 != party0) {\n            return (_party0, _party1, true);\n        } else {\n            return (_party0, _party1, false);\n        }\n    }\n\n    /**\n     * @dev Rebalance collateral from `_mainParty` collateral book to specific bilateral position\n     */\n    function _rebalanceFromBook(\n        address _mainParty,\n        address _counterparty,\n        uint256 _amount\n    ) internal {\n        (address _partyA, address _partyB, bool flipped) = _checkAddresses(\n            _mainParty,\n            _counterparty\n        );\n        Book storage book = books[_mainParty];\n\n        (uint256 maxWidthdraw, ) = _calcMaxCollateralWidthdrawFromBook(\n            _mainParty\n        );\n        require(maxWidthdraw >= _amount, \"Invalid rebalance amount\");\n\n        book.independentAmount = book.independentAmount.sub(_amount); // includes overflow checks\n        book.lockedCollateral = book.lockedCollateral.add(_amount);\n\n        if (!flipped) {\n            positions[_partyA][_partyB].lockedCollateralA += _amount;\n            emit Rebalance(_partyA, _partyB, _amount, 0);\n        } else {\n            positions[_partyA][_partyB].lockedCollateralB += _amount;\n            emit Rebalance(_partyA, _partyB, 0, _amount);\n        }\n    }\n\n    struct NetAndTotalPVLocalVars {\n        uint256 exp0;\n        uint256 exp1;\n        uint256 unsettledExp0;\n        uint256 unsettledExp1;\n        int256 exchangeRate;\n        uint256 totalUnsettledPV0inETH;\n        uint256 totalUnsettledPV1inETH;\n        uint256 totalPV0inETH;\n        uint256 totalPV1inETH;\n        uint256 totalCombinedPV0inETH;\n        uint256 totalCombinedPV1inETH;\n        uint256 totalHaircutPV0;\n        uint256 totalHaircutPV1;\n        uint256 haircutRatio;\n        uint256 expDiff0;\n        uint256 expDiff1;\n        uint256 netExp0;\n        uint256 netExp1;\n        CcyNetting netting;\n        uint256 maxCcy;\n    }\n\n    /**\n     * @dev Triggers to calculate netted exposures across all currencies with applied haircuts.\n     * Also used to calculate hypothetical Net PV with additional exposure in specific `_ccy`\n     * @param _party0 Counterparty A address\n     * @param _party1 Counterparty B address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _party0PV Counterparty A additional present value\n     * @param _party1PV Counterparty B additional present value\n     */\n    function _netTotalAndHypotheticalPV(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool isSettled\n    )\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        EnumerableSet.Bytes32Set storage expCcy = exposedCurrencies[_party0][\n            _party1\n        ];\n        NetAndTotalPVLocalVars memory vars;\n\n        vars.maxCcy = expCcy.length();\n\n        for (uint256 i = 0; i < vars.maxCcy; i++) {\n            bytes32 ccy = expCcy.at(i);\n            vars.netting = ccyNettings[_party0][_party1][ccy];\n            vars.exchangeRate = currencyController.getLastETHPrice(ccy);\n\n            if (_ccy == ccy) {\n                if (isSettled) {\n                    vars.exp0 = (vars.netting.party0PV.add(_party0PV))\n                        .mul(uint256(vars.exchangeRate))\n                        .div(1e18);\n                    vars.exp1 = (vars.netting.party1PV.add(_party1PV))\n                        .mul(uint256(vars.exchangeRate))\n                        .div(1e18);\n                } else {\n                    vars.unsettledExp0 = vars\n                        .netting\n                        .unsettled0PV\n                        .add(_party0PV)\n                        .mul(uint256(vars.exchangeRate))\n                        .div(1e18);\n                    vars.unsettledExp1 = vars\n                        .netting\n                        .unsettled1PV\n                        .add(_party1PV)\n                        .mul(uint256(vars.exchangeRate))\n                        .div(1e18);\n                }\n            } else {\n                vars.unsettledExp0 = vars\n                    .netting\n                    .unsettled0PV\n                    .mul(uint256(vars.exchangeRate))\n                    .div(1e18);\n                vars.unsettledExp1 = vars\n                    .netting\n                    .unsettled1PV\n                    .mul(uint256(vars.exchangeRate))\n                    .div(1e18);\n\n                vars.exp0 = vars\n                    .netting\n                    .party0PV\n                    .mul(uint256(vars.exchangeRate))\n                    .div(1e18);\n                vars.exp1 = vars\n                    .netting\n                    .party1PV\n                    .mul(uint256(vars.exchangeRate))\n                    .div(1e18);\n            }\n\n            vars.totalUnsettledPV0inETH = vars.totalUnsettledPV0inETH.add(\n                vars.unsettledExp0\n            );\n            vars.totalUnsettledPV1inETH = vars.totalUnsettledPV1inETH.add(\n                vars.unsettledExp1\n            );\n\n            vars.haircutRatio = currencyController.getHaircut(ccy);\n\n            vars.totalPV0inETH = vars.totalPV0inETH.add(vars.exp0);\n            vars.totalPV1inETH = vars.totalPV1inETH.add(vars.exp1);\n\n            vars.totalHaircutPV0 = vars.totalHaircutPV0.add(\n                vars.exp0.mul(vars.haircutRatio).div(BP)\n            );\n            vars.totalHaircutPV1 = vars.totalHaircutPV1.add(\n                vars.exp1.mul(vars.haircutRatio).div(BP)\n            );\n        }\n\n        vars.expDiff0 = vars.totalPV0inETH >= vars.totalHaircutPV1\n            ? vars.totalPV0inETH.sub(vars.totalHaircutPV1)\n            : 0;\n        vars.expDiff1 = vars.totalPV1inETH >= vars.totalHaircutPV0\n            ? vars.totalPV1inETH.sub(vars.totalHaircutPV0)\n            : 0;\n\n        (vars.netExp0, vars.netExp1) = vars.expDiff0 > vars.expDiff1\n            ? (\n                vars.expDiff0.sub(vars.expDiff1).add(\n                    vars.totalUnsettledPV0inETH\n                ),\n                vars.totalUnsettledPV1inETH\n            )\n            : (\n                vars.totalUnsettledPV0inETH,\n                vars.expDiff1.sub(vars.expDiff0).add(\n                    vars.totalUnsettledPV1inETH\n                )\n            );\n\n        vars.totalCombinedPV0inETH = vars.totalUnsettledPV0inETH.add(\n            vars.totalPV0inETH\n        );\n        vars.totalCombinedPV1inETH = vars.totalUnsettledPV1inETH.add(\n            vars.totalPV1inETH\n        );\n\n        return (\n            vars.netExp0,\n            vars.netExp1,\n            vars.totalCombinedPV0inETH,\n            vars.totalCombinedPV1inETH\n        );\n    }\n\n    struct CollateralReqLocalVars {\n        uint256 net0;\n        uint256 net1;\n        uint256 total0;\n        uint256 total1;\n        uint256 minMarginRatio;\n        uint256 minMarginReq0;\n        uint256 minMarginReq1;\n        uint256 netCover0;\n        uint256 netCover1;\n        uint256 req0;\n        uint256 req1;\n    }\n\n    /**\n     * @dev Triggers to calculate collateral coverage for bilateral position with/without additional PV\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `cover0`, `cover1` uint256 coverage percentages in basis point per counterparty\n     */\n    // TODO: NOW\n    function _calculateCollateralRequirements(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) internal view returns (uint256, uint256) {\n        CollateralReqLocalVars memory vars;\n\n        (\n            vars.net0,\n            vars.net1,\n            vars.total0,\n            vars.total1\n        ) = _netTotalAndHypotheticalPV(\n            _party0,\n            _party1,\n            _ccy,\n            _party0PV,\n            _party1PV,\n            _isSettled\n        );\n\n        vars.minMarginRatio = currencyController.getMinMargin(\"ETH\");\n        vars.minMarginReq0 = vars.total0.mul(vars.minMarginRatio).div(BP);\n        vars.minMarginReq1 = vars.total1.mul(vars.minMarginRatio).div(BP);\n\n        if (vars.net0 > 0) {\n            vars.netCover0 = (vars.net0.mul(MARGINLEVEL)).div(BP);\n            vars.req0 = vars.minMarginReq0 > vars.netCover0\n                ? vars.minMarginReq0\n                : vars.net0;\n        } else {\n            vars.req0 = vars.minMarginReq0;\n        }\n\n        if (vars.net1 > 0) {\n            vars.netCover1 = (vars.net1.mul(MARGINLEVEL)).div(BP);\n            vars.req1 = vars.minMarginReq1 > vars.netCover1\n                ? vars.minMarginReq1\n                : vars.net1;\n        } else {\n            vars.req1 = vars.minMarginReq1;\n        }\n\n        return (vars.req0, vars.req1);\n    }\n\n    struct CoverageCalcLocalVars {\n        uint256 req0;\n        uint256 req1;\n        uint256 cover0;\n        uint256 cover1;\n    }\n\n    /**\n     * @dev Triggers to calculate collateral coverage for bilateral position with/without additional PV\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `cover0`, `cover1` uint256 coverage percentages in basis point per counterparty\n     */\n    // TODO: NOW\n    function _calculateCoverage(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _party0PV,\n        uint256 _party1PV,\n        bool _isSettled\n    ) internal view returns (uint256, uint256) {\n        CoverageCalcLocalVars memory vars;\n\n        (vars.req0, vars.req1) = _calculateCollateralRequirements(\n            _party0,\n            _party1,\n            _ccy,\n            _party0PV,\n            _party1PV,\n            _isSettled\n        );\n\n        Position memory position = positions[_party0][_party1];\n\n        if (vars.req0 > 0) {\n            vars.cover0 = (PCT.mul(position.lockedCollateralA)).div(vars.req0);\n        }\n\n        if (vars.req1 > 0) {\n            vars.cover1 = (PCT.mul(position.lockedCollateralB)).div(vars.req1);\n        }\n\n        return (vars.cover0, vars.cover1);\n    }\n\n    struct MaxCollateralWidthdrawLocalVars {\n        uint256 req0;\n        uint256 req1;\n        uint256 targetReq0;\n        uint256 targetReq1;\n        uint256 delta0;\n        uint256 delta1;\n        uint256 maxWidthdraw0;\n        uint256 maxWidthdraw1;\n    }\n\n    /**\n     * @dev Triggers to calculate max collateral amount available to widthdraw from bilateral position\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `maxWidthdraw0`, `maxWidthdraw1` uint256 available for widthdraw collateral amounts\n     */\n    // TODO: NOW\n    function _calcMaxCollateralWidthdraw(address _party0, address _party1)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        MaxCollateralWidthdrawLocalVars memory vars;\n\n        (vars.req0, vars.req1) = _calculateCollateralRequirements(\n            _party0,\n            _party1,\n            \"\",\n            0,\n            0,\n            false\n        );\n\n        vars.targetReq0 = vars.req0.mul(MARGINLEVEL).div(BP);\n        vars.targetReq1 = vars.req1.mul(MARGINLEVEL).div(BP);\n\n        Position memory position = positions[_party0][_party1];\n\n        if (position.lockedCollateralA > 0 && vars.targetReq0 > 0) {\n            vars.maxWidthdraw0 = position.lockedCollateralA > vars.targetReq0\n                ? position.lockedCollateralA.sub(vars.targetReq0)\n                : 0;\n        } else {\n            vars.maxWidthdraw0 = position.lockedCollateralA;\n        }\n\n        if (position.lockedCollateralB > 0 && vars.targetReq1 > 0) {\n            vars.maxWidthdraw1 = position.lockedCollateralB > vars.targetReq1\n                ? position.lockedCollateralB.sub(vars.targetReq1)\n                : 0;\n        } else {\n            vars.maxWidthdraw1 = position.lockedCollateralB;\n        }\n\n        return (vars.maxWidthdraw0, vars.maxWidthdraw1);\n    }\n\n    struct RequiredCollateralForRebalanceLocalVars {\n        uint256 req0;\n        uint256 req1;\n        uint256 targetReq0;\n        uint256 targetReq1;\n        uint256 cover0;\n        uint256 cover1;\n        uint256 targetLocked0;\n        uint256 targetLocked1;\n        uint256 reqCollateral0;\n        uint256 reqCollateral1;\n    }\n\n    /**\n     * @dev Triggers to calculate collateral amount in ETH to rebalance to keep collateral coverage at least on MARGINLEVEL\n     * @param _party0 Counterparty A address\n     * @param _party0 Counterparty B address\n     *\n     * @return `amt0`, `amt1` uint256 amount of ETH to be rebalanced from parties collateral books\n     */\n    function _calcCollateralForRebalance(\n        address _party0,\n        address _party1,\n        bytes32 _ccy,\n        uint256 _amount0,\n        uint256 _amount1,\n        bool _isSettled\n    ) internal view returns (uint256, uint256) {\n        RequiredCollateralForRebalanceLocalVars memory vars;\n\n        (vars.req0, vars.req1) = _calculateCollateralRequirements(\n            _party0,\n            _party1,\n            _ccy,\n            _amount0,\n            _amount1,\n            _isSettled\n        );\n\n        vars.targetReq0 = vars.req0.mul(MARGINLEVEL).div(BP);\n        vars.targetReq1 = vars.req1.mul(MARGINLEVEL).div(BP);\n\n        Position memory position = positions[_party0][_party1];\n\n        if (position.lockedCollateralA > 0 && vars.targetReq0 > 0) {\n            vars.reqCollateral0 = position.lockedCollateralA > vars.targetReq0\n                ? 0\n                : vars.targetReq0.sub(position.lockedCollateralA);\n        } else {\n            vars.reqCollateral0 = vars.targetReq0;\n        }\n\n        if (position.lockedCollateralB > 0 && vars.targetReq1 > 0) {\n            vars.reqCollateral1 = position.lockedCollateralB > vars.targetReq1\n                ? 0\n                : vars.targetReq1.sub(position.lockedCollateralB);\n        } else {\n            vars.reqCollateral1 = vars.targetReq1;\n        }\n\n        return (vars.reqCollateral0, vars.reqCollateral1);\n    }\n\n    struct NetUnsettledExpLocalVars {\n        uint256 totalExp;\n        uint256 ccyExp;\n        uint256 ccyExpInETH;\n        int256 exchangeRate;\n        uint256 maxCcy;\n    }\n\n    /**\n     * @dev Triggers to calculate total unsettled exposure across all currencies for a global collateral book.\n     * Also used to calculate hypothetical Net PV with additional exposure in specific `_ccy`\n     * @param _user User's ethereum address\n     * @param _ccy Currency to calculate additional PV for\n     * @param _unsettledExp Additional exposure to lock into unsettled exposure\n     */\n    function _netTotalUnsettledAndHypotheticalPV(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) internal view returns (uint256) {\n        EnumerableSet.Bytes32Set storage expCcy = exposedUnsettledCurrencies[\n            _user\n        ];\n\n        NetUnsettledExpLocalVars memory vars;\n\n        vars.maxCcy = expCcy.length();\n\n        for (uint256 i = 0; i < vars.maxCcy; i++) {\n            bytes32 ccy = expCcy.at(i);\n            vars.ccyExp = unsettledCollateral[_user][ccy];\n            vars.exchangeRate = currencyController.getLastETHPrice(ccy);\n\n            if (_ccy == ccy) {\n                vars.ccyExpInETH = (vars.ccyExp.add(_unsettledExp))\n                    .mul(uint256(vars.exchangeRate))\n                    .div(1e18);\n            } else {\n                vars.ccyExpInETH = vars\n                    .ccyExp\n                    .mul(uint256(vars.exchangeRate))\n                    .div(1e18);\n            }\n\n            vars.totalExp = vars.totalExp.add(vars.ccyExpInETH);\n        }\n\n        return vars.totalExp;\n    }\n\n    struct UnsettledCoverageLocalVars {\n        uint256 totalExpInETH;\n        uint256 coverage;\n    }\n\n    function _calculateUnsettledCoverageAndTotalExposure(\n        address _user,\n        bytes32 _ccy,\n        uint256 _unsettledExp\n    ) internal view returns (uint256, uint256) {\n        UnsettledCoverageLocalVars memory vars;\n\n        vars.totalExpInETH = _netTotalUnsettledAndHypotheticalPV(\n            _user,\n            _ccy,\n            _unsettledExp\n        );\n\n        Book memory book = books[_user];\n\n        if (vars.totalExpInETH > 0) {\n            vars.coverage = (PCT.mul(book.independentAmount)).div(\n                vars.totalExpInETH\n            );\n        } else {\n            return (0, vars.totalExpInETH);\n        }\n\n        return (vars.coverage, vars.totalExpInETH);\n    }\n\n    struct MaxCollateralBookWidthdrawLocalVars {\n        uint256 totalExpInETH;\n        uint256 coverage;\n        uint256 delta;\n        uint256 maxWidthdraw;\n    }\n\n    /**\n     * @dev Triggers to calculate maximum amount of ETH available to widthdraw from `_user` collateral book\n     * @param _user User's ethereum address\n     *\n     * @return `maxWidthdraw` max widthdrawable amount of ETH\n     */\n    function _calcMaxCollateralWidthdrawFromBook(address _user)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        MaxCollateralBookWidthdrawLocalVars memory vars;\n\n        (\n            vars.coverage,\n            vars.totalExpInETH\n        ) = _calculateUnsettledCoverageAndTotalExposure(_user, \"\", 0);\n\n        Book memory book = books[_user];\n\n        if (vars.coverage > MARGINLEVEL) {\n            vars.delta = vars.coverage.sub(MARGINLEVEL);\n\n            vars.maxWidthdraw = book.independentAmount.mul(vars.delta).div(\n                vars.coverage\n            );\n        } else if (vars.totalExpInETH == 0) {\n            return (book.independentAmount, vars.totalExpInETH);\n        } else {\n            return (0, vars.totalExpInETH);\n        }\n\n        return (vars.maxWidthdraw, vars.totalExpInETH);\n    }\n}\n"
    },
    "contracts/mocks/PaymentAggregatorCallerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../ProtocolTypes.sol\";\nimport \"../interfaces/IPaymentAggregator.sol\";\n\ncontract PaymentAggregatorCallerMock is ProtocolTypes {\n    IPaymentAggregator public paymentAggregator;\n\n    constructor(address _paymentAggregator) public {\n        paymentAggregator = IPaymentAggregator(_paymentAggregator);\n    }\n\n    function registerPayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] memory timestamps,\n        uint256[] memory payments0,\n        uint256[] memory payments1\n    ) public {\n        paymentAggregator.registerPayments(\n            party0,\n            party1,\n            ccy,\n            dealId,\n            timestamps,\n            payments0,\n            payments1\n        );\n    }\n\n    function removePayments(\n        address party0,\n        address party1,\n        bytes32 ccy,\n        bytes32 dealId,\n        uint256[] calldata timestamps,\n        uint256[] calldata payments0,\n        uint256[] calldata payments1\n    ) public {\n        paymentAggregator.removePayments(\n            party0,\n            party1,\n            ccy,\n            dealId,\n            timestamps,\n            payments0,\n            payments1\n        );\n    }\n\n    function verifyPayment(\n        address counterparty,\n        bytes32 ccy,\n        uint256 timestamp,\n        uint256 payment,\n        bytes32 settlementId\n    ) public {\n        paymentAggregator.verifyPayment(\n            msg.sender,\n            counterparty,\n            ccy,\n            timestamp,\n            payment,\n            settlementId\n        );\n    }\n}\n"
    },
    "contracts/mocks/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV2V3Interface.sol\";\nimport \"../ProtocolTypes.sol\";\n\n/**\n * @title MockV3Aggregator\n * @notice Based on the FluxAggregator contract\n * @notice Use this contract when you need to test\n * other contract's ability to read data from an\n * aggregator contract, but how the aggregator got\n * its answer is unimportant\n */\ncontract MockV3Aggregator is AggregatorV2V3Interface, ProtocolTypes {\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    uint256 public constant override version = 0;\n    address public owner;\n\n    bytes32 public priceFeedCcy;\n    uint8 public override decimals;\n    int256 public override latestAnswer;\n    uint256 public override latestTimestamp;\n    uint256 public override latestRound;\n\n    mapping(uint256 => int256) public override getAnswer;\n    mapping(uint256 => uint256) public override getTimestamp;\n    mapping(uint256 => uint256) private getStartedAt;\n\n    constructor(\n        uint8 _decimals,\n        bytes32 _ccy,\n        int256 _initialAnswer\n    ) public {\n        owner = msg.sender;\n        priceFeedCcy = _ccy;\n        decimals = _decimals;\n        updateAnswer(_initialAnswer);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Sets owner of the controller market.\n     * @param _owner Address of new owner\n     */\n    function setOwner(address _owner) public onlyOwner {\n        require(_owner != address(0), \"new owner is the zero address\");\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    function updateAnswer(int256 _answer) public onlyOwner {\n        latestAnswer = _answer;\n        latestTimestamp = block.timestamp;\n        latestRound++;\n        getAnswer[latestRound] = _answer;\n        getTimestamp[latestRound] = block.timestamp;\n        getStartedAt[latestRound] = block.timestamp;\n    }\n\n    function updateRoundData(\n        uint80 _roundId,\n        int256 _answer,\n        uint256 _timestamp,\n        uint256 _startedAt\n    ) public onlyOwner {\n        latestRound = _roundId;\n        latestAnswer = _answer;\n        latestTimestamp = _timestamp;\n        getAnswer[latestRound] = _answer;\n        getTimestamp[latestRound] = _timestamp;\n        getStartedAt[latestRound] = _startedAt;\n    }\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (\n            _roundId,\n            getAnswer[_roundId],\n            getStartedAt[_roundId],\n            getTimestamp[_roundId],\n            _roundId\n        );\n    }\n\n    function latestRoundData()\n        external\n        view\n        override\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return (\n            uint80(latestRound),\n            getAnswer[latestRound],\n            getStartedAt[latestRound],\n            getTimestamp[latestRound],\n            uint80(latestRound)\n        );\n    }\n\n    function description() external view override returns (string memory) {\n        return \"v0.6/tests/MockV3Aggregator.sol\";\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\n{\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface AggregatorInterface {\n  function latestAnswer()\n    external\n    view\n    returns (\n      int256\n    );\n  \n  function latestTimestamp()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  function latestRound()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  function getAnswer(\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      int256\n    );\n\n  function getTimestamp(\n    uint256 roundId\n  )\n    external\n    view\n    returns (\n      uint256\n    );\n\n  event AnswerUpdated(\n    int256 indexed current,\n    uint256 indexed roundId,\n    uint256 updatedAt\n  );\n\n  event NewRound(\n    uint256 indexed roundId,\n    address indexed startedBy,\n    uint256 startedAt\n  );\n}\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/FXRatesAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./ProtocolTypes.sol\";\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @dev FX Rates Aggregator contract is using for accessing Chainlink price feeds\n * prices in USD/ETH for Secured Finance protocol and converts\n * FX rates to USDT/USDC/ETH internally\n *\n * Contract stores chainlink price feeds by ccy in usdPriceFeeds and ethPriceFeeds mappings.\n */\ncontract FXRatesAggregator is ProtocolTypes {\n    using SignedSafeMath for int256;\n    using SafeMath for uint256;\n\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n    event PriceFeedAdded(Ccy ccy, string secondCcy, address indexed priceFeed);\n    event PriceFeedRemoved(\n        Ccy ccy,\n        string secondCcy,\n        address indexed priceFeed\n    );\n\n    address public owner;\n\n    mapping(Ccy => AggregatorV3Interface) public usdPriceFeeds;\n    mapping(Ccy => AggregatorV3Interface) public ethPriceFeeds;\n    mapping(Ccy => uint8) public usdDecimals;\n    mapping(Ccy => uint8) public ethDecimals;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Sets owner of the controller market.\n     * @param _owner Address of new owner\n     */\n    function setOwner(address _owner) public onlyOwner {\n        require(_owner != address(0), \"new owner is the zero address\");\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    // =========== SET CHAINLINK PRICE FEED FUNCTIONS ===========\n\n    /**\n     * @dev Links the contract to existing chainlink price feed.\n     * @param _ccy Specified currency\n     * @param _priceFeedAddr Chainlink price feed contract address\n     * @param _isEthPriceFeed Boolean for price feed with ETH price\n     */\n    function linkPriceFeed(\n        Ccy _ccy,\n        address _priceFeedAddr,\n        bool _isEthPriceFeed\n    ) public onlyOwner returns (bool) {\n        require(_priceFeedAddr != address(0), \"Couldn't link 0x0 address\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(_priceFeedAddr);\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        require(price >= 0, \"PriceFeed is invalid\");\n\n        uint8 decimals = priceFeed.decimals();\n        require(decimals <= 18, \"PriceFeed decimals is invalid\");\n\n        if (_isEthPriceFeed) {\n            require(_ccy != Ccy.ETH, \"Can't link ETH PriceFeed\");\n            ethPriceFeeds[_ccy] = priceFeed;\n            ethDecimals[_ccy] = decimals;\n            emit PriceFeedAdded(_ccy, \"ETH\", _priceFeedAddr);\n        } else {\n            usdPriceFeeds[_ccy] = priceFeed;\n            usdDecimals[_ccy] = decimals;\n            emit PriceFeedAdded(_ccy, \"USD\", _priceFeedAddr);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Triggers to remove existing chainlink price feed.\n     * @param _ccy Specified currency\n     * @param _isEthPriceFeed Boolean for price feed with ETH price\n     */\n    function removePriceFeed(Ccy _ccy, bool _isEthPriceFeed)\n        external\n        onlyOwner\n    {\n        if (_isEthPriceFeed == true) {\n            address priceFeed = address(ethPriceFeeds[_ccy]);\n\n            require(priceFeed != address(0), \"Invalid PriceFeed\");\n            delete ethPriceFeeds[_ccy];\n            delete ethDecimals[_ccy];\n\n            emit PriceFeedRemoved(_ccy, \"ETH\", priceFeed);\n        } else {\n            address priceFeed = address(usdPriceFeeds[_ccy]);\n\n            require(priceFeed != address(0), \"Invalid PriceFeed\");\n            delete usdPriceFeeds[_ccy];\n            delete usdDecimals[_ccy];\n\n            emit PriceFeedRemoved(_ccy, \"USD\", priceFeed);\n        }\n    }\n\n    // =========== GET PRICE FUNCTIONS ===========\n\n    /**\n     * @dev Triggers to get last price in USD for selected currency.\n     * @param _ccy Currency\n     */\n    function getLastUSDPrice(Ccy _ccy) public view returns (int256) {\n        AggregatorV3Interface priceFeed = usdPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get historical price in USD for selected currency.\n     * @param _ccy Currency\n     * @param _roundId RoundId\n     */\n    function getHistoricalUSDPrice(Ccy _ccy, uint80 _roundId)\n        public\n        view\n        returns (int256)\n    {\n        AggregatorV3Interface priceFeed = usdPriceFeeds[_ccy];\n        (, int256 price, , uint256 timeStamp, ) = priceFeed.getRoundData(\n            _roundId\n        );\n\n        require(timeStamp > 0, \"Round not completed yet\");\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get last price in ETH for selected currency.\n     * @param _ccy Currency\n     */\n    function getLastETHPrice(Ccy _ccy) public view returns (int256) {\n        if (_isETH(_ccy)) return 1;\n\n        AggregatorV3Interface priceFeed = ethPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get historical price in ETH for selected currency.\n     * @param _ccy Currency\n     * @param _roundId RoundId\n     */\n    function getHistoricalETHPrice(Ccy _ccy, uint80 _roundId)\n        public\n        view\n        returns (int256)\n    {\n        if (_isETH(_ccy)) return 1;\n\n        AggregatorV3Interface priceFeed = ethPriceFeeds[_ccy];\n        (, int256 price, , uint256 timeStamp, ) = priceFeed.getRoundData(\n            _roundId\n        );\n\n        require(timeStamp > 0, \"Round not completed yet\");\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get converted amount of currency in ETH.\n     * @param _ccy Currency that has to be convered to ETH\n     * @param _amount Amount of funds to be converted\n     */\n    function convertToETH(Ccy _ccy, uint256 _amount)\n        public\n        view\n        returns (uint256)\n    {\n        if (_isETH(_ccy)) return _amount;\n\n        AggregatorV3Interface priceFeed = ethPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return _amount.mul(uint256(price)).div(1e18);\n    }\n\n    /**\n     * @dev Triggers to get converted amount of currency in ETH.\n     * @param _ccy Currency that has to be convered to ETH\n     * @param _amounts Amount of funds to be converted\n     */\n    function convertBulkToETH(Ccy _ccy, uint256[] memory _amounts)\n        public\n        view\n        returns (uint256[] memory)\n    {\n        if (_isETH(_ccy)) return _amounts;\n\n        AggregatorV3Interface priceFeed = ethPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        uint256[] memory amounts = new uint256[](_amounts.length);\n\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            uint256 amount = _amounts[i];\n\n            if (amount > 0) {\n                amounts[i] = amount.mul(uint256(price)).div(1e18);\n            } else {\n                amounts[i] = 0;\n            }\n        }\n\n        return amounts;\n    }\n\n    function _isETH(Ccy _ccy) internal pure returns (bool) {\n        return _ccy == Ccy.ETH;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/CurrencyController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./interfaces/ICurrencyController.sol\";\n\n/**\n * @dev Currency Controller contract is responsible for managing supported\n * currencies in Secured Finance Protocol\n *\n * Contract links new currencies to ETH Chainlink price feeds, without existing price feed\n * contract owner is not able to add a new currency into the protocol\n */\ncontract CurrencyController is ICurrencyController {\n    using SignedSafeMath for int256;\n    using SafeMath for uint256;\n\n    address public override owner;\n    uint8 public override last_ccy_index;\n\n    struct Currency {\n        bool isSupported;\n        string name;\n        uint16 chainId; // chain id for address conversion\n    }\n\n    // Protocol currencies storage\n    mapping(bytes32 => Currency) public override currencies;\n    mapping(bytes32 => uint256) public override haircuts;\n    mapping(bytes32 => uint256) public override minMargins;\n    mapping(bytes32 => bool) public override isCollateral;\n    mapping(bytes32 => address) public override tokenAddresses;\n\n    // PriceFeed storage\n    mapping(bytes32 => AggregatorV3Interface) private usdPriceFeeds;\n    mapping(bytes32 => AggregatorV3Interface) private ethPriceFeeds;\n    mapping(bytes32 => uint8) public override usdDecimals;\n    mapping(bytes32 => uint8) public override ethDecimals;\n\n    uint8 public override supportedCurrencies;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier supportedCcyOnly(bytes32 _ccy) {\n        require(isSupportedCcy(_ccy), \"Unsupported asset\");\n        _;\n    }\n\n    /**\n     * @dev Lending Market Controller Constructor.\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Sets owner of the controller market.\n     * @param _owner Address of new owner\n     */\n    function setOwner(address _owner) public override onlyOwner {\n        require(_owner != address(0), \"new owner is the zero address\");\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    // =========== CURRENCY CONTROL SECTION ===========\n\n    /**\n     * @dev Triggers to add new currency into the protocol. Links with existing ETH chainlink pricefeed\n     * @param _ccy Currency short ticket\n     * @param _name Currency full name\n     * @param _chainId Chain ID for conversion from bytes32 to bytes\n     * @param _ethPriceFeed Address for ETH price feed\n     */\n    function supportCurrency(\n        bytes32 _ccy,\n        string memory _name,\n        uint16 _chainId,\n        address _ethPriceFeed,\n        uint256 _haircut,\n        address _tokenAddress\n    ) public override onlyOwner returns (bool) {\n        last_ccy_index = last_ccy_index++;\n\n        Currency memory currency;\n        currency.name = _name;\n        if (_chainId != 0) {\n            currency.chainId = _chainId;\n        }\n\n        if (_tokenAddress != address(0)) {\n            tokenAddresses[_ccy] = _tokenAddress;\n        }\n\n        currency.isSupported = true;\n\n        currencies[_ccy] = currency;\n        haircuts[_ccy] = _haircut;\n\n        if (_ccy != \"ETH\") {\n            require(\n                linkPriceFeed(_ccy, _ethPriceFeed, true),\n                \"Invalid PriceFeed\"\n            );\n        } else {\n            require(\n                linkPriceFeed(_ccy, _ethPriceFeed, false),\n                \"Invalid PriceFeed\"\n            );\n        }\n        emit CcyAdded(_ccy, _name, _chainId, _haircut);\n    }\n\n    /**\n     * @dev Triggers to update currency support\n     * @param _ccy Currency short ticket\n     * @param _isSupported Boolean whether currency supported as collateral or not\n     */\n    function updateCurrencySupport(bytes32 _ccy, bool _isSupported)\n        public\n        override\n        onlyOwner\n        returns (bool)\n    {\n        Currency storage currency = currencies[_ccy];\n        currency.isSupported = _isSupported;\n\n        emit CcySupportUpdate(_ccy, _isSupported);\n    }\n\n    /**\n     * @dev Triggers to update if currency is accepted as collateral\n     * @param _ccy Currency short ticket\n     * @param _isSupported Boolean whether currency supported as collateral or not\n     */\n    function updateCollateralSupport(bytes32 _ccy, bool _isSupported)\n        public\n        override\n        onlyOwner\n        supportedCcyOnly(_ccy)\n        returns (bool)\n    {\n        isCollateral[_ccy] = _isSupported;\n\n        emit CcyCollateralUpdate(_ccy, _isSupported);\n    }\n\n    /**\n     * @dev Triggers to update the haircut ratio for supported currency\n     * @param _ccy Currency short ticket\n     * @param _haircut Currency haircut ratio used to calculate in collateral calculations\n     */\n    function updateCcyHaircut(bytes32 _ccy, uint256 _haircut)\n        public\n        override\n        onlyOwner\n        supportedCcyOnly(_ccy)\n        returns (bool)\n    {\n        require(_haircut > 0, \"Incorrect haircut ratio\");\n        require(_haircut <= 10000, \"Haircut ratio overflow\");\n\n        haircuts[_ccy] = _haircut;\n\n        emit HaircutUpdated(_ccy, _haircut);\n    }\n\n    /**\n     * @dev Triggers to update the minimal margin requirements for currency supported as collateral\n     * @param _ccy Currency short ticket\n     * @param _minMargin Currency minimal margin ratio used to calculate collateral coverage\n     */\n    function updateMinMargin(bytes32 _ccy, uint256 _minMargin)\n        public\n        override\n        onlyOwner\n        supportedCcyOnly(_ccy)\n        returns (bool)\n    {\n        require(_minMargin > 0, \"Incorrect MinMargin\");\n        require(_minMargin <= 10000, \"MinMargin overflow\");\n        require(isCollateral[_ccy], \"Unable to set MinMargin\");\n\n        minMargins[_ccy] = _minMargin;\n\n        emit MinMarginUpdated(_ccy, _minMargin);\n    }\n\n    // =========== EXTERNAL GET FUNCTIONS ===========\n\n    /**\n     * @dev Triggers to get haircut ratio for specific currency.\n     * Haircut is used in bilateral netting cross-calculation.\n     * @param _ccy Currency short ticket\n     */\n    function getHaircut(bytes32 _ccy) external view override returns (uint256) {\n        return haircuts[_ccy];\n    }\n\n    /**\n     * @dev Triggers to get minimal margin percentage for specific currency.\n     * @param _ccy Currency short ticket\n     */\n    function getMinMargin(bytes32 _ccy)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(isCollateral[_ccy], \"Unable to get MinMargin\");\n        return minMargins[_ccy];\n    }\n\n    /**\n     * @dev Triggers to get if specified currency is supported.\n     * @param _ccy Currency short ticket\n     */\n    function isSupportedCcy(bytes32 _ccy) public view override returns (bool) {\n        return currencies[_ccy].isSupported;\n    }\n\n    /**\n     * @dev Triggers to get chainId for a specific currency.\n     * Chain ID is a unique identifier of another chain like Bitcoin, Filecoin, etc.\n     * @param _ccy Currency short ticket\n     */\n    function getChainId(bytes32 _ccy) external view override returns (uint16) {\n        return currencies[_ccy].chainId;\n    }\n\n    // =========== CHAINLINK PRICE FEED FUNCTIONS ===========\n    // TODO: add additional price feeds in case if chainlink is not reliable\n\n    /**\n     * @dev Links the contract to existing chainlink price feed.\n     * @param _ccy Specified currency short code\n     * @param _priceFeedAddr Chainlink price feed contract address\n     * @param _isEthPriceFeed Boolean for price feed with ETH price\n     */\n    function linkPriceFeed(\n        bytes32 _ccy,\n        address _priceFeedAddr,\n        bool _isEthPriceFeed\n    ) public override onlyOwner returns (bool) {\n        require(_priceFeedAddr != address(0), \"Couldn't link 0x0 address\");\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(_priceFeedAddr);\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        require(price >= 0, \"Invalid PriceFeed\");\n\n        uint8 decimals = priceFeed.decimals();\n        require(decimals <= 18, \"Invalid decimals\");\n\n        if (_isEthPriceFeed) {\n            require(!_isETH(_ccy), \"Can't link to ETH\");\n            ethPriceFeeds[_ccy] = priceFeed;\n            ethDecimals[_ccy] = decimals;\n            emit PriceFeedAdded(_ccy, \"ETH\", _priceFeedAddr);\n        } else {\n            usdPriceFeeds[_ccy] = priceFeed;\n            usdDecimals[_ccy] = decimals;\n            emit PriceFeedAdded(_ccy, \"USD\", _priceFeedAddr);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Triggers to remove existing chainlink price feed.\n     * @param _ccy Specified currency\n     * @param _isEthPriceFeed Boolean for price feed with ETH price\n     */\n    function removePriceFeed(bytes32 _ccy, bool _isEthPriceFeed)\n        external\n        override\n        onlyOwner\n        supportedCcyOnly(_ccy)\n    {\n        if (_isEthPriceFeed == true) {\n            address priceFeed = address(ethPriceFeeds[_ccy]);\n\n            require(priceFeed != address(0), \"Invalid PriceFeed\");\n            delete ethPriceFeeds[_ccy];\n            delete ethDecimals[_ccy];\n\n            emit PriceFeedRemoved(_ccy, \"ETH\", priceFeed);\n        } else {\n            address priceFeed = address(usdPriceFeeds[_ccy]);\n\n            require(priceFeed != address(0), \"Invalid PriceFeed\");\n            delete usdPriceFeeds[_ccy];\n            delete usdDecimals[_ccy];\n\n            emit PriceFeedRemoved(_ccy, \"USD\", priceFeed);\n        }\n    }\n\n    // =========== GET PRICE FUNCTIONS ===========\n\n    /**\n     * @dev Triggers to get last price in USD for selected currency.\n     * @param _ccy Currency\n     */\n    function getLastUSDPrice(bytes32 _ccy)\n        public\n        view\n        override\n        returns (int256)\n    {\n        AggregatorV3Interface priceFeed = usdPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get historical price in USD for selected currency.\n     * @param _ccy Currency\n     * @param _roundId RoundId\n     */\n    function getHistoricalUSDPrice(bytes32 _ccy, uint80 _roundId)\n        public\n        view\n        override\n        returns (int256)\n    {\n        AggregatorV3Interface priceFeed = usdPriceFeeds[_ccy];\n        (, int256 price, , uint256 timeStamp, ) = priceFeed.getRoundData(\n            _roundId\n        );\n\n        require(timeStamp > 0, \"Round not completed yet\");\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get last price in ETH for selected currency.\n     * @param _ccy Currency\n     */\n    function getLastETHPrice(bytes32 _ccy)\n        public\n        view\n        override\n        returns (int256)\n    {\n        if (_isETH(_ccy)) return 1e18;\n\n        AggregatorV3Interface priceFeed = ethPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get historical price in ETH for selected currency.\n     * @param _ccy Currency\n     * @param _roundId RoundId\n     */\n    function getHistoricalETHPrice(bytes32 _ccy, uint80 _roundId)\n        public\n        view\n        override\n        returns (int256)\n    {\n        if (_isETH(_ccy)) return 1e18;\n\n        AggregatorV3Interface priceFeed = ethPriceFeeds[_ccy];\n        (, int256 price, , uint256 timeStamp, ) = priceFeed.getRoundData(\n            _roundId\n        );\n\n        require(timeStamp > 0, \"Round not completed yet\");\n        return price;\n    }\n\n    /**\n     * @dev Triggers to get converted amount of currency in ETH.\n     * @param _ccy Currency that has to be convered to ETH\n     * @param _amount Amount of funds to be converted\n     */\n    function convertToETH(bytes32 _ccy, uint256 _amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (_isETH(_ccy)) return _amount;\n\n        AggregatorV3Interface priceFeed = ethPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return _amount.mul(uint256(price)).div(1e18);\n    }\n\n    /**\n     * @dev Triggers to get converted amounts of currency to ETH.\n     * @param _ccy Currency that has to be convered to ETH\n     * @param _amounts Array with amounts of funds to be converted\n     */\n    function convertBulkToETH(bytes32 _ccy, uint256[] memory _amounts)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        if (_isETH(_ccy)) return _amounts;\n\n        AggregatorV3Interface priceFeed = ethPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n        uint256[] memory amounts = new uint256[](_amounts.length);\n\n        for (uint256 i = 0; i < _amounts.length; i++) {\n            uint256 amount = _amounts[i];\n\n            if (amount > 0) {\n                amounts[i] = amount.mul(uint256(price)).div(1e18);\n            } else {\n                amounts[i] = 0;\n            }\n        }\n\n        return amounts;\n    }\n\n    /**\n     * @dev Triggers to convert ETH amount of funds to specified currency.\n     * @param _ccy Currency that has to be convered from ETH\n     * @param _amountETH Amount of funds in ETH to be converted\n     */\n    function convertFromETH(bytes32 _ccy, uint256 _amountETH)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        if (_isETH(_ccy)) return _amountETH;\n\n        AggregatorV3Interface priceFeed = ethPriceFeeds[_ccy];\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return (_amountETH.mul(1e18)).div(uint256(price)); // add decimals checks\n    }\n\n    function _isETH(bytes32 _ccy) internal pure returns (bool) {\n        return _ccy == \"ETH\";\n    }\n}\n"
    },
    "contracts/mocks/LoanCallerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../ProtocolTypes.sol\";\nimport \"../interfaces/ILoanV2.sol\";\n\ncontract LoanCallerMock is ProtocolTypes {\n    ILoanV2 public loan;\n\n    constructor(address _loan) public {\n        loan = ILoanV2(_loan);\n    }\n\n    function register(\n        address maker,\n        address taker,\n        uint8 side,\n        bytes32 ccy,\n        uint256 term,\n        uint256 notional,\n        uint256 rate\n    ) public returns (bytes32 loanId) {\n        return loan.register(maker, taker, side, ccy, term, notional, rate);\n    }\n}\n"
    },
    "contracts/mocks/LendingMarketControllerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/ILendingMarketController.sol\";\nimport \"../ProtocolTypes.sol\";\nimport \"../libraries/DiscountFactor.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract LendingMarketControllerMock is\n    ILendingMarketController,\n    ProtocolTypes\n{\n    using SafeMath for uint256;\n\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    address public override owner;\n    uint256 public override numberOfMarkets = 0;\n\n    mapping(bytes32 => mapping(uint256 => uint256)) public lendRates;\n    mapping(bytes32 => mapping(uint256 => uint256)) public borrowRates;\n    mapping(bytes32 => uint256[]) public supportedTerms;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Lending Market Controller Constructor.\n     */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Sets owner of the controller market.\n     * @param _owner Address of new owner\n     */\n    function setOwner(address _owner) public onlyOwner {\n        require(_owner != address(0), \"new owner is the zero address\");\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    /**\n     * @dev Triggers to get borrow rates for selected currency.\n     * @param _ccy Currency short identifier\n     */\n    function getBorrowRatesForCcy(bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256[] memory terms = supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint8 i = 0; i < terms.length; i++) {\n            uint256 borrowRate = borrowRates[_ccy][i];\n\n            rates[i] = borrowRate;\n        }\n\n        return rates;\n    }\n\n    /**\n     * @dev Triggers to get lend rates for selected currency.\n     * @param _ccy Currency short identifier\n     */\n    function getLendRatesForCcy(bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256[] memory terms = supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint8 i = 0; i < terms.length; i++) {\n            uint256 lendRate = lendRates[_ccy][i];\n\n            rates[i] = lendRate;\n        }\n\n        return rates;\n    }\n\n    /**\n     * @dev Triggers to get mid rates for selected currency.\n     * @param _ccy Currency short identifier\n     */\n    function getMidRatesForCcy(bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        uint256[] memory terms = supportedTerms[_ccy];\n        uint256[] memory rates = new uint256[](terms.length);\n\n        for (uint8 i = 0; i < terms.length; i++) {\n            uint256 borrowRate = borrowRates[_ccy][i];\n            uint256 lendRate = lendRates[_ccy][i];\n            uint256 combinedRate = borrowRate.add(lendRate);\n\n            rates[i] = combinedRate.div(2);\n        }\n\n        return rates;\n    }\n\n    /**\n     * @dev Triggers to set borrow rates for selected currency.\n     * @param _ccy Currency short identifier\n     */\n    function setBorrowRatesForCcy(bytes32 _ccy, uint256[] memory _rates)\n        public\n        onlyOwner\n    {\n        for (uint8 i = 0; i < _rates.length; i++) {\n            borrowRates[_ccy][i] = _rates[i];\n        }\n    }\n\n    /**\n     * @dev Triggers to set lend rates for selected currency.\n     * @param _ccy Currency short identifier\n     */\n    function setLendRatesForCcy(bytes32 _ccy, uint256[] memory _rates)\n        public\n        onlyOwner\n    {\n        for (uint8 i = 0; i < _rates.length; i++) {\n            lendRates[_ccy][i] = _rates[i];\n        }\n    }\n\n    function getDiscountFactorsForCcy(bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256[] memory, uint256[] memory)\n    {\n        uint256[] memory rates = getMidRatesForCcy(_ccy);\n\n        return DiscountFactor.calculateDFs(rates, supportedTerms[_ccy]);\n    }\n\n    // =========== UNUSED FUNCTIONS ===========\n\n    function deployLendingMarket(bytes32 _ccy, uint256 _term)\n        public\n        override\n        returns (address)\n    {\n        _ccy;\n        _term;\n        return address(0);\n    }\n\n    function lendingMarkets(bytes32 _ccy, uint256 _term)\n        public\n        view\n        override\n        returns (address)\n    {\n        _ccy;\n        _term;\n        return address(0);\n    }\n\n    function pauseLendingMarkets(bytes32 _ccy) public override returns (bool) {\n        _ccy;\n        return true;\n    }\n\n    function unpauseLendingMarkets(bytes32 _ccy)\n        public\n        override\n        returns (bool)\n    {\n        _ccy;\n        return true;\n    }\n\n    function placeBulkOrders(Order[] memory orders)\n        public\n        override\n        returns (bool)\n    {\n        orders;\n        return true;\n    }\n\n    function setSupportedTerms(bytes32 _ccy, uint256[] memory terms) public {\n        supportedTerms[_ccy] = terms;\n    }\n\n    function getSupportedTerms(bytes32 _ccy)\n        public\n        view\n        override\n        returns (uint256[] memory)\n    {\n        return supportedTerms[_ccy];\n    }\n}\n"
    },
    "contracts/test/DiscountFactorTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../libraries/DiscountFactor.sol\";\n\ncontract DiscountFactorTest {\n    function bootstrapTerms(uint256[] memory rates, uint256[] memory terms)\n        external\n        view\n        returns (uint256[] memory, uint256[] memory)\n    {\n        return DiscountFactor.bootstrapTerms(rates, terms);\n    }\n\n    function getGasCostOfBootstrapTerms(\n        uint256[] memory rates,\n        uint256[] memory terms\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        DiscountFactor.bootstrapTerms(rates, terms);\n\n        return gasBefore - gasleft();\n    }\n\n    function calculateDFs(uint256[] memory rates, uint256[] memory terms)\n        external\n        view\n        returns (uint256[] memory, uint256[] memory)\n    {\n        return DiscountFactor.calculateDFs(rates, terms);\n    }\n\n    function getGasCostOfCalculateDFs(\n        uint256[] memory rates,\n        uint256[] memory terms\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        DiscountFactor.calculateDFs(rates, terms);\n\n        return gasBefore - gasleft();\n    }\n\n    function interpolateDF(\n        uint256[] memory discountFactors,\n        uint256[] memory terms,\n        uint256 date\n    ) external view returns (uint256) {\n        return DiscountFactor.interpolateDF(discountFactors, terms, date);\n    }\n\n    function getGasCostOfInterpolateDF(\n        uint256[] memory discountFactors,\n        uint256[] memory terms,\n        uint256 date\n    ) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        DiscountFactor.interpolateDF(discountFactors, terms, date);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/mocks/CollateralAggregatorCallerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../ProtocolTypes.sol\";\nimport \"../interfaces/ICollateralAggregatorV2.sol\";\n\ncontract CollateralAggregatorCallerMock is ProtocolTypes {\n    ICollateralAggregator public collateralAggregator;\n\n    constructor(address _collateralAggregator) public {\n        collateralAggregator = ICollateralAggregator(_collateralAggregator);\n    }\n\n    function useUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) public {\n        collateralAggregator.useUnsettledCollateral(user, ccy, amount);\n    }\n\n    function useCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) public {\n        collateralAggregator.useCollateral(\n            partyA,\n            partyB,\n            ccy,\n            amount0,\n            amount1,\n            isSettled\n        );\n    }\n\n    function settleCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1\n    ) public {\n        collateralAggregator.settleCollateral(\n            partyA,\n            partyB,\n            ccy,\n            amount0,\n            amount1\n        );\n    }\n\n    function releaseUnsettledCollateral(\n        address user,\n        bytes32 ccy,\n        uint256 amount\n    ) public {\n        collateralAggregator.releaseUnsettledCollateral(user, ccy, amount);\n    }\n\n    function releaseCollateral(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) public {\n        collateralAggregator.releaseCollateral(\n            partyA,\n            partyB,\n            ccy,\n            amount0,\n            amount1,\n            isSettled\n        );\n    }\n\n    function updatePV(\n        address partyA,\n        address partyB,\n        bytes32 ccy,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) external {\n        collateralAggregator.updatePV(\n            partyA,\n            partyB,\n            ccy,\n            prevPV0,\n            prevPV1,\n            currentPV0,\n            currentPV1\n        );\n    }\n\n    function liquidate(\n        address from,\n        address to,\n        bytes32 ccy,\n        uint256 liquidationAmount,\n        uint256 pvForRelease,\n        bool isSettled\n    ) external {\n        collateralAggregator.liquidate(\n            from,\n            to,\n            ccy,\n            liquidationAmount,\n            pvForRelease,\n            isSettled\n        );\n    }\n\n    function liquidate(\n        address from,\n        address to,\n        uint256 liquidationInETH\n    ) external {\n        collateralAggregator.liquidate(from, to, liquidationInETH);\n    }\n}\n"
    },
    "contracts/test/NetPVTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../libraries/NetPV.sol\";\n\ncontract NetPVTest {\n    using SafeMath for uint256;\n\n    mapping(bytes32 => mapping(bytes32 => NetPV.CcyNetting))\n        private _ccyNettings;\n    bytes32 public ccy = \"0xSampleCCY\";\n\n    function get(address party0, address party1)\n        public\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        NetPV.CcyNetting memory netting = _get(party0, party1);\n\n        return (\n            netting.unsettled0PV,\n            netting.unsettled1PV,\n            netting.party0PV,\n            netting.party1PV\n        );\n    }\n\n    function getGasCostOfGet(address party0, address party1)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        _get(party0, party1);\n\n        return gasBefore - gasleft();\n    }\n\n    function _get(address party0, address party1)\n        internal\n        view\n        returns (NetPV.CcyNetting memory)\n    {\n        return NetPV.get(_ccyNettings, party0, party1, ccy);\n    }\n\n    function use(\n        address party0,\n        address party1,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) public {\n        NetPV.CcyNetting memory nettingBefore = _get(party0, party1);\n\n        NetPV.use(\n            _ccyNettings,\n            party0,\n            party1,\n            ccy,\n            amount0,\n            amount1,\n            isSettled\n        );\n\n        NetPV.CcyNetting memory nettingAfter = _get(party0, party1);\n\n        if (isSettled) {\n            require(\n                nettingAfter.party0PV == nettingBefore.party0PV.add(amount0) &&\n                    nettingAfter.party1PV ==\n                    nettingBefore.party1PV.add(amount1),\n                \"INCORRECT_CCY_NETTING_USE\"\n            );\n        } else {\n            require(\n                nettingAfter.unsettled0PV ==\n                    nettingBefore.unsettled0PV.add(amount0) &&\n                    nettingAfter.unsettled1PV ==\n                    nettingBefore.unsettled1PV.add(amount1),\n                \"INCORRECT_CCY_NETTING_USE\"\n            );\n        }\n    }\n\n    function settle(\n        address party0,\n        address party1,\n        uint256 amount0,\n        uint256 amount1\n    ) public {\n        NetPV.CcyNetting memory nettingBefore = _get(party0, party1);\n\n        NetPV.settle(_ccyNettings, party0, party1, ccy, amount0, amount1);\n\n        NetPV.CcyNetting memory nettingAfter = _get(party0, party1);\n\n        require(\n            nettingAfter.unsettled0PV ==\n                nettingBefore.unsettled0PV.sub(amount0) &&\n                nettingAfter.party0PV == nettingBefore.party0PV.add(amount0),\n            \"INCORRECT_CCY_NETTING_SETTLE\"\n        );\n\n        require(\n            nettingAfter.unsettled1PV ==\n                nettingBefore.unsettled1PV.sub(amount1) &&\n                nettingAfter.party1PV == nettingBefore.party1PV.add(amount1),\n            \"INCORRECT_CCY_NETTING_SETTLE\"\n        );\n    }\n\n    function release(\n        address party0,\n        address party1,\n        uint256 amount0,\n        uint256 amount1,\n        bool isSettled\n    ) public {\n        NetPV.CcyNetting memory nettingBefore = _get(party0, party1);\n\n        NetPV.release(\n            _ccyNettings,\n            party0,\n            party1,\n            ccy,\n            amount0,\n            amount1,\n            isSettled\n        );\n\n        NetPV.CcyNetting memory nettingAfter = _get(party0, party1);\n\n        if (isSettled) {\n            require(\n                nettingAfter.party0PV == nettingBefore.party0PV.sub(amount0) &&\n                    nettingAfter.party1PV ==\n                    nettingBefore.party1PV.sub(amount1),\n                \"INCORRECT_CCY_NETTING_RELEASE\"\n            );\n        } else {\n            require(\n                nettingAfter.unsettled0PV ==\n                    nettingBefore.unsettled0PV.sub(amount0) &&\n                    nettingAfter.unsettled1PV ==\n                    nettingBefore.unsettled1PV.sub(amount1),\n                \"INCORRECT_CCY_NETTING_RELEASE\"\n            );\n        }\n    }\n\n    function update(\n        address party0,\n        address party1,\n        uint256 prevPV0,\n        uint256 prevPV1,\n        uint256 currentPV0,\n        uint256 currentPV1\n    ) public {\n        NetPV.CcyNetting memory nettingBefore = _get(party0, party1);\n\n        NetPV.update(\n            _ccyNettings,\n            party0,\n            party1,\n            ccy,\n            prevPV0,\n            prevPV1,\n            currentPV0,\n            currentPV1\n        );\n\n        NetPV.CcyNetting memory nettingAfter = _get(party0, party1);\n\n        require(\n            nettingAfter.party0PV ==\n                nettingBefore.party0PV.sub(prevPV0).add(currentPV0),\n            \"INCORRECT_CCY_NETTING_UPDATE\"\n        );\n\n        require(\n            nettingAfter.party1PV ==\n                nettingBefore.party1PV.sub(prevPV1).add(currentPV1),\n            \"INCORRECT_CCY_NETTING_SETTLE\"\n        );\n    }\n\n    function clear(address party0, address party1) public {\n        NetPV.clear(_ccyNettings, party0, party1, ccy);\n        NetPV.CcyNetting memory netting = _get(party0, party1);\n\n        require(\n            netting.unsettled0PV == 0 &&\n                netting.unsettled1PV == 0 &&\n                netting.party0PV == 0 &&\n                netting.party1PV == 0,\n            \"INCORRECT_POSITION_CLEAR\"\n        );\n    }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.12;\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    constructor(\n        string memory name,\n        string memory symbol,\n        address initialAccount,\n        uint256 initialBalance\n    ) public payable ERC20(name, symbol) {\n        _mint(initialAccount, initialBalance);\n    }\n\n    function mint(address account, uint256 amount) public {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) public {\n        _burn(account, amount);\n    }\n\n    function transferInternal(\n        address from,\n        address to,\n        uint256 value\n    ) public {\n        _transfer(from, to, value);\n    }\n\n    function approveInternal(\n        address owner,\n        address spender,\n        uint256 value\n    ) public {\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/mocks/BokkyPooBahsDateTimeContract.sol": {
      "content": "// SPDX-License-Identifier: GNU Lesser General Public License 3.0\npragma solidity ^0.6.12;\n\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.00 - Contract Instance\n//\n// A gas-efficient Solidity date and time library\n//\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n//\n// Tested date range 1970/01/01 to 2345/12/31\n//\n// Conventions:\n// Unit      | Range         | Notes\n// :-------- |:-------------:|:-----\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n// year      | 1970 ... 2345 |\n// month     | 1 ... 12      |\n// day       | 1 ... 31      |\n// hour      | 0 ... 23      |\n// minute    | 0 ... 59      |\n// second    | 0 ... 59      |\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n//\n//\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.\n//\n// GNU Lesser General Public License 3.0\n// https://www.gnu.org/licenses/lgpl-3.0.en.html\n// ----------------------------------------------------------------------------\n\nimport \"../libraries/BokkyPooBahsDateTimeLibrary.sol\";\n\ncontract BokkyPooBahsDateTimeContract {\n    uint256 public constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 public constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 public constant SECONDS_PER_MINUTE = 60;\n    int256 public constant OFFSET19700101 = 2440588;\n\n    uint256 public constant DOW_MON = 1;\n    uint256 public constant DOW_TUE = 2;\n    uint256 public constant DOW_WED = 3;\n    uint256 public constant DOW_THU = 4;\n    uint256 public constant DOW_FRI = 5;\n    uint256 public constant DOW_SAT = 6;\n    uint256 public constant DOW_SUN = 7;\n\n    function _now() public view returns (uint256 timestamp) {\n        timestamp = block.timestamp;\n    }\n\n    function _nowDateTime()\n        public\n        view\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary\n            .timestampToDateTime(now);\n    }\n\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) public pure returns (uint256 _days) {\n        return BokkyPooBahsDateTimeLibrary._daysFromDate(year, month, day);\n    }\n\n    function _daysToDate(uint256 _days)\n        public\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        return BokkyPooBahsDateTimeLibrary._daysToDate(_days);\n    }\n\n    function timestampFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) public pure returns (uint256 timestamp) {\n        return BokkyPooBahsDateTimeLibrary.timestampFromDate(year, month, day);\n    }\n\n    function timestampFromDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) public pure returns (uint256 timestamp) {\n        return\n            BokkyPooBahsDateTimeLibrary.timestampFromDateTime(\n                year,\n                month,\n                day,\n                hour,\n                minute,\n                second\n            );\n    }\n\n    function timestampToDate(uint256 timestamp)\n        public\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        (year, month, day) = BokkyPooBahsDateTimeLibrary.timestampToDate(\n            timestamp\n        );\n    }\n\n    function timestampToDateTime(uint256 timestamp)\n        public\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary\n            .timestampToDateTime(timestamp);\n    }\n\n    function isValidDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) public pure returns (bool valid) {\n        valid = BokkyPooBahsDateTimeLibrary.isValidDate(year, month, day);\n    }\n\n    function isValidDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) public pure returns (bool valid) {\n        valid = BokkyPooBahsDateTimeLibrary.isValidDateTime(\n            year,\n            month,\n            day,\n            hour,\n            minute,\n            second\n        );\n    }\n\n    function isLeapYear(uint256 timestamp) public pure returns (bool leapYear) {\n        leapYear = BokkyPooBahsDateTimeLibrary.isLeapYear(timestamp);\n    }\n\n    function _isLeapYear(uint256 year) public pure returns (bool leapYear) {\n        leapYear = BokkyPooBahsDateTimeLibrary._isLeapYear(year);\n    }\n\n    function isWeekDay(uint256 timestamp) public pure returns (bool weekDay) {\n        weekDay = BokkyPooBahsDateTimeLibrary.isWeekDay(timestamp);\n    }\n\n    function isWeekEnd(uint256 timestamp) public pure returns (bool weekEnd) {\n        weekEnd = BokkyPooBahsDateTimeLibrary.isWeekEnd(timestamp);\n    }\n\n    function getDaysInMonth(uint256 timestamp)\n        public\n        pure\n        returns (uint256 daysInMonth)\n    {\n        daysInMonth = BokkyPooBahsDateTimeLibrary.getDaysInMonth(timestamp);\n    }\n\n    function _getDaysInMonth(uint256 year, uint256 month)\n        public\n        pure\n        returns (uint256 daysInMonth)\n    {\n        daysInMonth = BokkyPooBahsDateTimeLibrary._getDaysInMonth(year, month);\n    }\n\n    function getDayOfWeek(uint256 timestamp)\n        public\n        pure\n        returns (uint256 dayOfWeek)\n    {\n        dayOfWeek = BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp);\n    }\n\n    function getYear(uint256 timestamp) public pure returns (uint256 year) {\n        year = BokkyPooBahsDateTimeLibrary.getYear(timestamp);\n    }\n\n    function getMonth(uint256 timestamp) public pure returns (uint256 month) {\n        month = BokkyPooBahsDateTimeLibrary.getMonth(timestamp);\n    }\n\n    function getDay(uint256 timestamp) public pure returns (uint256 day) {\n        day = BokkyPooBahsDateTimeLibrary.getDay(timestamp);\n    }\n\n    function getHour(uint256 timestamp) public pure returns (uint256 hour) {\n        hour = BokkyPooBahsDateTimeLibrary.getHour(timestamp);\n    }\n\n    function getMinute(uint256 timestamp) public pure returns (uint256 minute) {\n        minute = BokkyPooBahsDateTimeLibrary.getMinute(timestamp);\n    }\n\n    function getSecond(uint256 timestamp) public pure returns (uint256 second) {\n        second = BokkyPooBahsDateTimeLibrary.getSecond(timestamp);\n    }\n\n    function addYears(uint256 timestamp, uint256 _years)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addYears(timestamp, _years);\n    }\n\n    function getGasCostofAddYears(uint256 timestamp, uint256 _years)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        BokkyPooBahsDateTimeLibrary.addYears(timestamp, _years);\n\n        return gasBefore - gasleft();\n    }\n\n    function addMonths(uint256 timestamp, uint256 _months)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(\n            timestamp,\n            _months\n        );\n    }\n\n    function getGasCostofAddMonths(uint256 timestamp, uint256 _months)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        BokkyPooBahsDateTimeLibrary.addMonths(timestamp, _months);\n\n        return gasBefore - gasleft();\n    }\n\n    function addDays(uint256 timestamp, uint256 _days)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, _days);\n    }\n\n    function getGasCostofAddDays(uint256 timestamp, uint256 _days)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        BokkyPooBahsDateTimeLibrary.addDays(timestamp, _days);\n\n        return gasBefore - gasleft();\n    }\n\n    function addHours(uint256 timestamp, uint256 _hours)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addHours(timestamp, _hours);\n    }\n\n    function addMinutes(uint256 timestamp, uint256 _minutes)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addMinutes(\n            timestamp,\n            _minutes\n        );\n    }\n\n    function addSeconds(uint256 timestamp, uint256 _seconds)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addSeconds(\n            timestamp,\n            _seconds\n        );\n    }\n\n    function getGasCostofAddSeconds(uint256 timestamp, uint256 _seconds)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        BokkyPooBahsDateTimeLibrary.addSeconds(timestamp, _seconds);\n\n        return gasBefore - gasleft();\n    }\n\n    function subYears(uint256 timestamp, uint256 _years)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subYears(timestamp, _years);\n    }\n\n    function subMonths(uint256 timestamp, uint256 _months)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subMonths(\n            timestamp,\n            _months\n        );\n    }\n\n    function subDays(uint256 timestamp, uint256 _days)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subDays(timestamp, _days);\n    }\n\n    function subHours(uint256 timestamp, uint256 _hours)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subHours(timestamp, _hours);\n    }\n\n    function subMinutes(uint256 timestamp, uint256 _minutes)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subMinutes(\n            timestamp,\n            _minutes\n        );\n    }\n\n    function subSeconds(uint256 timestamp, uint256 _seconds)\n        public\n        pure\n        returns (uint256 newTimestamp)\n    {\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subSeconds(\n            timestamp,\n            _seconds\n        );\n    }\n\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _years)\n    {\n        _years = BokkyPooBahsDateTimeLibrary.diffYears(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _months)\n    {\n        _months = BokkyPooBahsDateTimeLibrary.diffMonths(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _days)\n    {\n        _days = BokkyPooBahsDateTimeLibrary.diffDays(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _hours)\n    {\n        _hours = BokkyPooBahsDateTimeLibrary.diffHours(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _minutes)\n    {\n        _minutes = BokkyPooBahsDateTimeLibrary.diffMinutes(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        public\n        pure\n        returns (uint256 _seconds)\n    {\n        _seconds = BokkyPooBahsDateTimeLibrary.diffSeconds(\n            fromTimestamp,\n            toTimestamp\n        );\n    }\n}\n"
    },
    "contracts/libraries/HitchensOrderStatisticsTree.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"./HitchensOrderStatisticsTreeLib.sol\";\n\ncontract HitchensOrderStatisticsTree {\n    using HitchensOrderStatisticsTreeLib for HitchensOrderStatisticsTreeLib.Tree;\n\n    HitchensOrderStatisticsTreeLib.Tree tree;\n\n    event InsertOrder(\n        string action,\n        uint256 amount,\n        uint256 value,\n        uint256 orderId\n    );\n    event RemoveOrder(\n        string action,\n        uint256 amount,\n        uint256 value,\n        uint256 _id\n    );\n\n    constructor() public {}\n\n    function treeRootNode() public view returns (uint256 _value) {\n        _value = tree.root;\n    }\n\n    function firstValue() public view returns (uint256 _value) {\n        _value = tree.first();\n    }\n\n    function lastValue() public view returns (uint256 _value) {\n        _value = tree.last();\n    }\n\n    function nextValue(uint256 value) public view returns (uint256 _value) {\n        _value = tree.next(value);\n    }\n\n    function prevValue(uint256 value) public view returns (uint256 _value) {\n        _value = tree.prev(value);\n    }\n\n    function valueExists(uint256 value) public view returns (bool _exists) {\n        _exists = tree.exists(value);\n    }\n\n    function amountValueExists(uint256 amount, uint256 value)\n        public\n        view\n        returns (bool _exists)\n    {\n        _exists = tree.amountExistsInNode(amount, value);\n    }\n\n    function getNode(uint256 value)\n        public\n        view\n        returns (\n            uint256 _parent,\n            uint256 _left,\n            uint256 _right,\n            bool _red,\n            uint256 _head,\n            uint256 _tail,\n            uint256 _orderCounter\n        )\n    {\n        (_parent, _left, _right, _red, _head, _tail, _orderCounter) = tree\n            .getNode(value);\n    }\n\n    function getOrderByID(uint256 value, uint256 id)\n        public\n        view\n        returns (\n            uint256 _orderId,\n            uint256 _next,\n            uint256 _prev,\n            uint256 _timestamp,\n            uint256 _amount\n        )\n    {\n        (_orderId, _next, _prev, _timestamp, _amount) = tree.getOrderById(\n            value,\n            id\n        );\n    }\n\n    function getRootCount() public view returns (uint256 _orderCounter) {\n        _orderCounter = tree.count();\n    }\n\n    function getValueCount(uint256 value)\n        public\n        view\n        returns (uint256 _orderCounter)\n    {\n        _orderCounter = tree.getNodeCount(value);\n    }\n\n    function insertAmountValue(\n        uint256 amount,\n        uint256 value,\n        uint256 orderId\n    ) public {\n        emit InsertOrder(\"insert\", amount, value, orderId);\n        tree.insert(amount, value, orderId);\n    }\n\n    function removeAmountValue(\n        uint256 amount,\n        uint256 value,\n        uint256 orderId\n    ) public {\n        emit RemoveOrder(\"delete\", amount, value, orderId);\n        tree.remove(amount, value, orderId);\n    }\n}\n"
    },
    "contracts/test/AddressPackingTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.6.12;\n\nimport \"../libraries/AddressPacking.sol\";\n\ncontract AddressPackingTest {\n    function pack(address party0, address party1)\n        external\n        pure\n        returns (bytes32, bool)\n    {\n        return AddressPacking.pack(party0, party1);\n    }\n\n    function getGasCostOfPack(address party0, address party1)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        AddressPacking.pack(party0, party1);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    },
    "contracts/mocks/MarkToMarketMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract MarkToMarketMock {\n    function updatePV(bytes32 dealId) public pure {\n        return;\n    }\n\n    function updatePVs(bytes32[] memory dealIds) public pure {\n        return;\n    }\n}\n"
    },
    "contracts/test/StringsTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.12;\n\nimport \"../libraries/Strings.sol\";\n\ncontract StringsTest {\n    function isEqual(string memory text0, string memory text1)\n        external\n        view\n        returns (bool)\n    {\n        return Strings.isEqual(text0, text1);\n    }\n\n    function toHex(bytes32 _hash) external view returns (string memory) {\n        return Strings.toHex(_hash);\n    }\n\n    function toHex16(bytes16 _halfOfHash) external view returns (bytes32) {\n        return Strings.toHex16(_halfOfHash);\n    }\n\n    function getGasCostOfIsEqual(string memory text0, string memory text1)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        Strings.isEqual(text0, text1);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfToHex(bytes32 _hash) external view returns (uint256) {\n        uint256 gasBefore = gasleft();\n        Strings.toHex(_hash);\n\n        return gasBefore - gasleft();\n    }\n\n    function getGasCostOfToHex16(bytes16 _halfOfHash)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 gasBefore = gasleft();\n        Strings.toHex16(_halfOfHash);\n\n        return gasBefore - gasleft();\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}