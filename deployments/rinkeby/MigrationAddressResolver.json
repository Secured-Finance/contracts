{
  "address": "0xF31B086459C2cdaC006Feedd9080223964a9cDdB",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_addresses",
          "type": "address[]"
        }
      ],
      "name": "buildCaches",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xe759561c304d6e5ca0946d159f350a77eeb7b729c9d0fdfac238906bc38f39dd",
  "receipt": {
    "to": null,
    "from": "0xDBA767F3DFF3835BEf5dE1eDEe91A9901402AB21",
    "contractAddress": "0xF31B086459C2cdaC006Feedd9080223964a9cDdB",
    "transactionIndex": 23,
    "gasUsed": "196489",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x39b00dcb6730d9207b92b195970f288d91468eb0cfcea2b7e5b168c85891acaa",
    "transactionHash": "0xe759561c304d6e5ca0946d159f350a77eeb7b729c9d0fdfac238906bc38f39dd",
    "logs": [],
    "blockNumber": 10907135,
    "cumulativeGasUsed": "2515660",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "0fd5a5d025de86963d36bd38be3b6dce",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"buildCaches\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/migrations/MigrationAddressResolver.sol\":\"MigrationAddressResolver\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/interfaces/IAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IAddressResolver {\\n    event AddressImported(bytes32 name, address destination);\\n\\n    function getAddress(bytes32 name, string calldata reason) external view returns (address);\\n\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function getAddresses() external view returns (address[] memory);\\n}\\n\",\"keccak256\":\"0x85fea92a32d4ac0f08532d339ceeef07a468748ab7628bd2fd60980090e53a5d\",\"license\":\"MIT\"},\"contracts/interfaces/ICloseOutNetting.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ICloseOutNetting {\\n    event AddCloseOutPayments(\\n        address indexed party0,\\n        address indexed party1,\\n        bytes32 ccy,\\n        uint256 payment0,\\n        uint256 payment1\\n    );\\n    event RemoveCloseOutPayments(\\n        address indexed party0,\\n        address indexed party1,\\n        bytes32 ccy,\\n        uint256 payment0,\\n        uint256 payment1\\n    );\\n    event SettleCloseOut(\\n        address indexed party0,\\n        address indexed party1,\\n        bytes32 ccy,\\n        uint256 netPayment,\\n        bytes32 txHash\\n    );\\n    event VerifyCloseOut(\\n        address indexed party0,\\n        address indexed party1,\\n        bytes32 ccy,\\n        uint256 netPayment,\\n        bytes32 txHash\\n    );\\n\\n    function addPayments(\\n        address party0,\\n        address party1,\\n        bytes32 ccy,\\n        uint256 payment0,\\n        uint256 payment1\\n    ) external;\\n\\n    function checkDefault(address _party) external view returns (bool);\\n\\n    function removePayments(\\n        address party0,\\n        address party1,\\n        bytes32 ccy,\\n        uint256 payment0,\\n        uint256 payment1\\n    ) external;\\n}\\n\",\"keccak256\":\"0x6bbe6c9de500443c72cde8832c0ff9c921c6f38ace09523d3a1769f6e855830e\",\"license\":\"MIT\"},\"contracts/interfaces/ICollateralAggregatorV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ICollateralAggregator {\\n    event Register(address indexed addr);\\n    event Release(\\n        address indexed partyA,\\n        address indexed partyB,\\n        bytes32 ccy,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bool isSettled\\n    );\\n    event Liquidate(address indexed from, address indexed to, bytes32 ccy, uint256 amount);\\n    event ReleaseUnsettled(address indexed party, bytes32 ccy, uint256 amount);\\n    event SettleCollateral(\\n        address indexed partyA,\\n        address indexed partyB,\\n        bytes32 ccy,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n    event UpdatePV(\\n        address indexed partyA,\\n        address indexed partyB,\\n        bytes32 ccy,\\n        uint256 prevPV0,\\n        uint256 prevPV1,\\n        uint256 currentPV0,\\n        uint256 currentPV1\\n    );\\n    event UseCollateral(\\n        address indexed partyA,\\n        address indexed partyB,\\n        bytes32 ccy,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bool isSettled\\n    );\\n    event UseUnsettledCollateral(address indexed party, bytes32 ccy, uint256 amount);\\n\\n    function checkRegisteredUser(address addr) external view returns (bool);\\n\\n    function getCcyExposures(\\n        address partyA,\\n        address partyB,\\n        bytes32 ccy\\n    )\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function getCoverage(address _party0, address _party1) external view returns (uint256, uint256);\\n\\n    function getExposedCurrencies(address partyA, address partyB)\\n        external\\n        view\\n        returns (bytes32[] memory);\\n\\n    function getMaxCollateralBookWidthdraw(address _user)\\n        external\\n        view\\n        returns (uint256 maxWithdraw);\\n\\n    function getMaxCollateralWidthdraw(address _party0, address _party1)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function getNetAndTotalPV(address _party0, address _party1)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function getRebalanceCollateralAmounts(address _party0, address _party1)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function getTotalUnsettledExp(address _user) external view returns (uint256);\\n\\n    function getUnsettledCoverage(address _user) external view returns (uint256 coverage);\\n\\n    function isCovered(\\n        address _party0,\\n        address _party1,\\n        bytes32 _ccy,\\n        uint256 _party0PV,\\n        uint256 _party1PV,\\n        bool _isSettled\\n    ) external view returns (bool, bool);\\n\\n    function isCoveredUnsettled(\\n        address _user,\\n        bytes32 _ccy,\\n        uint256 _unsettledExp\\n    ) external view returns (bool);\\n\\n    function liquidate(\\n        address from,\\n        address to,\\n        uint256 liquidationInETH\\n    ) external;\\n\\n    function liquidate(\\n        address from,\\n        address to,\\n        bytes32 ccy,\\n        uint256 liquidationAmount,\\n        uint256 pv,\\n        bool isSettled\\n    ) external;\\n\\n    function register() external;\\n\\n    function register(string[] memory _addresses, uint256[] memory _chainIds) external;\\n\\n    function releaseCollateral(\\n        address partyA,\\n        address partyB,\\n        bytes32 ccy,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bool isSettled\\n    ) external;\\n\\n    function releaseUnsettledCollateral(\\n        address user,\\n        bytes32 ccy,\\n        uint256 amount\\n    ) external;\\n\\n    function settleCollateral(\\n        address partyA,\\n        address partyB,\\n        bytes32 ccy,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) external;\\n\\n    function updatePV(\\n        address party0,\\n        address party1,\\n        bytes32 ccy,\\n        uint256 prevPV0,\\n        uint256 prevPV1,\\n        uint256 currentPV0,\\n        uint256 currentPV1\\n    ) external;\\n\\n    function useCollateral(\\n        address partyA,\\n        address partyB,\\n        bytes32 ccy,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bool isSettled\\n    ) external;\\n\\n    function useUnsettledCollateral(\\n        address user,\\n        bytes32 ccy,\\n        uint256 amount\\n    ) external;\\n\\n    function getUnsettledCollateral(address user, bytes32 ccy) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x6ce0f77af603bba3166a03eebf4b1679a78491c64cce912331765889583a4369\",\"license\":\"MIT\"},\"contracts/interfaces/ICollateralVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ICollateralVault {\\n    event Deposit(address user, bytes32 ccy, uint256 amount);\\n    event PositionDeposit(address user, address counterparty, bytes32 ccy, uint256 amount);\\n    event RebalanceBetween(\\n        address user,\\n        address fromCounterparty,\\n        address toCounterparty,\\n        bytes32 ccy,\\n        uint256 amount\\n    );\\n    event RebalanceFrom(address user, address counterparty, bytes32 ccy, uint256 amount);\\n    event RebalanceTo(address user, address counterparty, bytes32 ccy, uint256 amount);\\n    event Withdraw(address from, bytes32 ccy, uint256 amount);\\n    event PositionWithdraw(address from, address counterparty, bytes32 ccy, uint256 amount);\\n    event Liquidate(address from, address to, bytes32 ccy, uint256 amount);\\n    event LiquidateIndependent(address from, address to, bytes32 ccy, uint256 amount);\\n\\n    function deposit(\\n        address _counterparty,\\n        bytes32 _ccy,\\n        uint256 _amount\\n    ) external;\\n\\n    function deposit(bytes32 _ccy, uint256 _amount) external payable;\\n\\n    function getIndependentCollateral(address _user, bytes32 _ccy) external view returns (uint256);\\n\\n    function getIndependentCollateralInETH(address _user, bytes32 _ccy)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getLockedCollateral(address _user, bytes32 _ccy) external view returns (uint256);\\n\\n    function getLockedCollateralInETH(address _user, bytes32 _ccy) external view returns (uint256);\\n\\n    function getLockedCollateral(\\n        address _partyA,\\n        address _partyB,\\n        bytes32 _ccy\\n    ) external view returns (uint256, uint256);\\n\\n    function getLockedCollateralInETH(\\n        address _partyA,\\n        address _partyB,\\n        bytes32 _ccy\\n    ) external view returns (uint256, uint256);\\n\\n    function liquidate(\\n        address _from,\\n        address _to,\\n        uint256 _liquidationTarget\\n    ) external returns (bool);\\n\\n    function rebalanceCollateral(\\n        address _party0,\\n        address _party1,\\n        uint256 _rebalanceTarget,\\n        bool isRebalanceFrom\\n    ) external returns (bool);\\n\\n    function rebalanceBetween(\\n        address _user,\\n        address _fromParty,\\n        address _toParty,\\n        bytes32 _ccy,\\n        uint256 _amountETH\\n    ) external returns (uint256);\\n\\n    function withdraw(bytes32 _ccy, uint256 _amount) external;\\n\\n    function withdrawFrom(\\n        address _counterparty,\\n        bytes32 _ccy,\\n        uint256 _amount\\n    ) external;\\n\\n    function getUsedCurrencies(address user) external view returns (bytes32[] memory);\\n\\n    function getUsedCurrencies(address party0, address party1)\\n        external\\n        view\\n        returns (bytes32[] memory);\\n\\n    function getTotalIndependentCollateralInETH(address _party) external view returns (uint256);\\n\\n    function getTotalLockedCollateralInETH(address _party0, address _party1)\\n        external\\n        view\\n        returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0x05a973a84165750802bf97f2c889467191ae0a99fb50221149f46b9df35bdd6e\",\"license\":\"MIT\"},\"contracts/interfaces/ICrosschainAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ICrosschainAddressResolver {\\n    event UpdateAddress(address _user, uint256 _chainId, string _address);\\n\\n    /**\\n     * @dev Trigers to register multiple cross-chain addresses per chainId for user\\n     * @param _user Secured Finance user ETH address\\n     * @param _chainIds Array of chain ID number\\n     * @param _addresses Array of the target blockchain addresses\\n     *\\n     * @notice This function triggers by the Collateral Aggregator while user is registered in a system\\n     *\\n     */\\n    function updateAddresses(\\n        address _user,\\n        uint256[] memory _chainIds,\\n        string[] memory _addresses\\n    ) external;\\n\\n    /**\\n     * @dev Trigers to register cross-chain address per chainId by user\\n     * @param _chainId Chain ID number\\n     * @param _address Target blockchain address\\n     *\\n     */\\n    function updateAddress(uint256 _chainId, string memory _address) external;\\n\\n    /**\\n     * @dev Trigers to register cross-chain address per chainId by user\\n     * @param _user Secured Finance user ETH address\\n     * @param _chainId Chain ID number\\n     * @param _address Target blockchain address\\n     *\\n     */\\n    function updateAddress(\\n        address _user,\\n        uint256 _chainId,\\n        string memory _address\\n    ) external;\\n\\n    /**\\n     * @dev Trigers to get target blockchain address for a specific user.\\n     * @param _user Ethereum address of the Secured Finance user\\n     * @param _user Chain ID number\\n     */\\n    function getUserAddress(address _user, uint256 _chainId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x6ef89efa2bd508258da18e2ca2699cb07847d75d6df996cde56b8f6d524d7db8\",\"license\":\"MIT\"},\"contracts/interfaces/ICurrencyController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../types/ProtocolTypes.sol\\\";\\n\\n/**\\n * @dev Currency Controller contract is responsible for managing supported\\n * currencies in Secured Finance Protocol\\n *\\n * Contract links new currencies to ETH Chainlink price feeds, without existing price feed\\n * contract owner is not able to add a new currency into the protocol\\n */\\ninterface ICurrencyController {\\n    event CcyAdded(bytes32 indexed ccy, string name, uint16 chainId, uint256 haircut);\\n    event CcyCollateralUpdate(bytes32 indexed ccy, bool isCollateral);\\n    event CcySupportUpdate(bytes32 indexed ccy, bool isSupported);\\n    event HaircutUpdated(bytes32 indexed ccy, uint256 haircut);\\n    event MinMarginUpdated(bytes32 indexed ccy, uint256 minMargin);\\n    event PriceFeedAdded(bytes32 ccy, string secondCcy, address indexed priceFeed);\\n    event PriceFeedRemoved(bytes32 ccy, string secondCcy, address indexed priceFeed);\\n\\n    function convertBulkToETH(bytes32 _ccy, uint256[] memory _amounts)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function convertFromETH(bytes32 _ccy, uint256 _amountETH) external view returns (uint256);\\n\\n    function convertToETH(bytes32 _ccy, uint256 _amount) external view returns (uint256);\\n\\n    function getCurrencies(bytes32) external view returns (ProtocolTypes.Currency memory);\\n\\n    function getEthDecimals(bytes32) external view returns (uint8);\\n\\n    function getUsdDecimals(bytes32) external view returns (uint8);\\n\\n    function getHaircut(bytes32 _ccy) external view returns (uint256);\\n\\n    function getHistoricalETHPrice(bytes32 _ccy, uint80 _roundId) external view returns (int256);\\n\\n    function getHistoricalUSDPrice(bytes32 _ccy, uint80 _roundId) external view returns (int256);\\n\\n    function getLastETHPrice(bytes32 _ccy) external view returns (int256);\\n\\n    function getLastUSDPrice(bytes32 _ccy) external view returns (int256);\\n\\n    function getMinMargin(bytes32 _ccy) external view returns (uint256);\\n\\n    function getChainId(bytes32 _ccy) external view returns (uint16);\\n\\n    function isCollateral(bytes32) external view returns (bool);\\n\\n    function isSupportedCcy(bytes32 _ccy) external view returns (bool);\\n\\n    function linkPriceFeed(\\n        bytes32 _ccy,\\n        address _priceFeedAddr,\\n        bool _isEthPriceFeed\\n    ) external returns (bool);\\n\\n    function removePriceFeed(bytes32 _ccy, bool _isEthPriceFeed) external;\\n\\n    function supportCurrency(\\n        bytes32 _ccy,\\n        string memory _name,\\n        uint16 _chainId,\\n        address _ethPriceFeed,\\n        uint256 _haircut,\\n        address _tokenAddress\\n    ) external;\\n\\n    function updateCcyHaircut(bytes32 _ccy, uint256 _haircut) external;\\n\\n    function updateCollateralSupport(bytes32 _ccy, bool _isSupported) external;\\n\\n    function updateCurrencySupport(bytes32 _ccy, bool _isSupported) external;\\n\\n    function updateMinMargin(bytes32 _ccy, uint256 _minMargin) external;\\n\\n    function getTokenAddresses(bytes32) external view returns (address);\\n}\\n\",\"keccak256\":\"0x0bad90929934b6a43200ae276697a9e428d47b119120ea81208778ced9abbe76\",\"license\":\"MIT\"},\"contracts/interfaces/IExternalAdapterTxResponse.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IExternalAdapterTxResponse {\\n    struct FulfillData {\\n        string from;\\n        string to;\\n        uint256 value;\\n        uint256 timestamp;\\n        string txHash;\\n    }\\n}\\n\",\"keccak256\":\"0x2fde36d406ead00758aeccdf58fd8be1b32cf2fd3fd2061824d538bd06d4ab4c\",\"license\":\"MIT\"},\"contracts/interfaces/ILendingMarketController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../types/ProtocolTypes.sol\\\";\\n\\nstruct Order {\\n    bytes32 ccy;\\n    uint256 term;\\n    ProtocolTypes.Side side;\\n    uint256 amount;\\n    uint256 rate;\\n}\\n\\ninterface ILendingMarketController {\\n    event LendingMarketCreated(bytes32 ccy, uint256 term, address indexed marketAddr);\\n    event LendingMarketsPaused(bytes32 ccy);\\n    event LendingMarketsUnpaused(bytes32 ccy);\\n\\n    function deployLendingMarket(bytes32 _ccy, uint256 _term) external returns (address market);\\n\\n    function getBorrowRatesForCcy(bytes32 _ccy) external view returns (uint256[] memory rates);\\n\\n    function getDiscountFactorsForCcy(bytes32 _ccy)\\n        external\\n        view\\n        returns (uint256[] memory, uint256[] memory);\\n\\n    function getLendRatesForCcy(bytes32 _ccy) external view returns (uint256[] memory rates);\\n\\n    function getMidRatesForCcy(bytes32 _ccy) external view returns (uint256[] memory rates);\\n\\n    function getLendingMarket(bytes32, uint256) external view returns (address);\\n\\n    function pauseLendingMarkets(bytes32 _ccy) external returns (bool);\\n\\n    function placeBulkOrders(Order[] memory orders) external returns (bool);\\n\\n    function unpauseLendingMarkets(bytes32 _ccy) external returns (bool);\\n\\n    function getSupportedTerms(bytes32 _ccy) external view returns (uint256[] memory);\\n}\\n\",\"keccak256\":\"0x8c2a321d93fb14a1878ffb332e03d8201c4998ecca88b8862347855787ebf49c\",\"license\":\"MIT\"},\"contracts/interfaces/ILiquidations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ILiquidations {\\n    event DealAddedToLiquidationQueue(address party0, address party1, bytes32 dealId);\\n    event DealRemovedFromLiquidationQueue(address party0, address party1, bytes32 dealId);\\n    event LiquidationAgentAdded(address indexed liquidationAgent);\\n    event LiquidationAgentRemoved(address indexed liquidationAgent);\\n    event OffsetUpdated(uint256 oldOffset, uint256 newOffset);\\n\\n    function addDealToLiquidationQueue(\\n        address party0,\\n        address party1,\\n        bytes32 dealId\\n    ) external;\\n\\n    function addLiquidationAgent(address _liquidationAgent) external;\\n\\n    function liquidateDeals(\\n        address party0,\\n        address party1,\\n        bytes32[] memory dealIds\\n    ) external;\\n\\n    function liquidateDeals(address party0, address party1) external;\\n\\n    function getOffset() external view returns (uint256);\\n\\n    function removeDealFromLiquidationQueue(\\n        address party0,\\n        address party1,\\n        bytes32 dealId\\n    ) external;\\n\\n    function removeLiquidationAgent(address _liquidationAgent) external;\\n\\n    function updateLiquidationOffset(uint256 _offset) external;\\n}\\n\",\"keccak256\":\"0x4e2784b0014ff688a60c4628cc1ebab63ca0aa40aa9949dbde6d53c69dbe3746\",\"license\":\"MIT\"},\"contracts/interfaces/IMarkToMarket.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IMarkToMarket {\\n    function updatePV(bytes32 dealId) external;\\n\\n    function updatePVs(bytes32[] memory dealIds) external;\\n}\\n\",\"keccak256\":\"0xb100f8c173fda11136c5579306d99065752bb797bff6ffe91c64eee228ae2df9\",\"license\":\"MIT\"},\"contracts/interfaces/IPaymentAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nstruct Slot {\\n    uint256 totalPayment0;\\n    uint256 totalPayment1;\\n    uint256 netPayment;\\n    bool flipped;\\n    bytes32 paymentProof;\\n    address verificationParty;\\n    bool isSettled;\\n}\\n\\ninterface IPaymentAggregator {\\n    event RegisterPayment(\\n        address indexed party0,\\n        address indexed party1,\\n        bytes32 ccy,\\n        bytes32 timeSlot,\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 payment0,\\n        uint256 payment1\\n    );\\n    event VerifyPayment(\\n        address indexed verifier,\\n        address indexed counterparty,\\n        bytes32 ccy,\\n        bytes32 timeSlot,\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 payment,\\n        bytes32 settlementId\\n    );\\n    event SettlePayment(\\n        address indexed verifier,\\n        address indexed counterparty,\\n        bytes32 ccy,\\n        bytes32 timeSlot,\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        bytes32 settlementId\\n    );\\n    event RemovePayment(\\n        address indexed party0,\\n        address indexed party1,\\n        bytes32 ccy,\\n        bytes32 timeSlot,\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 payment0,\\n        uint256 payment1\\n    );\\n\\n    function registerPayments(\\n        address party0,\\n        address party1,\\n        bytes32 ccy,\\n        bytes32 dealId,\\n        uint256[] memory timestamps,\\n        uint256[] memory payments0,\\n        uint256[] memory payments1\\n    ) external;\\n\\n    function removePayments(\\n        address party0,\\n        address party1,\\n        bytes32 ccy,\\n        bytes32 dealId,\\n        uint256[] calldata timestamps,\\n        uint256[] calldata payments0,\\n        uint256[] calldata payments1\\n    ) external;\\n\\n    function verifyPayment(\\n        address verifier,\\n        address counterparty,\\n        bytes32 ccy,\\n        uint256 timestamp,\\n        uint256 payment,\\n        bytes32 settlementId\\n    ) external;\\n\\n    function isSettled(\\n        address party0,\\n        address party1,\\n        bytes32 ccy,\\n        uint256 timestamp\\n    ) external view returns (bool status);\\n\\n    function getDealsFromSlot(\\n        address party0,\\n        address party1,\\n        bytes32 ccy,\\n        bytes32 slotPosition\\n    ) external view returns (bytes32[] memory);\\n\\n    // function getTimeSlotByDate(\\n    //     address party0,\\n    //     address party1,\\n    //     bytes32 ccy,\\n    //     uint256 year,\\n    //     uint256 month,\\n    //     uint256 day\\n    // ) external view returns (Slot memory timeSlot);\\n\\n    // function getTimeSlotBySlotId(\\n    //     address party0,\\n    //     address party1,\\n    //     bytes32 ccy,\\n    //     bytes32 slot\\n    // ) external view returns (Slot memory timeSlot);\\n\\n    function checkSettlementWindow(uint256 targetTime) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x626f4bb7d28a476b21c2bc18278a091f134fbd98a6e06e586cd63180184518f4\",\"license\":\"MIT\"},\"contracts/interfaces/IProductAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface IProductAddressResolver {\\n    event RegisterProduct(bytes4 prefix, address indexed product, address indexed controller);\\n\\n    /**\\n     * @dev Triggers to register new product type in a address resolver\\n     * @param _prefix Bytes4 prefix for product type\\n     * @param _contract Product contract address\\n     * @param _controller Market controller address\\n     *\\n     * @notice Triggers only be contract owner\\n     * @notice Reverts on saving contract which is not supporting a common interface\\n     */\\n    function registerProduct(\\n        bytes4 _prefix,\\n        address _contract,\\n        address _controller\\n    ) external;\\n\\n    /**\\n     * @dev Triggers to register several product types in a address resolver\\n     * @param _prefixes Array of Bytes4 prefixes for each product type\\n     * @param _contracts Array of smart contract addresses for each product\\n     * @param _controllers Array of market controller addresses\\n     *\\n     * @notice Triggers only be contract owner\\n     * @notice Reverts on saving contract which is not supporting common interface\\n     */\\n    function registerProducts(\\n        bytes4[] calldata _prefixes,\\n        address[] calldata _contracts,\\n        address[] calldata _controllers\\n    ) external;\\n\\n    /**\\n     * @dev Triggers to get product address by short prefix.\\n     * @param _prefix Bytes4 prefix for product type\\n     * @notice To work with the contract this address should be wrapped around IProduct interface\\n     */\\n    function getProductContract(bytes4 _prefix) external view returns (address);\\n\\n    /**\\n     * @dev Triggers to get product addresses\\n     * @notice To work with the contract this address should be wrapped around IProduct interface\\n     */\\n    function getProductContracts() external view returns (address[] memory);\\n\\n    /**\\n     * @dev Triggers to get product address by deal id\\n     * @param _dealId Product deal idenfitier\\n     * @notice To work with the contract this address should be wrapped around IProduct interface\\n     */\\n    function getProductContractByDealId(bytes32 _dealId) external view returns (address);\\n\\n    /**\\n     * @dev Triggers to get market controller address by short prefix.\\n     * @param _prefix Bytes4 prefix for product type\\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\\n     */\\n    function getControllerContract(bytes4 _prefix) external view returns (address);\\n\\n    /**\\n     * @dev Triggers to get market controller address by deal id\\n     * @param _dealId Product deal idenfitier\\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\\n     */\\n    function getControllerContractByDealId(bytes32 _dealId) external view returns (address);\\n\\n    /**\\n     * @dev Triggers to verify if a specific product is supported by short prefix.\\n     * @param _prefix Bytes4 prefix for product type\\n     */\\n    function isSupportedProduct(bytes4 _prefix) external view returns (bool);\\n\\n    /**\\n     * @dev Triggers to verify if a specific product is supported by deal id.\\n     * @param _dealId Product deal idenfitier\\n     */\\n    function isSupportedProductByDealId(bytes32 _dealId) external view returns (bool);\\n\\n    /**\\n     * @dev Triggers to verify if a specific product contract is registered.\\n     * @param _product Product contract address\\n     */\\n    function isRegisteredProductContract(address _product) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x44855f57913172a86e203a89d7713efe1ec39351a0830b0f35fac9ffa24ec770\",\"license\":\"MIT\"},\"contracts/interfaces/ISettlementEngine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.5.3. SEE SOURCE BELOW. !!\\npragma solidity ^0.8.9;\\n\\nimport \\\"./IExternalAdapterTxResponse.sol\\\";\\nimport \\\"../types/ProtocolTypes.sol\\\";\\n\\ninterface ISettlementEngine {\\n    event CrosschainSettlementRequested(\\n        address payer,\\n        address receiver,\\n        uint16 chainId,\\n        uint256 timestamp,\\n        string txHash,\\n        bytes32 requestId\\n    );\\n    event CrosschainSettlementRequestFulfilled(\\n        string payer,\\n        string receiver,\\n        uint16 chainId,\\n        uint256 amount,\\n        uint256 timestamp,\\n        string txHash,\\n        bytes32 settlementId\\n    );\\n    event ExternalAdapterAdded(address indexed adapter, bytes32 ccy);\\n\\n    function addExternalAdapter(address _adapter, bytes32 _ccy) external;\\n\\n    function getExternalAdapters(bytes32) external view returns (address);\\n\\n    function fulfillSettlementRequest(\\n        bytes32 _requestId,\\n        IExternalAdapterTxResponse.FulfillData calldata _txData,\\n        bytes32 _ccy\\n    ) external;\\n\\n    function getVersion() external view returns (uint16);\\n\\n    function getSettlementRequests(bytes32)\\n        external\\n        view\\n        returns (ProtocolTypes.SettlementRequest memory);\\n\\n    function verifyPayment(\\n        address _counterparty,\\n        bytes32 _ccy,\\n        uint256 _payment,\\n        uint256 _timestamp,\\n        string calldata _txHash\\n    ) external payable returns (bytes32);\\n}\\n\",\"keccak256\":\"0x3888a41e40b8eb2cebf8557436b0f09286dfaeb08a3762a33c0a6ae0521f67a3\",\"license\":\"MIT\"},\"contracts/interfaces/ITermStructure.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\ninterface ITermStructure {\\n    event TermAdded(uint256 numDays);\\n    event ProductTermSupportUpdated(\\n        uint256 numDays,\\n        bytes4 product,\\n        bytes32 _ccy,\\n        bool isSupported\\n    );\\n    event TermSupportUpdated(uint256 numDays, bool isSupported);\\n\\n    function getDfFrac(uint256 _numDays) external view returns (uint256);\\n\\n    function getNumDays(uint256 _numDays) external view returns (uint256);\\n\\n    function getNumPayments(uint256 _numDays, uint8 frequency) external view returns (uint256);\\n\\n    function getTerm(uint256 _numDays, uint8 frequency)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function getTermSchedule(uint256 _numDays, uint8 frequency)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    function isSupportedTerm(\\n        uint256 _numDays,\\n        bytes4 _product,\\n        bytes32 _ccy\\n    ) external view returns (bool);\\n\\n    function supportTerm(\\n        uint256 _numDays,\\n        bytes4[] memory _products,\\n        bytes32[] memory _currencies\\n    ) external;\\n\\n    function updateTermSupport(\\n        uint256 _numDays,\\n        bytes4 _product,\\n        bytes32 _ccy,\\n        bool _isSupported\\n    ) external;\\n\\n    function getTermsForProductAndCcy(\\n        bytes4 _product,\\n        bytes32 _ccy,\\n        bool sort\\n    ) external view returns (uint256[] memory);\\n}\\n\",\"keccak256\":\"0x8509c4f927878626ee8cb73d0fb2daa0cf0a7c9869bb6241ccc180d0854544f4\",\"license\":\"MIT\"},\"contracts/libraries/Contracts.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nlibrary Contracts {\\n    bytes32 internal constant CLOSE_OUT_NETTING = \\\"CloseOutNetting\\\";\\n    bytes32 internal constant COLLATERAL_AGGREGATOR = \\\"CollateralAggregator\\\";\\n    bytes32 internal constant COLLATERAL_VAULT = \\\"CollateralVault\\\";\\n    bytes32 internal constant CROSSCHAIN_ADDRESS_RESOLVER = \\\"CrosschainAddressResolver\\\";\\n    bytes32 internal constant CURRENCY_CONTROLLER = \\\"CurrencyController\\\";\\n    bytes32 internal constant LENDING_MARKET_CONTROLLER = \\\"LendingMarketController\\\";\\n    bytes32 internal constant LIQUIDATIONS = \\\"Liquidations\\\";\\n    bytes32 internal constant MARK_TO_MARKET = \\\"MarkToMarket\\\";\\n    bytes32 internal constant PAYMENT_AGGREGATOR = \\\"PaymentAggregator\\\";\\n    bytes32 internal constant PRODUCT_ADDRESS_RESOLVER = \\\"ProductAddressResolver\\\";\\n    bytes32 internal constant SETTLEMENT_ENGINE = \\\"SettlementEngine\\\";\\n    bytes32 internal constant TERM_STRUCTURE = \\\"TermStructure\\\";\\n}\\n\",\"keccak256\":\"0x939f50a87aa51db235c78c3c224edc9123271a5b44974e13557e4590958e83df\",\"license\":\"MIT\"},\"contracts/migrations/MigrationAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../mixins/MixinAddressResolver.sol\\\";\\n\\ncontract MigrationAddressResolver {\\n    function buildCaches(address[] calldata _addresses) external {\\n        for (uint256 i = 0; i < _addresses.length; i++) {\\n            MixinAddressResolver destination = MixinAddressResolver(_addresses[i]);\\n            if (!destination.isResolverCached()) {\\n                destination.buildCache();\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xcde5ece4ce2b9b66f4b334c8119b6bda2b5fb7d624af1a5457a11727d62ebb12\",\"license\":\"MIT\"},\"contracts/mixins/MixinAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"../libraries/Contracts.sol\\\";\\nimport \\\"../interfaces/IAddressResolver.sol\\\";\\nimport \\\"../interfaces/ICloseOutNetting.sol\\\";\\nimport \\\"../interfaces/ICollateralAggregatorV2.sol\\\";\\nimport \\\"../interfaces/ICollateralVault.sol\\\";\\nimport \\\"../interfaces/ICrosschainAddressResolver.sol\\\";\\nimport \\\"../interfaces/ICurrencyController.sol\\\";\\nimport \\\"../interfaces/IMarkToMarket.sol\\\";\\nimport \\\"../interfaces/ILendingMarketController.sol\\\";\\nimport \\\"../interfaces/ILiquidations.sol\\\";\\nimport \\\"../interfaces/IPaymentAggregator.sol\\\";\\nimport \\\"../interfaces/IProductAddressResolver.sol\\\";\\nimport \\\"../interfaces/ISettlementEngine.sol\\\";\\nimport \\\"../interfaces/ITermStructure.sol\\\";\\n\\ncontract MixinAddressResolver {\\n    event CacheUpdated(bytes32 name, address destination);\\n\\n    IAddressResolver public resolver;\\n\\n    mapping(bytes32 => address) private addressCache;\\n\\n    modifier onlyAcceptedContracts() {\\n        require(isAcceptedContract(msg.sender), \\\"Only Accepted Contracts\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns required contract names in this contract\\n     */\\n    function requiredContracts() public pure virtual returns (bytes32[] memory contracts) {}\\n\\n    /**\\n     * @dev Returns contract names that can call this contract.\\n     */\\n    function acceptedContracts() public pure virtual returns (bytes32[] memory contracts) {}\\n\\n    function buildCache() public {\\n        // The resolver must call this function whenever it updates its state\\n        bytes32[] memory contractNames = requiredContracts();\\n        for (uint256 i = 0; i < contractNames.length; i++) {\\n            bytes32 name = contractNames[i];\\n            // Note: can only be invoked once the resolver has all the targets needed added\\n            address destination = resolver.getAddress(\\n                name,\\n                string(abi.encodePacked(\\\"Resolver missing target: \\\", name))\\n            );\\n            addressCache[name] = destination;\\n            emit CacheUpdated(name, destination);\\n        }\\n    }\\n\\n    function isResolverCached() external view returns (bool) {\\n        bytes32[] memory contractNames = requiredContracts();\\n        for (uint256 i = 0; i < contractNames.length; i++) {\\n            bytes32 name = contractNames[i];\\n            // false if our cache is invalid or if the resolver doesn't have the required address\\n            if (\\n                resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)\\n            ) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Register the Address Resolver contract\\n     * @param _resolver The address of the Address Resolver contract\\n     */\\n    function registerAddressResolver(address _resolver) internal {\\n        require(address(resolver) == address(0), \\\"resolver registered already\\\");\\n        resolver = IAddressResolver(_resolver);\\n    }\\n\\n    function getAddress(bytes32 name) internal view returns (address) {\\n        address _foundAddress = addressCache[name];\\n        require(_foundAddress != address(0), string(abi.encodePacked(\\\"Missing address: \\\", name)));\\n        return _foundAddress;\\n    }\\n\\n    function isAcceptedContract(address account) internal view virtual returns (bool) {\\n        bytes32[] memory contractNames = acceptedContracts();\\n        for (uint256 i = 0; i < contractNames.length; i++) {\\n            if (account == getAddress(contractNames[i])) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function closeOutNetting() internal view returns (ICloseOutNetting) {\\n        return ICloseOutNetting(getAddress(Contracts.CLOSE_OUT_NETTING));\\n    }\\n\\n    function collateralAggregator() internal view returns (ICollateralAggregator) {\\n        return ICollateralAggregator(getAddress(Contracts.COLLATERAL_AGGREGATOR));\\n    }\\n\\n    function collateralVault() internal view returns (ICollateralVault) {\\n        return ICollateralVault(getAddress(Contracts.COLLATERAL_VAULT));\\n    }\\n\\n    function crosschainAddressResolver() internal view returns (ICrosschainAddressResolver) {\\n        return ICrosschainAddressResolver(getAddress(Contracts.CROSSCHAIN_ADDRESS_RESOLVER));\\n    }\\n\\n    function currencyController() internal view returns (ICurrencyController) {\\n        return ICurrencyController(getAddress(Contracts.CURRENCY_CONTROLLER));\\n    }\\n\\n    function markToMarket() internal view returns (IMarkToMarket) {\\n        return IMarkToMarket(getAddress(Contracts.MARK_TO_MARKET));\\n    }\\n\\n    function lendingMarketController() internal view returns (ILendingMarketController) {\\n        return ILendingMarketController(getAddress(Contracts.LENDING_MARKET_CONTROLLER));\\n    }\\n\\n    function liquidations() internal view returns (ILiquidations) {\\n        return ILiquidations(getAddress(Contracts.LIQUIDATIONS));\\n    }\\n\\n    function paymentAggregator() internal view returns (IPaymentAggregator) {\\n        return IPaymentAggregator(getAddress(Contracts.PAYMENT_AGGREGATOR));\\n    }\\n\\n    function productAddressResolver() internal view returns (IProductAddressResolver) {\\n        return IProductAddressResolver(getAddress(Contracts.PRODUCT_ADDRESS_RESOLVER));\\n    }\\n\\n    function settlementEngine() internal view returns (ISettlementEngine) {\\n        return ISettlementEngine(getAddress(Contracts.SETTLEMENT_ENGINE));\\n    }\\n\\n    function termStructure() internal view returns (ITermStructure) {\\n        return ITermStructure(getAddress(Contracts.TERM_STRUCTURE));\\n    }\\n}\\n\",\"keccak256\":\"0xa11e12f5ac8a1710ad3f16fb7d867e615ed13dd98324eea2f7eb36c00b21c2fb\",\"license\":\"MIT\"},\"contracts/types/ProtocolTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\n/**\\n * @dev ProtocolTypes is a base-level contract that holds common Secured Finance protocol types\\n * @author Secured Finance\\n */\\nlibrary ProtocolTypes {\\n    // Constant values\\n    uint256 public constant BP = 10000; // basis point\\n    uint256 public constant PCT = 10000; // percentage point in basis\\n    uint256 public constant PENALTYLEVEL = 1000; // 10% settlement failure penalty\\n    uint256 public constant MKTMAKELEVEL = 2000; // 20% for market making\\n\\n    // Lending market common types\\n    enum Side {\\n        LEND,\\n        BORROW\\n    }\\n    enum Ccy {\\n        ETH,\\n        FIL,\\n        USDC,\\n        BTC\\n    }\\n\\n    // Loan common types\\n    enum LoanState {\\n        REGISTERED,\\n        WORKING,\\n        DUE,\\n        PAST_DUE,\\n        CLOSED,\\n        TERMINATED\\n    }\\n    enum DFTERM {\\n        _3m,\\n        _6m,\\n        _1y,\\n        _2y,\\n        _3y,\\n        _4y,\\n        _5y\\n    }\\n\\n    // Collateral common types\\n    enum CollateralState {\\n        EMPTY,\\n        AVAILABLE,\\n        IN_USE,\\n        MARGIN_CALL,\\n        LIQUIDATION_IN_PROGRESS,\\n        LIQUIDATION\\n    }\\n\\n    // FXMarket common types\\n    enum CcyPair {\\n        FILETH,\\n        FILUSDC,\\n        ETHUSDC,\\n        BTCUSDC,\\n        BTCETH,\\n        BTCFIL\\n    }\\n    enum FXSide {\\n        BID,\\n        OFFER\\n    }\\n\\n    enum PaymentFrequency {\\n        ANNUAL,\\n        SEMI_ANNUAL,\\n        QUARTERLY,\\n        MONTHLY,\\n        FORWARD\\n    }\\n\\n    struct Currency {\\n        bool isSupported;\\n        string name;\\n        uint16 chainId; // chain id for address conversion\\n    }\\n\\n    struct SettlementRequest {\\n        address payer;\\n        address receiver;\\n        uint16 chainId;\\n        uint256 timestamp;\\n        string txHash;\\n    }\\n}\\n\",\"keccak256\":\"0x6419e0bcd07b8ff86e0ffce1e7f16e9a38a470f0ab2f697af0f5234cb943303f\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610298806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c806367ba79c814610030575b600080fd5b61004361003e36600461015c565b610045565b005b60005b81811015610157576000838383818110610064576100646101d1565b905060200201602081019061007991906101e7565b9050806001600160a01b0316632af64bd36040518163ffffffff1660e01b815260040160206040518083038186803b1580156100b457600080fd5b505afa1580156100c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100ec9190610217565b61014457806001600160a01b03166329985e5a6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561012b57600080fd5b505af115801561013f573d6000803e3d6000fd5b505050505b508061014f81610239565b915050610048565b505050565b6000806020838503121561016f57600080fd5b823567ffffffffffffffff8082111561018757600080fd5b818501915085601f83011261019b57600080fd5b8135818111156101aa57600080fd5b8660208260051b85010111156101bf57600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052603260045260246000fd5b6000602082840312156101f957600080fd5b81356001600160a01b038116811461021057600080fd5b9392505050565b60006020828403121561022957600080fd5b8151801515811461021057600080fd5b600060001982141561025b57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220db5b9781f38227eb75690d8f865c6c6b6415a333a495ef805d8c271ceb3ed5eb64736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c806367ba79c814610030575b600080fd5b61004361003e36600461015c565b610045565b005b60005b81811015610157576000838383818110610064576100646101d1565b905060200201602081019061007991906101e7565b9050806001600160a01b0316632af64bd36040518163ffffffff1660e01b815260040160206040518083038186803b1580156100b457600080fd5b505afa1580156100c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906100ec9190610217565b61014457806001600160a01b03166329985e5a6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561012b57600080fd5b505af115801561013f573d6000803e3d6000fd5b505050505b508061014f81610239565b915050610048565b505050565b6000806020838503121561016f57600080fd5b823567ffffffffffffffff8082111561018757600080fd5b818501915085601f83011261019b57600080fd5b8135818111156101aa57600080fd5b8660208260051b85010111156101bf57600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052603260045260246000fd5b6000602082840312156101f957600080fd5b81356001600160a01b038116811461021057600080fd5b9392505050565b60006020828403121561022957600080fd5b8151801515811461021057600080fd5b600060001982141561025b57634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220db5b9781f38227eb75690d8f865c6c6b6415a333a495ef805d8c271ceb3ed5eb64736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}