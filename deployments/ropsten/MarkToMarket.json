{
  "address": "0x4E599754188C4772696BB9A85F435Df02275cE29",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_productResolver",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "dealId",
          "type": "bytes32"
        }
      ],
      "name": "updatePV",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "dealIds",
          "type": "bytes32[]"
        }
      ],
      "name": "updatePVs",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xdd678c0ab604c179a5b79c940cce173db729036de9f3645b5bd1c878e514a320",
  "receipt": {
    "to": null,
    "from": "0x57AB42d4fa756b6956b0cAf986a5f53bA90D9e28",
    "contractAddress": "0x4E599754188C4772696BB9A85F435Df02275cE29",
    "transactionIndex": 24,
    "gasUsed": "382201",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x0ff96a8af4b6f7d52e03fd6c57b7a15faa55e9b772256b99f01d8a16e3feac53",
    "transactionHash": "0xdd678c0ab604c179a5b79c940cce173db729036de9f3645b5bd1c878e514a320",
    "logs": [],
    "blockNumber": 12167919,
    "cumulativeGasUsed": "1358616",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x3Bb006345DA94AA05BEBD0Ec70CBe6f28A017cEe"
  ],
  "numDeployments": 1,
  "solcInputHash": "48d264388c4204a72ee447cb1af8bee3",
  "metadata": "{\"compiler\":{\"version\":\"0.6.12+commit.27d51765\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_productResolver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dealId\",\"type\":\"bytes32\"}],\"name\":\"updatePV\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"dealIds\",\"type\":\"bytes32[]\"}],\"name\":\"updatePVs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Contract constructor function.\"},\"updatePV(bytes32)\":{\"details\":\"Triggers to update present value for a single deal.\",\"params\":{\"dealId\":\"Deal ID to update PV for\"}},\"updatePVs(bytes32[])\":{\"details\":\"Triggers to update present value for a multiple deals.\",\"params\":{\"dealIds\":\"Array of Deal IDs to update PV for\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"constructor\":\"sets contract deployer as owner of this contract and connects to product address resolver contract\"},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MarkToMarket.sol\":\"MarkToMarket\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xcc78a17dd88fa5a2edc60c8489e2f405c0913b377216a5b26b35656b2d0dab52\",\"license\":\"MIT\"},\"contracts/MarkToMarket.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ProtocolTypes.sol\\\";\\nimport \\\"./interfaces/IMarketController.sol\\\";\\nimport \\\"./interfaces/IMarkToMarket.sol\\\";\\nimport \\\"./interfaces/IPaymentAggregator.sol\\\";\\nimport \\\"./interfaces/IProduct.sol\\\";\\nimport \\\"./interfaces/IProductAddressResolver.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract MarkToMarket is IMarkToMarket {\\n    using SafeMath for uint256;\\n\\n    uint256 constant NOTICE = 2 weeks;\\n    address public owner;\\n\\n    // Contracts\\n    IProductAddressResolver productResolver;\\n    IPaymentAggregator paymentAggregator;\\n\\n    /**\\n     * @dev Modifier to make a function callable only by contract owner.\\n     */\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    /**\\n     * @dev Contract constructor function.\\n     *\\n     * @notice sets contract deployer as owner of this contract and connects to product address resolver contract\\n     */\\n    constructor(address _productResolver) public {\\n        owner = msg.sender;\\n        productResolver = IProductAddressResolver(_productResolver);\\n    }\\n\\n    struct PresentValueCalcLocalVars {\\n        bytes4 prefix;\\n        address controller;\\n        IMarketController controllerContract;\\n        address product;\\n        IProduct productContract;\\n    }\\n\\n    /**\\n     * @dev Triggers to update present value for a single deal.\\n     * @param dealId Deal ID to update PV for\\n     */\\n    function updatePV(bytes32 dealId) public override {\\n        address product = productResolver.getProductContractByDealId(dealId);\\n\\n        require(\\n            IProduct(product).markToMarket(dealId),\\n            \\\"CAN'T DO MARK-TO-MARKET\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Triggers to update present value for a multiple deals.\\n     * @param dealIds Array of Deal IDs to update PV for\\n     */\\n    function updatePVs(bytes32[] memory dealIds) public override {\\n        PresentValueCalcLocalVars memory vars;\\n\\n        for (uint256 i = 0; i < dealIds.length; i++) {\\n            bytes32 dealId = dealIds[i];\\n\\n            vars.product = productResolver.getProductContractByDealId(dealId);\\n            // vars.controller = productResolver.getControllerContract(vars.prefix);\\n\\n            require(\\n                IProduct(vars.product).markToMarket(dealId),\\n                \\\"CAN'T DO MARK-TO-MARKET\\\"\\n            );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xabc09f5a1b1e8d693399dff607e30d432bc2279079d196df284c2a65bddace26\",\"license\":\"MIT\"},\"contracts/ProtocolTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/**\\n * @dev ProtocolTypes is a base-level contract that holds common Secured Finance protocol types\\n * @author Secured Finance\\n */\\ncontract ProtocolTypes {\\n    // Constant values\\n    uint8 internal constant NUMCCY = 3;\\n    uint8 internal constant NUMTERM = 6;\\n    uint8 internal constant NUMDF = 7; // number of discount factors\\n    uint256 internal constant BP = 10000; // basis point\\n\\n    uint256 internal constant PCT = 10000; // percentage point in basis\\n    uint256 internal constant PENALTYLEVEL = 1000; // 10% settlement failure penalty\\n    uint256 internal constant MKTMAKELEVEL = 2000; // 20% for market making\\n\\n    // Lending market common types\\n    enum Side {\\n        LEND,\\n        BORROW\\n    }\\n    enum Ccy {\\n        ETH,\\n        FIL,\\n        USDC,\\n        BTC\\n    }\\n\\n    // Loan common types\\n    enum LoanState {\\n        REGISTERED,\\n        WORKING,\\n        DUE,\\n        PAST_DUE,\\n        CLOSED,\\n        TERMINATED\\n    }\\n    enum DFTERM {\\n        _3m,\\n        _6m,\\n        _1y,\\n        _2y,\\n        _3y,\\n        _4y,\\n        _5y\\n    }\\n\\n    // Collateral common types\\n    enum CollateralState {\\n        EMPTY,\\n        AVAILABLE,\\n        IN_USE,\\n        MARGIN_CALL,\\n        LIQUIDATION_IN_PROGRESS,\\n        LIQUIDATION\\n    }\\n\\n    // FXMarket common types\\n    enum CcyPair {\\n        FILETH,\\n        FILUSDC,\\n        ETHUSDC,\\n        BTCUSDC,\\n        BTCETH,\\n        BTCFIL\\n    }\\n    enum FXSide {\\n        BID,\\n        OFFER\\n    }\\n\\n    enum PaymentFrequency {\\n        ANNUAL,\\n        SEMI_ANNUAL,\\n        QUARTERLY,\\n        MONTHLY,\\n        FORWARD\\n    }\\n}\\n\",\"keccak256\":\"0x72de205a94aefa6e5b79074f603b8056535f99918af5112343156e79b7eadd83\",\"license\":\"MIT\"},\"contracts/interfaces/IMarkToMarket.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface IMarkToMarket {\\n    function updatePV(bytes32 dealId) external;\\n\\n    function updatePVs(bytes32[] memory dealIds) external;\\n}\\n\",\"keccak256\":\"0x12c4c499ec5de5155b58fd7e0396e88f629406ff3d3c44b4ecd7680c878b9b6e\",\"license\":\"MIT\"},\"contracts/interfaces/IMarketController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface IMarketController {\\n    function getBorrowRatesForCcy(bytes32 _ccy)\\n        external\\n        view\\n        returns (uint256[] memory rates);\\n\\n    function getDiscountFactorsForCcy(bytes32 _ccy)\\n        external\\n        view\\n        returns (uint256[] memory, uint256[] memory);\\n\\n    function getLendRatesForCcy(bytes32 _ccy)\\n        external\\n        view\\n        returns (uint256[] memory rates);\\n\\n    function getMidRatesForCcy(bytes32 _ccy)\\n        external\\n        view\\n        returns (uint256[] memory rates);\\n}\\n\",\"keccak256\":\"0xabb8748cb4cf4be02edb0cf3df5cc51ff19d5d59046c392d17953722cd881be0\",\"license\":\"MIT\"},\"contracts/interfaces/IPaymentAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nstruct Slot {\\n    uint256 totalPayment0;\\n    uint256 totalPayment1;\\n    uint256 netPayment;\\n    bool flipped;\\n    bytes32 paymentProof;\\n    address verificationParty;\\n    bool isSettled;\\n}\\n\\ninterface IPaymentAggregator {\\n    event UpdateCloseOutNetting(\\n        address indexed prevContract,\\n        address indexed closeOutNetting\\n    );\\n    event UpdateMarkToMarket(\\n        address indexed prevContract,\\n        address indexed closeOutNetting\\n    );\\n\\n    event RegisterPayment(\\n        address indexed party0,\\n        address indexed party1,\\n        bytes32 ccy,\\n        bytes32 timeSlot,\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 payment0,\\n        uint256 payment1\\n    );\\n    event VerifyPayment(\\n        address indexed verifier,\\n        address indexed counterparty,\\n        bytes32 ccy,\\n        bytes32 timeSlot,\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 payment,\\n        bytes32 txHash\\n    );\\n    event SettlePayment(\\n        address indexed verifier,\\n        address indexed counterparty,\\n        bytes32 ccy,\\n        bytes32 timeSlot,\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        bytes32 txHash\\n    );\\n    event RemovePayment(\\n        address indexed party0,\\n        address indexed party1,\\n        bytes32 ccy,\\n        bytes32 timeSlot,\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 payment0,\\n        uint256 payment1\\n    );\\n\\n    function addPaymentAggregatorUser(address _user) external returns (bool);\\n\\n    function isPaymentAggregatorUser(address _user)\\n        external\\n        view\\n        returns (bool);\\n\\n    function owner() external view returns (address);\\n\\n    function registerPayments(\\n        address party0,\\n        address party1,\\n        bytes32 ccy,\\n        bytes32 dealId,\\n        uint256[] memory timestamps,\\n        uint256[] memory payments0,\\n        uint256[] memory payments1\\n    ) external;\\n\\n    function removePaymentAggregatorUser(address _user) external returns (bool);\\n\\n    function removePayments(\\n        address party0,\\n        address party1,\\n        bytes32 ccy,\\n        bytes32 dealId,\\n        uint256[] calldata timestamps,\\n        uint256[] calldata payments0,\\n        uint256[] calldata payments1\\n    ) external;\\n\\n    function settlePayment(\\n        address verifier,\\n        address counterparty,\\n        bytes32 ccy,\\n        uint256 timestamp,\\n        bytes32 txHash\\n    ) external;\\n\\n    function verifyPayment(\\n        address verifier,\\n        address counterparty,\\n        bytes32 ccy,\\n        uint256 timestamp,\\n        uint256 payment,\\n        bytes32 txHash\\n    ) external;\\n\\n    function isSettled(\\n        address party0,\\n        address party1,\\n        bytes32 ccy,\\n        uint256 timestamp\\n    ) external view returns (bool status);\\n\\n    function getDealsFromSlot(\\n        address party0,\\n        address party1,\\n        bytes32 ccy,\\n        bytes32 slotPosition\\n    ) external view returns (bytes32[] memory);\\n\\n    // function getTimeSlotByDate(\\n    //     address party0,\\n    //     address party1,\\n    //     bytes32 ccy,\\n    //     uint256 year,\\n    //     uint256 month,\\n    //     uint256 day\\n    // ) external view returns (Slot memory timeSlot);\\n\\n    // function getTimeSlotBySlotId(\\n    //     address party0,\\n    //     address party1,\\n    //     bytes32 ccy,\\n    //     bytes32 slot\\n    // ) external view returns (Slot memory timeSlot);\\n\\n    function settlementWindow() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x26b01bf1c8f14e441ca8a531af8574cc4e551bcf347b09bcad8f160f3cb48bd0\",\"license\":\"MIT\"},\"contracts/interfaces/IProduct.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\n/**\\n * @title IProduct is a common interface for various products on secured finance protocol\\n */\\ninterface IProduct {\\n    event Liquidate(bytes32 dealId);\\n    event RequestTermination(bytes32 dealId, address indexed requestedBy);\\n    event RejectTermination(bytes32 dealId, address indexed rejectedBy);\\n    event EarlyTermination(\\n        bytes32 dealId,\\n        address indexed acceptedBy,\\n        uint256 payment\\n    );\\n    event MarkToMarket(bytes32 dealId, uint256 prevPV, uint256 currPV);\\n\\n    /**\\n     * Triggered to liquidate existing deal of this product type\\n     * @param dealId Deal unique id in bytes32 word.\\n     */\\n    function liquidate(bytes32 dealId) external;\\n\\n    /**\\n     * Triggered to request early termination of this specific deal\\n     * @param dealId Deal unique id in bytes32 word.\\n     */\\n    function requestTermination(bytes32 dealId) external;\\n\\n    /**\\n     * Triggered to reject previously requested early termination of this deal\\n     * @param dealId Deal unique id in bytes32 word.\\n     */\\n    function rejectTermination(bytes32 dealId) external;\\n\\n    /**\\n     * Triggered to accept previously requested early termination of this deal\\n     * @param dealId Deal unique id in bytes32 word.\\n     */\\n    function acceptTermination(bytes32 dealId) external;\\n\\n    /**\\n     * Triggered to update present value of the deal\\n     * @param dealId Deal unique id in bytes32 word.\\n     */\\n    function markToMarket(bytes32 dealId) external returns (bool);\\n\\n    // /**\\n    //  * Returns the state of the deal by `dealId`\\n    //  * @param dealId Deal unique id in bytes32 word.\\n    //  *\\n    //  * @return State identifier\\n    //  */\\n    // function getDealState(bytes32 dealId) external view returns (uint8);\\n\\n    /**\\n     * Returns the main currency of the deal.\\n     * @param dealId Deal unique id in bytes32 word.\\n     *\\n     * @return Currency short identifier.\\n     */\\n    function getDealCurrency(bytes32 dealId) external view returns (bytes32);\\n\\n    /**\\n     * Returns previously saved present value of the deal.\\n     * @param dealId Deal unique id in bytes32 word.\\n     *\\n     * @return Present value previously saved during mark-to-market.\\n     */\\n    function getDealLastPV(\\n        address party0,\\n        address party1,\\n        bytes32 dealId\\n    ) external view returns (uint256, uint256);\\n\\n    /**\\n     * Triggers to recalculate and return current present value of the deal.\\n     * @param dealId Deal unique id in bytes32 word.\\n     *\\n     * @return Present value at the time of execution.\\n     */\\n    function getDealPV(bytes32 dealId) external view returns (uint256);\\n\\n    /**\\n     * Returns settlement status of the deal by `dealId`\\n     * @param dealId Deal unique id in bytes32 word.\\n     *\\n     * @return Settlement bool identifier\\n     */\\n    function getDealSettlementStatus(bytes32 dealId)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * Get the version of the underlying contract.\\n     *\\n     * @return Version number.\\n     */\\n    function getVersion() external view returns (uint16);\\n}\\n\",\"keccak256\":\"0xc3cc3591cf950ec247fa500bb6c191e40f209052fb1738a989bfb12077fec837\",\"license\":\"MIT\"},\"contracts/interfaces/IProductAddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.6.12;\\n\\ninterface IProductAddressResolver {\\n    event RegisterProduct(\\n        bytes4 prefix,\\n        address indexed product,\\n        address indexed controller\\n    );\\n\\n    /**\\n     * @dev Trigers to register new product type in a address resolver\\n     * @param _prefix Bytes4 prefix for product type\\n     * @param _contract Product contract address\\n     * @param _controller Market controller address\\n     *\\n     * @notice Trigers only be contract owner\\n     * @notice Reverts on saving contract which is not supporting a common interface\\n     */\\n    function registerProduct(\\n        bytes4 _prefix,\\n        address _contract,\\n        address _controller\\n    ) external;\\n\\n    /**\\n     * @dev Trigers to register several product types in a address resolver\\n     * @param _prefixes Array of Bytes4 prefixes for each product type\\n     * @param _contracts Array of smart contract addresses for each product\\n     * @param _controllers Array of market controller addresses\\n     *\\n     * @notice Trigers only be contract owner\\n     * @notice Reverts on saving contract which is not supporting common interface\\n     */\\n    function registerProducts(\\n        bytes4[] calldata _prefixes,\\n        address[] calldata _contracts,\\n        address[] calldata _controllers\\n    ) external;\\n\\n    /**\\n     * @dev Trigers to get product address by short prefix.\\n     * @param _prefix Bytes4 prefix for product type\\n     * @notice To work with the contract this address should be wrapped around IProduct interface\\n     */\\n    function getProductContract(bytes4 _prefix) external view returns (address);\\n\\n    /**\\n     * @dev Trigers to get product address by deal id\\n     * @param _dealId Product deal idenfitier\\n     * @notice To work with the contract this address should be wrapped around IProduct interface\\n     */\\n    function getProductContractByDealId(bytes32 _dealId)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n     * @dev Trigers to get market controller address by short prefix.\\n     * @param _prefix Bytes4 prefix for product type\\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\\n     */\\n    function getControllerContract(bytes4 _prefix)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n     * @dev Trigers to get market controller address by deal id\\n     * @param _dealId Product deal idenfitier\\n     * @notice To work with the contract this address should be wrapped around IYieldCurve interface\\n     */\\n    function getControllerContractByDealId(bytes32 _dealId)\\n        external\\n        view\\n        returns (address);\\n\\n    /**\\n     * @dev Triggers to verify if a specific product is supported by short prefix.\\n     * @param _prefix Bytes4 prefix for product type\\n     */\\n    function isSupportedProduct(bytes4 _prefix) external view returns (bool);\\n\\n    /**\\n     * @dev Triggers to verify if a specific product is supported by deal id.\\n     * @param _dealId Product deal idenfitier\\n     */\\n    function isSupportedProductByDealId(bytes32 _dealId)\\n        external\\n        view\\n        returns (bool);\\n}\\n\",\"keccak256\":\"0x725c8887c2695629e6e6cda13d2ec086d58098b8c1de007efc2d74ee5dabd6ef\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506040516105ba3803806105ba83398101604081905261002f91610062565b60008054336001600160a01b031991821617909155600180549091166001600160a01b0392909216919091179055610090565b600060208284031215610073578081fd5b81516001600160a01b0381168114610089578182fd5b9392505050565b61051b8061009f6000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063175cfff4146100465780634d283d5c1461005b5780638da5cb5b1461006e575b600080fd5b610059610054366004610432565b61008c565b005b61005961006936600461037d565b6101b7565b610076610312565b604051610083919061044a565b60405180910390f35b600154604051634d86283f60e01b81526000916001600160a01b031690634d86283f906100bd90859060040161045e565b60206040518083038186803b1580156100d557600080fd5b505afa1580156100e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061010d919061034f565b604051639ad9a69160e01b81529091506001600160a01b03821690639ad9a6919061013c90859060040161045e565b602060405180830381600087803b15801561015657600080fd5b505af115801561016a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061018e9190610412565b6101b35760405162461bcd60e51b81526004016101aa90610467565b60405180910390fd5b5050565b6101bf610321565b60005b825181101561030d5760008382815181106101d957fe5b6020908102919091010151600154604051634d86283f60e01b81529192506001600160a01b031690634d86283f9061021590849060040161045e565b60206040518083038186803b15801561022d57600080fd5b505afa158015610241573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610265919061034f565b6001600160a01b031660608401819052604051639ad9a69160e01b8152639ad9a6919061029690849060040161045e565b602060405180830381600087803b1580156102b057600080fd5b505af11580156102c4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102e89190610412565b6103045760405162461bcd60e51b81526004016101aa90610467565b506001016101c2565b505050565b6000546001600160a01b031681565b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915290565b600060208284031215610360578081fd5b81516001600160a01b0381168114610376578182fd5b9392505050565b6000602080838503121561038f578182fd5b823567ffffffffffffffff8111156103a5578283fd5b8301601f810185136103b5578283fd5b80356103c86103c3826104c5565b61049e565b81815283810190838501858402850186018910156103e4578687fd5b8694505b838510156104065780358352600194909401939185019185016103e8565b50979650505050505050565b600060208284031215610423578081fd5b81518015158114610376578182fd5b600060208284031215610443578081fd5b5035919050565b6001600160a01b0391909116815260200190565b90815260200190565b60208082526017908201527f43414e275420444f204d41524b2d544f2d4d41524b4554000000000000000000604082015260600190565b60405181810167ffffffffffffffff811182821017156104bd57600080fd5b604052919050565b600067ffffffffffffffff8211156104db578081fd5b506020908102019056fea26469706673582212207690b78cf5b1d41d5a27f3be9056a56f3ea9787924929ff445dfa8281b825cd464736f6c634300060c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c8063175cfff4146100465780634d283d5c1461005b5780638da5cb5b1461006e575b600080fd5b610059610054366004610432565b61008c565b005b61005961006936600461037d565b6101b7565b610076610312565b604051610083919061044a565b60405180910390f35b600154604051634d86283f60e01b81526000916001600160a01b031690634d86283f906100bd90859060040161045e565b60206040518083038186803b1580156100d557600080fd5b505afa1580156100e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061010d919061034f565b604051639ad9a69160e01b81529091506001600160a01b03821690639ad9a6919061013c90859060040161045e565b602060405180830381600087803b15801561015657600080fd5b505af115801561016a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061018e9190610412565b6101b35760405162461bcd60e51b81526004016101aa90610467565b60405180910390fd5b5050565b6101bf610321565b60005b825181101561030d5760008382815181106101d957fe5b6020908102919091010151600154604051634d86283f60e01b81529192506001600160a01b031690634d86283f9061021590849060040161045e565b60206040518083038186803b15801561022d57600080fd5b505afa158015610241573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610265919061034f565b6001600160a01b031660608401819052604051639ad9a69160e01b8152639ad9a6919061029690849060040161045e565b602060405180830381600087803b1580156102b057600080fd5b505af11580156102c4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102e89190610412565b6103045760405162461bcd60e51b81526004016101aa90610467565b506001016101c2565b505050565b6000546001600160a01b031681565b6040805160a08101825260008082526020820181905291810182905260608101829052608081019190915290565b600060208284031215610360578081fd5b81516001600160a01b0381168114610376578182fd5b9392505050565b6000602080838503121561038f578182fd5b823567ffffffffffffffff8111156103a5578283fd5b8301601f810185136103b5578283fd5b80356103c86103c3826104c5565b61049e565b81815283810190838501858402850186018910156103e4578687fd5b8694505b838510156104065780358352600194909401939185019185016103e8565b50979650505050505050565b600060208284031215610423578081fd5b81518015158114610376578182fd5b600060208284031215610443578081fd5b5035919050565b6001600160a01b0391909116815260200190565b90815260200190565b60208082526017908201527f43414e275420444f204d41524b2d544f2d4d41524b4554000000000000000000604082015260600190565b60405181810167ffffffffffffffff811182821017156104bd57600080fd5b604052919050565b600067ffffffffffffffff8211156104db578081fd5b506020908102019056fea26469706673582212207690b78cf5b1d41d5a27f3be9056a56f3ea9787924929ff445dfa8281b825cd464736f6c634300060c0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "Contract constructor function."
      },
      "updatePV(bytes32)": {
        "details": "Triggers to update present value for a single deal.",
        "params": {
          "dealId": "Deal ID to update PV for"
        }
      },
      "updatePVs(bytes32[])": {
        "details": "Triggers to update present value for a multiple deals.",
        "params": {
          "dealIds": "Array of Deal IDs to update PV for"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "constructor": "sets contract deployer as owner of this contract and connects to product address resolver contract"
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 17465,
        "contract": "contracts/MarkToMarket.sol:MarkToMarket",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 17467,
        "contract": "contracts/MarkToMarket.sol:MarkToMarket",
        "label": "productResolver",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(IProductAddressResolver)22478"
      },
      {
        "astId": 17469,
        "contract": "contracts/MarkToMarket.sol:MarkToMarket",
        "label": "paymentAggregator",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IPaymentAggregator)22284"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(IPaymentAggregator)22284": {
        "encoding": "inplace",
        "label": "contract IPaymentAggregator",
        "numberOfBytes": "20"
      },
      "t_contract(IProductAddressResolver)22478": {
        "encoding": "inplace",
        "label": "contract IProductAddressResolver",
        "numberOfBytes": "20"
      }
    }
  }
}