// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import {EnumerableSet} from "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
// interfaces
import {ILendingMarket} from "../../interfaces/ILendingMarket.sol";
import {ILendingMarketController} from "../../interfaces/ILendingMarketController.sol";
import {IFutureValueVault} from "../../interfaces/IFutureValueVault.sol";
// libraries
import {AddressResolverLib} from "../AddressResolverLib.sol";
import {QuickSort} from "../QuickSort.sol";
import {Constants} from "../Constants.sol";
import {RoundingUint256} from "../math/RoundingUint256.sol";
import {RoundingInt256} from "../math/RoundingInt256.sol";
// types
import {ProtocolTypes} from "../../types/ProtocolTypes.sol";
// storages
import {LendingMarketControllerStorage as Storage} from "../../storages/LendingMarketControllerStorage.sol";
// liquidation
import {ILiquidationReceiver} from "../../../liquidators/interfaces/ILiquidationReceiver.sol";

library FundManagementLogic {
    using EnumerableSet for EnumerableSet.Bytes32Set;
    using EnumerableSet for EnumerableSet.UintSet;
    using SafeCast for uint256;
    using SafeCast for int256;
    using RoundingUint256 for uint256;
    using RoundingInt256 for int256;

    struct ExecuteLiquidationVars {
        address reserveFund;
        uint256 liquidationAmountInCollateralCcy;
        uint256 protocolFeeInCollateralCcy;
        uint256 liquidatorFeeInCollateralCcy;
        bool isDefaultMarket;
        bool isReserveFundPaused;
        uint256 receivedCollateralAmount;
        uint256 receivedDebtAmount;
    }

    struct CalculatedTotalFundInETHVars {
        bool[] isCollateral;
        bytes32 ccy;
        uint256[] amounts;
        uint256[] amountsInETH;
        uint256 plusDepositAmount;
        uint256 minusDepositAmount;
    }

    struct ActualFunds {
        int256 presentValue;
        int256 futureValue;
        uint256 workingLendOrdersAmount;
        uint256 lentAmount;
        uint256 workingBorrowOrdersAmount;
        uint256 borrowedAmount;
        int256 genesisValue;
    }

    struct CalculateActualFundsVars {
        bool isTotal;
        address market;
        bool isDefaultMarket;
        uint256[] maturities;
    }

    struct FutureValueVaultFunds {
        int256 genesisValue;
        int256 presentValue;
        int256 futureValue;
    }

    struct InactiveBorrowOrdersFunds {
        int256 genesisValue;
        int256 presentValue;
        int256 futureValue;
        uint256 workingOrdersAmount;
        uint256 borrowedAmount;
    }

    struct InactiveLendOrdersFunds {
        int256 genesisValue;
        int256 presentValue;
        int256 futureValue;
        uint256 workingOrdersAmount;
        uint256 lentAmount;
    }

    event OrderFilled(
        address indexed taker,
        bytes32 indexed ccy,
        ProtocolTypes.Side side,
        uint256 indexed maturity,
        uint256 amount,
        uint256 futureValue
    );

    event OrdersFilledInAsync(
        address indexed taker,
        bytes32 indexed ccy,
        ProtocolTypes.Side side,
        uint256 indexed maturity,
        uint256 amount,
        uint256 futureValue
    );

    /**
     * @notice Converts the future value to the genesis value if there is balance in the past maturity.
     * @param _ccy Currency for pausing all lending markets
     * @param _user User's address
     * @return Current future value amount after update
     */
    function convertFutureValueToGenesisValue(
        bytes32 _ccy,
        uint256 _maturity,
        address _user
    ) public returns (int256) {
        address futureValueVault = Storage.slot().futureValueVaults[_ccy][
            Storage.slot().maturityLendingMarkets[_ccy][_maturity]
        ];
        (
            int256 removedAmount,
            int256 currentAmount,
            uint256 basisMaturity,
            bool isAllRemoved
        ) = IFutureValueVault(futureValueVault).removeFutureValue(_user, _maturity);

        if (removedAmount != 0) {
            // Overwrite the `removedAmount` with the unsettled amount left of the Genesis Value
            // to handle the fractional amount generated by the lazy evaluation.
            if (isAllRemoved) {
                AddressResolverLib.genesisValueVault().updateGenesisValueWithResidualAmount(
                    _ccy,
                    _user,
                    basisMaturity
                );
            } else {
                AddressResolverLib.genesisValueVault().updateGenesisValueWithFutureValue(
                    _ccy,
                    _user,
                    basisMaturity,
                    removedAmount
                );
            }
        }

        return currentAmount;
    }

    function unwind(
        bytes32 _ccy,
        uint256 _maturity,
        address _user
    )
        external
        returns (
            uint256 filledUnitPrice,
            uint256 filledAmount,
            uint256 filledFutureValue,
            ILendingMarket.PartiallyFilledOrder memory partiallyFilledOrder,
            ProtocolTypes.Side side
        )
    {
        int256 futureValue = calculateActualFunds(_ccy, _maturity, _user).futureValue;

        require(futureValue != 0, "Future Value is zero");

        if (futureValue > 0) {
            side = ProtocolTypes.Side.BORROW;
            (
                filledUnitPrice,
                filledAmount,
                filledFutureValue,
                partiallyFilledOrder
            ) = ILendingMarket(Storage.slot().maturityLendingMarkets[_ccy][_maturity]).unwind(
                side,
                _user,
                futureValue.toUint256()
            );
        } else if (futureValue < 0) {
            side = ProtocolTypes.Side.LEND;
            (
                filledUnitPrice,
                filledAmount,
                filledFutureValue,
                partiallyFilledOrder
            ) = ILendingMarket(Storage.slot().maturityLendingMarkets[_ccy][_maturity]).unwind(
                side,
                _user,
                (-futureValue).toUint256()
            );
        }
    }

    function executeLiquidation(
        address _liquidator,
        address _user,
        bytes32 _collateralCcy,
        bytes32 _debtCcy,
        uint256 _debtMaturity
    ) external returns (uint256 totalLiquidatedDebtAmount) {
        ExecuteLiquidationVars memory vars;

        int256 debtPVAmount = calculateActualFunds(_debtCcy, _debtMaturity, _user).presentValue;

        require(debtPVAmount < 0, "No debt in the selected maturity");

        (
            vars.liquidationAmountInCollateralCcy,
            vars.protocolFeeInCollateralCcy,
            vars.liquidatorFeeInCollateralCcy
        ) = AddressResolverLib.tokenVault().getLiquidationAmount(
            _user,
            _collateralCcy,
            AddressResolverLib.currencyController().convert(
                _debtCcy,
                _collateralCcy,
                (-debtPVAmount).toUint256()
            )
        );

        require(vars.liquidationAmountInCollateralCcy != 0, "User has enough collateral");

        totalLiquidatedDebtAmount = AddressResolverLib.currencyController().convert(
            _collateralCcy,
            _debtCcy,
            vars.liquidationAmountInCollateralCcy
        );

        vars.isDefaultMarket =
            Storage.slot().maturityLendingMarkets[_debtCcy][_debtMaturity] ==
            Storage.slot().lendingMarkets[_debtCcy][0];
        vars.isReserveFundPaused = AddressResolverLib.reserveFund().isPaused();
        vars.reserveFund = address(AddressResolverLib.reserveFund());

        // Transfer collateral from users to liquidators and reserve funds.
        vars.receivedCollateralAmount =
            vars.liquidationAmountInCollateralCcy +
            vars.liquidatorFeeInCollateralCcy;

        uint256 untransferredAmount = AddressResolverLib.tokenVault().transferFrom(
            _collateralCcy,
            _user,
            vars.reserveFund,
            vars.protocolFeeInCollateralCcy
        );

        // If `untransferredAmount` is not 0, the user has not enough deposit in the collateral currency.
        // Therefore, the liquidators and the reserve fund obtain zero-coupon bonds instead of the user's collateral.
        if (untransferredAmount > 0) {
            _transferFunds(_user, vars.reserveFund, _collateralCcy, untransferredAmount.toInt256());
            untransferredAmount = vars.receivedCollateralAmount;
        } else {
            untransferredAmount = AddressResolverLib.tokenVault().transferFrom(
                _collateralCcy,
                _user,
                _liquidator,
                vars.receivedCollateralAmount
            );
        }

        if (untransferredAmount > 0) {
            untransferredAmount = _transferFunds(
                _user,
                _liquidator,
                _collateralCcy,
                untransferredAmount.toInt256()
            ).toUint256();
        }

        // Cover insolvent amounts using reserve funds.
        if (untransferredAmount > 0 && !vars.isReserveFundPaused) {
            uint256 insolventAmountInDebtCcy = AddressResolverLib.currencyController().convert(
                _collateralCcy,
                _debtCcy,
                untransferredAmount
            );

            if (AddressResolverLib.tokenVault().getTotalCollateralAmount(_user) == 0) {
                insolventAmountInDebtCcy = _transferFunds(
                    vars.reserveFund,
                    _liquidator,
                    _debtCcy,
                    _debtMaturity,
                    insolventAmountInDebtCcy.toInt256(),
                    vars.isDefaultMarket
                ).toUint256();
            }

            totalLiquidatedDebtAmount -= insolventAmountInDebtCcy;
        }

        if (_liquidator.code.length > 0) {
            require(
                ILiquidationReceiver(_liquidator).executeOperationForCollateral(
                    _liquidator,
                    _user,
                    _collateralCcy,
                    vars.receivedCollateralAmount
                ),
                "Invalid operation execution"
            );
        }

        // Transfer the debt from users to liquidators
        if (totalLiquidatedDebtAmount > 0) {
            vars.receivedDebtAmount = totalLiquidatedDebtAmount;

            _transferFunds(
                _user,
                _liquidator,
                _debtCcy,
                _debtMaturity,
                -vars.receivedDebtAmount.toInt256(),
                vars.isDefaultMarket
            );

            if (_liquidator.code.length > 0) {
                require(
                    ILiquidationReceiver(_liquidator).executeOperationForDebt(
                        _liquidator,
                        _user,
                        _collateralCcy,
                        vars.receivedCollateralAmount,
                        _debtCcy,
                        _debtMaturity,
                        vars.receivedDebtAmount
                    ),
                    "Invalid operation execution"
                );
            }
        }
    }

    function updateFunds(
        bytes32 _ccy,
        uint256 _maturity,
        address _user,
        ProtocolTypes.Side _side,
        uint256 _filledFutureValue,
        uint256 _filledAmount,
        uint256 _feeFutureValue,
        bool _isTaker
    ) external {
        address futureValueVault = Storage.slot().futureValueVaults[_ccy][
            Storage.slot().maturityLendingMarkets[_ccy][_maturity]
        ];

        if (_side == ProtocolTypes.Side.BORROW) {
            AddressResolverLib.tokenVault().addDepositAmount(_user, _ccy, _filledAmount);
            IFutureValueVault(futureValueVault).addBorrowFutureValue(
                _user,
                _filledFutureValue + _feeFutureValue,
                _maturity,
                _isTaker
            );
        } else {
            AddressResolverLib.tokenVault().removeDepositAmount(_user, _ccy, _filledAmount);
            IFutureValueVault(futureValueVault).addLendFutureValue(
                _user,
                _filledFutureValue - _feeFutureValue,
                _maturity,
                _isTaker
            );
        }

        if (_feeFutureValue > 0) {
            address reserveFundAddr = address(AddressResolverLib.reserveFund());
            IFutureValueVault(futureValueVault).addLendFutureValue(
                reserveFundAddr,
                _feeFutureValue,
                _maturity,
                _side == ProtocolTypes.Side.LEND
            );

            registerCurrencyAndMaturity(_ccy, _maturity, reserveFundAddr);
        }

        emit OrderFilled(_user, _ccy, _side, _maturity, _filledAmount, _filledFutureValue);
    }

    function registerCurrencyAndMaturity(
        bytes32 _ccy,
        uint256 _maturity,
        address _user
    ) public {
        if (!Storage.slot().usedMaturities[_ccy][_user].contains(_maturity)) {
            Storage.slot().usedMaturities[_ccy][_user].add(_maturity);

            if (!Storage.slot().usedCurrencies[_user].contains(_ccy)) {
                Storage.slot().usedCurrencies[_user].add(_ccy);
            }
        }
    }

    function resetFunds(bytes32 _ccy, address _user) external returns (int256 amount) {
        // First, clean up future values and genesis values to redeem those amounts.
        cleanUpFunds(_ccy, _user);

        amount = calculateActualFunds(_ccy, 0, _user).presentValue;

        uint256[] memory maturities = Storage.slot().usedMaturities[_ccy][_user].values();
        for (uint256 j; j < maturities.length; j++) {
            IFutureValueVault(
                Storage.slot().futureValueVaults[_ccy][
                    Storage.slot().maturityLendingMarkets[_ccy][maturities[j]]
                ]
            ).resetFutureValue(_user);
        }

        AddressResolverLib.genesisValueVault().resetGenesisValue(_ccy, _user);
    }

    function addDepositAtMarketTerminationPrice(
        bytes32 _ccy,
        address _user,
        uint256 _amount
    ) external {
        bytes32[] memory collateralCurrencies = AddressResolverLib
            .tokenVault()
            .getCollateralCurrencies();

        uint256[] memory marketTerminationRatios = new uint256[](collateralCurrencies.length);
        uint256 marketTerminationRatioTotal;

        for (uint256 i; i < collateralCurrencies.length; i++) {
            bytes32 ccy = collateralCurrencies[i];
            marketTerminationRatios[i] = Storage.slot().marketTerminationRatios[ccy];
            marketTerminationRatioTotal += marketTerminationRatios[i];
        }

        uint256 amountInETH = _convertToETHAtMarketTerminationPrice(_ccy, _amount);

        for (uint256 i; i < collateralCurrencies.length; i++) {
            bytes32 ccy = collateralCurrencies[i];
            uint256 addedAmount = _convertFromETHAtMarketTerminationPrice(
                ccy,
                (amountInETH * marketTerminationRatios[i]).div(marketTerminationRatioTotal)
            );

            AddressResolverLib.tokenVault().addDepositAmount(_user, ccy, addedAmount);
        }
    }

    function removeDepositAtMarketTerminationPrice(
        bytes32 _ccy,
        address _user,
        uint256 _amount,
        bytes32 _collateralCcy
    ) external {
        require(
            AddressResolverLib.tokenVault().isCollateral(_collateralCcy),
            "Not registered as collateral"
        );

        uint256 depositAmount = AddressResolverLib.tokenVault().getDepositAmount(
            _user,
            _collateralCcy
        );

        uint256 removedAmount = _convertFromETHAtMarketTerminationPrice(
            _collateralCcy,
            _convertToETHAtMarketTerminationPrice(_ccy, _amount)
        );

        require(depositAmount >= removedAmount, "Not enough collateral");

        AddressResolverLib.tokenVault().removeDepositAmount(_user, _collateralCcy, removedAmount);
    }

    function calculateActualFunds(
        bytes32 _ccy,
        uint256 _maturity,
        address _user
    ) public view returns (ActualFunds memory actualFunds) {
        CalculateActualFundsVars memory vars;

        if (_maturity == 0) {
            vars.isTotal = true;
            vars.market = Storage.slot().lendingMarkets[_ccy][0];
            vars.isDefaultMarket = true;
        } else {
            vars.isTotal = false;
            vars.market = Storage.slot().maturityLendingMarkets[_ccy][_maturity];
            vars.isDefaultMarket = vars.market == Storage.slot().lendingMarkets[_ccy][0];
        }
        actualFunds.genesisValue = AddressResolverLib.genesisValueVault().getGenesisValue(
            _ccy,
            _user
        );

        vars.maturities = getUsedMaturities(_ccy, _user);

        for (uint256 i = 0; i < vars.maturities.length; i++) {
            address currentMarket = Storage.slot().maturityLendingMarkets[_ccy][vars.maturities[i]];
            uint256 currentMaturity = ILendingMarket(currentMarket).getMaturity();
            bool isDefaultMarket = currentMarket == Storage.slot().lendingMarkets[_ccy][0];

            if (vars.isDefaultMarket || currentMarket == vars.market) {
                // Get current funds from Future Value Vault by lazy evaluations.
                FutureValueVaultFunds memory futureValueVaultFunds = _getFundsFromFutureValueVault(
                    _ccy,
                    _user,
                    vars,
                    currentMaturity,
                    currentMarket,
                    isDefaultMarket
                );
                // Get current funds from borrowing orders by lazy evaluations.
                InactiveBorrowOrdersFunds
                    memory borrowOrdersFunds = _getFundsFromInactiveBorrowOrders(
                        _ccy,
                        _user,
                        vars,
                        currentMaturity,
                        currentMarket,
                        isDefaultMarket
                    );
                // Get current funds from lending orders by lazy evaluations.
                InactiveLendOrdersFunds memory lendOrdersFunds = _getFundsFromInactiveLendOrders(
                    _ccy,
                    _user,
                    vars,
                    currentMaturity,
                    currentMarket,
                    isDefaultMarket
                );

                actualFunds.genesisValue +=
                    futureValueVaultFunds.genesisValue -
                    borrowOrdersFunds.genesisValue +
                    lendOrdersFunds.genesisValue;

                actualFunds.futureValue +=
                    futureValueVaultFunds.futureValue -
                    borrowOrdersFunds.futureValue +
                    lendOrdersFunds.futureValue;

                actualFunds.presentValue +=
                    futureValueVaultFunds.presentValue -
                    borrowOrdersFunds.presentValue +
                    lendOrdersFunds.presentValue;

                actualFunds.workingBorrowOrdersAmount += borrowOrdersFunds.workingOrdersAmount;
                actualFunds.workingLendOrdersAmount += lendOrdersFunds.workingOrdersAmount;
                actualFunds.borrowedAmount += borrowOrdersFunds.borrowedAmount;
                actualFunds.lentAmount += lendOrdersFunds.lentAmount;

                // Get balance fluctuation amount by auto-rolls
                if (actualFunds.genesisValue < 0) {
                    int256 fluctuation = AddressResolverLib
                        .genesisValueVault()
                        .calculateBalanceFluctuationByAutoRolls(
                            _ccy,
                            actualFunds.genesisValue,
                            vars.maturities[i],
                            i == vars.maturities.length - 1 ? 0 : vars.maturities[i + 1]
                        );

                    actualFunds.genesisValue += fluctuation;
                }
            }
        }

        // Add GV to PV & FV if the market is that the lending position is rolled to.
        if (vars.isDefaultMarket && actualFunds.genesisValue != 0) {
            int256 futureValue = AddressResolverLib.genesisValueVault().calculateFVFromGV(
                _ccy,
                0,
                actualFunds.genesisValue
            );
            actualFunds.presentValue += _calculatePVFromFV(
                futureValue,
                ILendingMarket(Storage.slot().lendingMarkets[_ccy][0]).getMidUnitPrice()
            );
            actualFunds.futureValue += futureValue;
        }
    }

    function calculateFunds(bytes32 _ccy, address _user)
        public
        view
        returns (
            uint256 workingLendOrdersAmount,
            uint256 claimableAmount,
            uint256 collateralAmount,
            uint256 lentAmount,
            uint256 workingBorrowOrdersAmount,
            uint256 debtAmount,
            uint256 borrowedAmount
        )
    {
        ActualFunds memory funds = calculateActualFunds(_ccy, 0, _user);
        workingLendOrdersAmount = funds.workingLendOrdersAmount;
        lentAmount = funds.lentAmount;
        workingBorrowOrdersAmount = funds.workingBorrowOrdersAmount;
        borrowedAmount = funds.borrowedAmount;

        if (funds.presentValue > 0) {
            claimableAmount = (funds.presentValue).toUint256();
            uint256 haircut = AddressResolverLib.currencyController().getHaircut(_ccy);
            collateralAmount = (claimableAmount * haircut).div(Constants.PCT_DIGIT);
        } else if (funds.presentValue < 0) {
            debtAmount = (-funds.presentValue).toUint256();
        }
    }

    function calculateTotalFundsInETH(
        address _user,
        bytes32 _depositCcy,
        uint256 _depositAmount
    )
        external
        view
        returns (
            uint256 totalWorkingLendOrdersAmount,
            uint256 totalClaimableAmount,
            uint256 totalCollateralAmount,
            uint256 totalLentAmount,
            uint256 totalWorkingBorrowOrdersAmount,
            uint256 totalDebtAmount,
            uint256 totalBorrowedAmount,
            bool isEnoughDeposit
        )
    {
        EnumerableSet.Bytes32Set storage currencySet = Storage.slot().usedCurrencies[_user];
        CalculatedTotalFundInETHVars memory vars;

        vars.isCollateral = AddressResolverLib.tokenVault().isCollateral(currencySet.values());
        vars.plusDepositAmount = _depositAmount;

        // Calculate total funds from the user's order list
        for (uint256 i = 0; i < currencySet.length(); i++) {
            vars.ccy = currencySet.at(i);
            vars.amounts = new uint256[](7);

            // 0: workingLendOrdersAmount
            // 1: claimableAmount
            // 2: collateralAmount
            // 3: lentAmount
            // 4: workingBorrowOrdersAmount
            // 5: debtAmount
            // 6: borrowedAmount
            (
                vars.amounts[0],
                vars.amounts[1],
                vars.amounts[2],
                vars.amounts[3],
                vars.amounts[4],
                vars.amounts[5],
                vars.amounts[6]
            ) = calculateFunds(vars.ccy, _user);

            if (vars.ccy == _depositCcy) {
                // plusDepositAmount: depositAmount + borrowedAmount
                // minusDepositAmount: workingLendOrdersAmount + lentAmount
                vars.plusDepositAmount += vars.amounts[6];
                vars.minusDepositAmount += vars.amounts[0] + vars.amounts[3];
            }

            vars.amountsInETH = AddressResolverLib.currencyController().convertToBaseCurrency(
                vars.ccy,
                vars.amounts
            );

            totalClaimableAmount += vars.amountsInETH[1];
            totalCollateralAmount += vars.amountsInETH[2];
            totalWorkingBorrowOrdersAmount += vars.amountsInETH[4];
            totalDebtAmount += vars.amountsInETH[5];

            // NOTE: Lent amount and working lend orders amount are excluded here as they are not used
            // for the collateral calculation.
            // Those amounts need only to check whether there is enough deposit amount in the selected currency.
            if (vars.isCollateral[i]) {
                totalWorkingLendOrdersAmount += vars.amountsInETH[0];
                totalLentAmount += vars.amountsInETH[3];
                totalBorrowedAmount += vars.amountsInETH[6];
            }
        }

        // Check if the user has enough collateral in the selected currency.
        isEnoughDeposit = vars.plusDepositAmount >= vars.minusDepositAmount;
    }

    function getUsedMaturities(bytes32 _ccy, address _user)
        public
        view
        returns (uint256[] memory maturities)
    {
        maturities = Storage.slot().usedMaturities[_ccy][_user].values();
        if (maturities.length > 0) {
            maturities = QuickSort.sort(maturities);
        }
    }

    function cleanUpFunds(bytes32 _ccy, address _user)
        public
        returns (uint256 totalActiveOrderCount)
    {
        bool futureValueExists = false;
        uint256[] memory maturities = getUsedMaturities(_ccy, _user);

        for (uint256 j = 0; j < maturities.length; j++) {
            ILendingMarket market = ILendingMarket(
                Storage.slot().maturityLendingMarkets[_ccy][maturities[j]]
            );
            uint256 activeMaturity = market.getMaturity();
            int256 currentFutureValue = convertFutureValueToGenesisValue(
                _ccy,
                activeMaturity,
                _user
            );
            (uint256 activeOrderCount, bool isCleaned) = _cleanUpOrders(
                _ccy,
                activeMaturity,
                _user
            );

            totalActiveOrderCount += activeOrderCount;

            if (isCleaned) {
                currentFutureValue = convertFutureValueToGenesisValue(_ccy, activeMaturity, _user);
            }

            if (currentFutureValue != 0) {
                futureValueExists = true;
            }

            if (currentFutureValue == 0 && activeOrderCount == 0) {
                Storage.slot().usedMaturities[_ccy][_user].remove(maturities[j]);
            }

            AddressResolverLib.genesisValueVault().cleanUpGenesisValue(
                _ccy,
                _user,
                j == maturities.length - 1 ? 0 : maturities[j + 1]
            );
        }

        if (
            totalActiveOrderCount == 0 &&
            !futureValueExists &&
            AddressResolverLib.genesisValueVault().getGenesisValue(_ccy, _user) == 0
        ) {
            Storage.slot().usedCurrencies[_user].remove(_ccy);
        }
    }

    function _cleanUpOrders(
        bytes32 _ccy,
        uint256 _maturity,
        address _user
    ) internal returns (uint256 activeOrderCount, bool isCleaned) {
        address futureValueVault = Storage.slot().futureValueVaults[_ccy][
            Storage.slot().maturityLendingMarkets[_ccy][_maturity]
        ];

        (
            uint256 activeLendOrderCount,
            uint256 activeBorrowOrderCount,
            uint256 removedLendOrderFutureValue,
            uint256 removedBorrowOrderFutureValue,
            uint256 removedLendOrderAmount,
            uint256 removedBorrowOrderAmount,
            uint256 userCurrentMaturity
        ) = ILendingMarket(Storage.slot().maturityLendingMarkets[_ccy][_maturity]).cleanUpOrders(
                _user
            );

        if (removedLendOrderAmount > removedBorrowOrderAmount) {
            AddressResolverLib.tokenVault().removeDepositAmount(
                _user,
                _ccy,
                removedLendOrderAmount - removedBorrowOrderAmount
            );
        } else if (removedLendOrderAmount < removedBorrowOrderAmount) {
            AddressResolverLib.tokenVault().addDepositAmount(
                _user,
                _ccy,
                removedBorrowOrderAmount - removedLendOrderAmount
            );
        }

        if (removedLendOrderFutureValue > 0) {
            IFutureValueVault(futureValueVault).addLendFutureValue(
                _user,
                removedLendOrderFutureValue,
                userCurrentMaturity,
                false
            );
            emit OrdersFilledInAsync(
                _user,
                _ccy,
                ProtocolTypes.Side.LEND,
                userCurrentMaturity,
                removedLendOrderAmount,
                removedLendOrderFutureValue
            );
        }

        if (removedBorrowOrderFutureValue > 0) {
            IFutureValueVault(futureValueVault).addBorrowFutureValue(
                _user,
                removedBorrowOrderFutureValue,
                userCurrentMaturity,
                false
            );
            emit OrdersFilledInAsync(
                _user,
                _ccy,
                ProtocolTypes.Side.BORROW,
                userCurrentMaturity,
                removedBorrowOrderAmount,
                removedBorrowOrderFutureValue
            );
        }

        isCleaned = (removedLendOrderFutureValue + removedBorrowOrderFutureValue) > 0;
        activeOrderCount = activeLendOrderCount + activeBorrowOrderCount;
    }

    function _getFundsFromFutureValueVault(
        bytes32 _ccy,
        address _user,
        CalculateActualFundsVars memory vars,
        uint256 currentMaturity,
        address currentMarket,
        bool isDefaultMarket
    ) internal view returns (FutureValueVaultFunds memory funds) {
        (int256 futureValueInMaturity, uint256 fvMaturity) = IFutureValueVault(
            Storage.slot().futureValueVaults[_ccy][currentMarket]
        ).getFutureValue(_user);

        if (futureValueInMaturity != 0) {
            if (currentMaturity != fvMaturity) {
                if (vars.isDefaultMarket) {
                    funds.genesisValue = AddressResolverLib.genesisValueVault().calculateGVFromFV(
                        _ccy,
                        fvMaturity,
                        futureValueInMaturity
                    );
                }
            } else if (currentMaturity == fvMaturity) {
                if (vars.isTotal && !isDefaultMarket) {
                    (funds.presentValue, funds.futureValue) = _calculatePVandFVInDefaultMarket(
                        _ccy,
                        fvMaturity,
                        futureValueInMaturity
                    );
                } else if (vars.isTotal || !vars.isDefaultMarket || isDefaultMarket) {
                    funds.futureValue = futureValueInMaturity;
                    funds.presentValue = _calculatePVFromFV(
                        _ccy,
                        fvMaturity,
                        futureValueInMaturity
                    );
                }
            }
        }
    }

    function _getFundsFromInactiveBorrowOrders(
        bytes32 _ccy,
        address _user,
        CalculateActualFundsVars memory vars,
        uint256 currentMaturity,
        address currentMarket,
        bool isDefaultMarket
    ) internal view returns (InactiveBorrowOrdersFunds memory funds) {
        uint256 filledFutureValue;
        uint256 orderMaturity;
        (
            funds.workingOrdersAmount,
            funds.borrowedAmount,
            filledFutureValue,
            orderMaturity
        ) = ILendingMarket(currentMarket).getTotalAmountFromBorrowOrders(_user);

        if (filledFutureValue != 0) {
            if (currentMaturity != orderMaturity) {
                if (vars.isDefaultMarket) {
                    funds.genesisValue = AddressResolverLib.genesisValueVault().calculateGVFromFV(
                        _ccy,
                        orderMaturity,
                        filledFutureValue.toInt256()
                    );
                }
            } else if (currentMaturity == orderMaturity) {
                if (vars.isTotal && !isDefaultMarket) {
                    (funds.presentValue, funds.futureValue) = _calculatePVandFVInDefaultMarket(
                        _ccy,
                        orderMaturity,
                        filledFutureValue.toInt256()
                    );
                } else if (vars.isTotal || !vars.isDefaultMarket || isDefaultMarket) {
                    funds.futureValue = filledFutureValue.toInt256();
                    funds.presentValue = _calculatePVFromFV(_ccy, orderMaturity, funds.futureValue);
                }
            }
        }
    }

    function _getFundsFromInactiveLendOrders(
        bytes32 _ccy,
        address _user,
        CalculateActualFundsVars memory vars,
        uint256 currentMaturity,
        address currentMarket,
        bool isDefaultMarket
    ) internal view returns (InactiveLendOrdersFunds memory funds) {
        uint256 filledFutureValue;
        uint256 orderMaturity;
        (
            funds.workingOrdersAmount,
            funds.lentAmount,
            filledFutureValue,
            orderMaturity
        ) = ILendingMarket(currentMarket).getTotalAmountFromLendOrders(_user);

        if (filledFutureValue != 0) {
            if (currentMaturity != orderMaturity) {
                if (vars.isDefaultMarket) {
                    funds.genesisValue += AddressResolverLib.genesisValueVault().calculateGVFromFV(
                        _ccy,
                        orderMaturity,
                        filledFutureValue.toInt256()
                    );
                }
            } else if (currentMaturity == orderMaturity) {
                if (vars.isTotal && !isDefaultMarket) {
                    (funds.presentValue, funds.futureValue) = _calculatePVandFVInDefaultMarket(
                        _ccy,
                        orderMaturity,
                        filledFutureValue.toInt256()
                    );
                } else if (vars.isTotal || !vars.isDefaultMarket || isDefaultMarket) {
                    funds.futureValue = filledFutureValue.toInt256();
                    funds.presentValue = _calculatePVFromFV(_ccy, orderMaturity, funds.futureValue);
                }
            }
        }
    }

    function _calculatePVandFVInDefaultMarket(
        bytes32 _ccy,
        uint256 _maturity,
        int256 _futureValueInMaturity
    ) internal view returns (int256 presentValue, int256 futureValue) {
        address destinationMarket = Storage.slot().lendingMarkets[_ccy][0];
        uint256 unitPriceInDestinationMaturity = ILendingMarket(destinationMarket)
            .getMidUnitPrice();

        if (AddressResolverLib.genesisValueVault().getAutoRollLog(_ccy, _maturity).unitPrice == 0) {
            presentValue = _calculatePVFromFV(_ccy, _maturity, _futureValueInMaturity);
            futureValue = (presentValue * Constants.PRICE_DIGIT.toInt256()).div(
                unitPriceInDestinationMaturity.toInt256()
            );
        } else {
            futureValue = AddressResolverLib.genesisValueVault().calculateFVFromFV(
                _ccy,
                _maturity,
                0,
                _futureValueInMaturity
            );
            presentValue = _calculatePVFromFV(futureValue, unitPriceInDestinationMaturity);
        }
    }

    function _calculatePVFromFV(
        bytes32 _ccy,
        uint256 _maturity,
        int256 _futureValue
    ) internal view returns (int256 presentValue) {
        uint256 unitPriceInBasisMaturity = ILendingMarket(
            Storage.slot().maturityLendingMarkets[_ccy][_maturity]
        ).getMidUnitPrice();
        presentValue = _calculatePVFromFV(_futureValue, unitPriceInBasisMaturity);
    }

    function _calculateFVFromPV(
        bytes32 _ccy,
        uint256 _maturity,
        int256 _presentValue
    ) internal view returns (int256) {
        int256 unitPrice = ILendingMarket(Storage.slot().maturityLendingMarkets[_ccy][_maturity])
            .getMidUnitPrice()
            .toInt256();

        // NOTE: The formula is: futureValue = presentValue / unitPrice.
        return (_presentValue * Constants.PRICE_DIGIT.toInt256()).div(unitPrice);
    }

    function _calculatePVFromFV(int256 _futureValue, uint256 _unitPrice)
        internal
        pure
        returns (int256)
    {
        // NOTE: The formula is: presentValue = futureValue * unitPrice.
        return (_futureValue * _unitPrice.toInt256()).div(Constants.PRICE_DIGIT.toInt256());
    }

    function _convertToETHAtMarketTerminationPrice(bytes32 _ccy, uint256 _amount)
        internal
        view
        returns (uint256)
    {
        if (_ccy == "ETH") {
            return _amount;
        } else {
            uint8 decimals = AddressResolverLib.currencyController().getDecimals(_ccy);

            return
                (_amount * Storage.slot().marketTerminationPrices[_ccy].toUint256()).div(
                    (10**decimals)
                );
        }
    }

    function _convertFromETHAtMarketTerminationPrice(bytes32 _ccy, uint256 _amount)
        internal
        view
        returns (uint256)
    {
        if (_ccy == "ETH") {
            return _amount;
        } else {
            uint8 decimals = AddressResolverLib.currencyController().getDecimals(_ccy);
            return
                (_amount * 10**decimals).div(
                    Storage.slot().marketTerminationPrices[_ccy].toUint256()
                );
        }
    }

    function _transferFunds(
        address _from,
        address _to,
        bytes32 _ccy,
        int256 _amount
    ) internal returns (int256 untransferredAmount) {
        uint256[] memory maturities = getUsedMaturities(_ccy, _from);
        address defaultMarketAddress = Storage.slot().lendingMarkets[_ccy][0];
        untransferredAmount = _amount;

        for (uint256 i; i < maturities.length; i++) {
            if (untransferredAmount == 0) {
                break;
            }

            untransferredAmount = _transferFunds(
                _from,
                _to,
                _ccy,
                maturities[i],
                untransferredAmount,
                Storage.slot().maturityLendingMarkets[_ccy][maturities[i]] == defaultMarketAddress
            );
        }
    }

    function _transferFunds(
        address _from,
        address _to,
        bytes32 _ccy,
        uint256 _maturity,
        int256 _amount,
        bool _isDefaultMarket
    ) internal returns (int256 untransferredAmount) {
        untransferredAmount = _amount;
        bool isDebt = _amount < 0;

        if (_isDefaultMarket) {
            int256 userGVAmount = AddressResolverLib.genesisValueVault().getGenesisValue(
                _ccy,
                _from
            );

            if ((isDebt && userGVAmount < 0) || (!isDebt && userGVAmount > 0)) {
                uint256 currentMaturity = AddressResolverLib.genesisValueVault().getCurrentMaturity(
                    _ccy
                );

                int256 gvAmount = AddressResolverLib.genesisValueVault().calculateGVFromFV(
                    _ccy,
                    0,
                    _calculateFVFromPV(_ccy, currentMaturity, untransferredAmount)
                );

                if ((isDebt && userGVAmount > gvAmount) || (!isDebt && userGVAmount < gvAmount)) {
                    gvAmount = userGVAmount;
                }

                // Due to the negative genesis value, the liquidator's genesis value is decreased.
                AddressResolverLib.genesisValueVault().transferFrom(_ccy, _from, _to, gvAmount);

                untransferredAmount -= _calculatePVFromFV(
                    _ccy,
                    currentMaturity,
                    AddressResolverLib.genesisValueVault().calculateFVFromGV(_ccy, 0, gvAmount)
                );
            }
        }

        IFutureValueVault futureValueVault = IFutureValueVault(
            Storage.slot().futureValueVaults[_ccy][
                Storage.slot().maturityLendingMarkets[_ccy][_maturity]
            ]
        );

        (int256 userFVAmount, ) = futureValueVault.getFutureValue(_from);

        if ((isDebt && userFVAmount < 0) || (!isDebt && userFVAmount > 0)) {
            int256 fvAmount = _calculateFVFromPV(_ccy, _maturity, untransferredAmount);

            if ((isDebt && userFVAmount > fvAmount) || (!isDebt && userFVAmount < fvAmount)) {
                fvAmount = userFVAmount;
            }

            futureValueVault.transferFrom(_from, _to, fvAmount, _maturity);
            untransferredAmount -= _calculatePVFromFV(_ccy, _maturity, fvAmount);
        }

        if (_amount != untransferredAmount) {
            registerCurrencyAndMaturity(_ccy, _maturity, _to);
        }
    }
}
